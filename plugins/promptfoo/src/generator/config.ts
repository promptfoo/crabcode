/**
 * Promptfoo Config Generator
 *
 * Generates YAML configuration files for promptfoo.
 */

import { stringify as yamlStringify } from 'yaml';
import * as fs from 'node:fs';
import * as path from 'node:path';
import type { ProviderConfig } from '../types.js';

export interface GenerateConfigOptions {
  description: string;
  providerType: 'http' | 'file:./provider.js' | 'file:./provider.py';
  providerConfig: Record<string, unknown>;
  envVars?: Record<string, string>;
  outputDir?: string;
  filename?: string;
}

export interface GeneratedConfig {
  yaml: string;
  filePath: string;
  envVars: Record<string, string>;
}

/**
 * Generate a promptfoo YAML config
 */
export function generateConfig(options: GenerateConfigOptions): GeneratedConfig {
  const {
    description,
    providerType,
    providerConfig,
    envVars = {},
    outputDir = '.',
    filename = 'promptfooconfig.yaml',
  } = options;

  // Validate providerConfig has required fields for http provider
  if (providerType === 'http' && (!providerConfig || Object.keys(providerConfig).length === 0)) {
    throw new Error(
      'providerConfig is required for http provider. Must include url, method, body, and responseParser.'
    );
  }

  // Build provider section
  let provider: ProviderConfig | string;

  if (providerType === 'http') {
    provider = {
      id: 'http',
      config: providerConfig,
    };
  } else {
    // Custom provider file - just use the file path as string
    provider = providerType;
  }

  // Build the full config
  const config = {
    description,
    providers: [provider],
    // Default test with the prompt variable
    defaultTest: {
      vars: {
        prompt: '{{prompt}}',
      },
    },
    // Mini redteam for verification
    redteam: {
      plugins: ['harmful:hate'],
      strategies: [
        { id: 'jailbreak' },
        {
          id: 'jailbreak:composite',
          config: {
            maxTurns: 3,
          },
        },
      ],
      numTests: 1,
    },
  };

  // Generate YAML
  const yaml = yamlStringify(config, {
    lineWidth: 0, // Don't wrap lines
    defaultStringType: 'QUOTE_DOUBLE',
    defaultKeyType: 'PLAIN',
  });

  // Add header comment
  const header = `# Promptfoo Target Configuration
# Generated by crab-pf target discovery agent
#
# Description: ${description}
#
# Required environment variables:
${Object.entries(envVars).map(([k, v]) => `#   ${k}: ${v}`).join('\n') || '#   (none)'}
#
# Run with:
#   promptfoo eval
#
`;

  const fullYaml = header + yaml;

  // Write the file
  const filePath = path.join(outputDir, filename);
  fs.writeFileSync(filePath, fullYaml, 'utf-8');

  return {
    yaml: fullYaml,
    filePath,
    envVars,
  };
}

/**
 * Write a custom provider file
 */
export function writeProviderFile(options: {
  code: string;
  filename: string;
  outputDir?: string;
}): string {
  const { code, filename, outputDir = '.' } = options;

  // Add header comment
  const header = filename.endsWith('.py')
    ? `# Custom Promptfoo Provider
# Generated by crab-pf target discovery agent
#
# This provider handles communication with the target.
# Edit as needed for your specific use case.
#

`
    : `/**
 * Custom Promptfoo Provider
 * Generated by crab-pf target discovery agent
 *
 * This provider handles communication with the target.
 * Edit as needed for your specific use case.
 */

`;

  const fullCode = header + code;
  const filePath = path.join(outputDir, filename);

  fs.writeFileSync(filePath, fullCode, 'utf-8');

  return filePath;
}

/**
 * Generate a simple HTTP provider config
 */
export function generateHttpProvider(options: {
  url: string;
  method: string;
  headers: Record<string, string>;
  body: unknown;
  promptField: string;
  responseField: string;
}): Record<string, unknown> {
  const { url, method, headers, body, promptField, responseField } = options;

  // Replace the prompt field value with the template variable
  const bodyTemplate = replaceInObject(body, promptField, '{{prompt}}');

  return {
    url,
    method,
    headers,
    body: bodyTemplate,
    responseParser: `json.${responseField}`,
  };
}

/**
 * Replace a value in a nested object by field path
 */
function replaceInObject(obj: unknown, fieldPath: string, replacement: string): unknown {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  const result = Array.isArray(obj) ? [...obj] : { ...obj };
  const parts = fieldPath.split('.');
  let current: Record<string, unknown> = result as Record<string, unknown>;

  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    if (current[part] && typeof current[part] === 'object') {
      current[part] = { ...(current[part] as Record<string, unknown>) };
      current = current[part] as Record<string, unknown>;
    } else {
      return result;
    }
  }

  const lastPart = parts[parts.length - 1];
  current[lastPart] = replacement;

  return result;
}
