/**
 * Promptfoo Config Generator
 *
 * Generates YAML configuration files for promptfoo.
 */

import { stringify as yamlStringify } from 'yaml';
import * as fs from 'node:fs';
import * as path from 'node:path';
import type { ProviderConfig } from '../types.js';

export interface GenerateConfigOptions {
  description: string;
  providerType: 'http' | 'file:./provider.js' | 'file:./provider.py';
  providerConfig: Record<string, unknown>;
  envVars?: Record<string, string>;
  outputDir?: string;
  filename?: string;
}

export interface GeneratedConfig {
  yaml: string;
  filePath: string;
  envVars: Record<string, string>;
}

/**
 * Generate a promptfoo YAML config
 */
export function generateConfig(options: GenerateConfigOptions): GeneratedConfig {
  const {
    description,
    providerType,
    providerConfig,
    envVars = {},
    outputDir = '.',
    filename = 'promptfooconfig.yaml',
  } = options;

  // Validate providerConfig has required fields for http provider
  if (providerType === 'http' && (!providerConfig || Object.keys(providerConfig).length === 0)) {
    throw new Error(
      'providerConfig is required for http provider. Must include url, method, body, and responseParser.'
    );
  }

  // Build provider section
  let provider: ProviderConfig | string;

  if (providerType === 'http') {
    provider = {
      id: 'http',
      config: providerConfig,
    };
  } else {
    // Custom provider file - strip 'file:' prefix, use relative path
    // e.g., 'file:./provider.js' -> './provider.js'
    provider = providerType.replace(/^file:/, '');
  }

  // Build the full config
  const config = {
    description,
    providers: [provider],
    prompts: ['{{prompt}}'],
    defaultTest: {
      assert: [
        { type: 'javascript', value: 'output && output.length > 0' },
      ],
    },
    tests: [
      { vars: { prompt: 'Hello, how are you?' } },
      { vars: { prompt: 'What can you help me with?' } },
    ],
  };

  // Generate YAML
  const yaml = yamlStringify(config, {
    lineWidth: 0, // Don't wrap lines
    defaultStringType: 'QUOTE_DOUBLE',
    defaultKeyType: 'PLAIN',
  });

  // Add header comment
  const header = `# Promptfoo Target Configuration
# Generated by crab-pf target discovery agent
#
# Description: ${description}
#
# Required environment variables:
${Object.entries(envVars).map(([k, v]) => `#   ${k}: ${v}`).join('\n') || '#   (none)'}
#
# Run with:
#   promptfoo eval
#
`;

  const fullYaml = header + yaml;

  // Write the file
  const filePath = path.join(outputDir, filename);
  fs.writeFileSync(filePath, fullYaml, 'utf-8');

  return {
    yaml: fullYaml,
    filePath,
    envVars,
  };
}

/**
 * Write a custom provider file and package.json with dependencies
 */
export function writeProviderFile(options: {
  code: string;
  filename: string;
  outputDir?: string;
}): string {
  const { code, filename, outputDir = '.' } = options;

  // Add header comment
  const header = filename.endsWith('.py')
    ? `# Custom Promptfoo Provider
# Generated by crab-pf target discovery agent
#
# This provider handles communication with the target.
# Edit as needed for your specific use case.
#

`
    : `/**
 * Custom Promptfoo Provider
 * Generated by crab-pf target discovery agent
 *
 * This provider handles communication with the target.
 * Edit as needed for your specific use case.
 */

`;

  const fullCode = header + code;
  const filePath = path.join(outputDir, filename);

  fs.writeFileSync(filePath, fullCode, 'utf-8');

  // For JS providers, detect and create package.json with dependencies
  if (filename.endsWith('.js')) {
    const deps = detectDependencies(code);
    if (Object.keys(deps).length > 0) {
      const packageJson = {
        name: 'promptfoo-provider',
        version: '1.0.0',
        type: 'module',
        dependencies: deps,
      };
      const packagePath = path.join(outputDir, 'package.json');
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2), 'utf-8');
    }
  }

  return filePath;
}

/**
 * Detect npm dependencies from import statements in code
 */
function detectDependencies(code: string): Record<string, string> {
  const deps: Record<string, string> = {};

  // Match: import X from 'package' or import { X } from 'package'
  const importRegex = /import\s+(?:[\w{}\s,*]+)\s+from\s+['"]([^'"./][^'"]*)['"]/g;
  let match;

  while ((match = importRegex.exec(code)) !== null) {
    const pkg = match[1];
    // Skip node built-ins
    if (!pkg.startsWith('node:')) {
      // Common package versions
      const versions: Record<string, string> = {
        ws: '^8.18.0',
        'node-fetch': '^3.3.0',
        axios: '^1.6.0',
      };
      deps[pkg] = versions[pkg] || '*';
    }
  }

  return deps;
}

/**
 * Generate a simple HTTP provider config
 */
export function generateHttpProvider(options: {
  url: string;
  method: string;
  headers: Record<string, string>;
  body: unknown;
  promptField: string;
  responseField: string;
}): Record<string, unknown> {
  const { url, method, headers, body, promptField, responseField } = options;

  // Replace the prompt field value with the template variable
  const bodyTemplate = replaceInObject(body, promptField, '{{prompt}}');

  return {
    url,
    method,
    headers,
    body: bodyTemplate,
    responseParser: `json.${responseField}`,
  };
}

/**
 * Replace a value in a nested object by field path
 */
function replaceInObject(obj: unknown, fieldPath: string, replacement: string): unknown {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  const result = Array.isArray(obj) ? [...obj] : { ...obj };
  const parts = fieldPath.split('.');
  let current: Record<string, unknown> = result as Record<string, unknown>;

  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    if (current[part] && typeof current[part] === 'object') {
      current[part] = { ...(current[part] as Record<string, unknown>) };
      current = current[part] as Record<string, unknown>;
    } else {
      return result;
    }
  }

  const lastPart = parts[parts.length - 1];
  current[lastPart] = replacement;

  return result;
}
