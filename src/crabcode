#!/usr/bin/env bash
# crabcode - Generic tmux-based workspace manager for multi-repo development
# https://github.com/your-org/crabcode
#
# Usage: crabcode [command] [arguments]
#
# Commands:
#   (no args)         List all workspaces
#   <N>               Open/create workspace N
#   <N> --separate    Open workspace N in separate terminal window
#   <N> cleanup       Kill window + reset to origin/main
#   <N> restart       Reset git + restart panes in place
#   <N> continue      Resume session with --continue flag
#   restart           Auto-detect workspace from cwd + restart
#   continue          Auto-detect workspace from cwd + resume
#   init              Setup config (auto-detects project type)
#   config            Show current configuration
#   config scan       Auto-detect .env files and ports
#   doctor            Diagnose common issues
#   cheat             Show cheat sheet / help
#   ports             Show port usage across workspaces
#   wip save          Save work in progress
#   wip ls            List saved WIP states
#   wip --continue    Restore most recent WIP
#   wip --resume      Interactive WIP selection
#   wip delete <name> Delete a WIP state

set -e

VERSION="0.8.0"
CONFIG_DIR="$HOME/.crabcode"
CONFIG_FILE="$CONFIG_DIR/config.yaml"
WIP_BASE="$CONFIG_DIR/wip"
PROJECTS_DIR="$CONFIG_DIR/projects"
GLOBAL_CONFIG="$CONFIG_DIR/config.yaml"
PROJECT_ALIAS=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# =============================================================================
# Utility Functions
# =============================================================================

error() {
  echo -e "${RED}Error: $*${NC}" >&2
}

warn() {
  echo -e "${YELLOW}Warning: $*${NC}" >&2
}

info() {
  echo -e "${CYAN}$*${NC}"
}

success() {
  echo -e "${GREEN}$*${NC}"
}

# Check if a command exists
command_exists() {
  command -v "$1" &>/dev/null
}

# =============================================================================
# Config Loading (using yq for YAML parsing)
# =============================================================================

# Check if yq is installed
check_yq() {
  if ! command_exists yq; then
    error "yq is required but not installed."
    echo "Install with:"
    echo "  brew install yq       # macOS"
    echo "  apt install yq        # Ubuntu/Debian"
    echo "  go install github.com/mikefarah/yq/v4@latest  # Go"
    exit 1
  fi
}

# Load a config value, with optional default
# Usage: config_get "path.to.value" "default"
config_get() {
  local path="$1"
  local default="${2:-}"
  local value

  if [ ! -f "$CONFIG_FILE" ]; then
    echo "$default"
    return
  fi

  value=$(yq -r ".$path // \"\"" "$CONFIG_FILE" 2>/dev/null)
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    echo "$default"
  else
    echo "$value"
  fi
}

# Check if config exists and is valid
config_exists() {
  [ -f "$CONFIG_FILE" ]
}

# Validate required config fields
validate_config() {
  local errors=0

  if ! config_exists; then
    if [ -n "${PROJECT_ALIAS:-}" ]; then
      error "Config not found for project @$PROJECT_ALIAS at $CONFIG_FILE"
    else
      error "No config file found at $CONFIG_FILE"
    fi
    echo "Run 'crabcode init' to create one."
    exit 1
  fi

  local session_name=$(config_get "session_name")
  local workspace_base=$(config_get "workspace_base")
  local main_repo=$(config_get "main_repo")

  if [ -z "$session_name" ]; then
    error "Missing required config: session_name"
    errors=$((errors + 1))
  fi

  if [ -z "$workspace_base" ]; then
    error "Missing required config: workspace_base"
    errors=$((errors + 1))
  fi

  if [ -z "$main_repo" ]; then
    error "Missing required config: main_repo"
    errors=$((errors + 1))
  fi

  if [ $errors -gt 0 ]; then
    echo ""
    echo "Run 'crabcode doctor' to diagnose issues."
    exit 1
  fi
}

# Sync MCP config from main repo to workspace
# Claude Code reads MCP servers from .mcp.json in the project directory
sync_mcp_servers() {
  local workspace_dir=$1
  local main_repo=$(config_get "main_repo" "")

  [ -z "$main_repo" ] && return

  # Copy .mcp.json if it exists in main repo (this is where Claude Code reads MCP config)
  if [ -f "$main_repo/.mcp.json" ]; then
    cp "$main_repo/.mcp.json" "$workspace_dir/.mcp.json"
    echo -e "${GREEN}Copied .mcp.json from main repo${NC}"
  fi
}

# Expand ~ and environment variables in paths
expand_path() {
  local path="$1"
  # Expand ~ to $HOME
  path="${path/#\~/$HOME}"
  # Expand environment variables
  eval echo "$path"
}

# =============================================================================
# Multi-Project Resolution
# =============================================================================

# Resolve project from @alias argument or fall back to default
# Sets CONFIG_FILE and PROJECT_ALIAS
resolve_project() {
  local arg="${1:-}"

  if [[ "$arg" == @* ]]; then
    local alias="${arg#@}"
    local project_file="$PROJECTS_DIR/${alias}.yaml"
    if [ ! -f "$project_file" ]; then
      error "No project registered with alias: @$alias"
      echo "Run 'crab projects' to see registered projects."
      exit 1
    fi
    CONFIG_FILE="$project_file"
    PROJECT_ALIAS="$alias"
    return
  fi

  # No @alias given — try to resolve default
  resolve_default_project
}

# Resolve the default project when no @alias is given
# Falls back to legacy config.yaml if no projects/ dir
resolve_default_project() {
  # If projects/ dir doesn't exist or is empty, keep legacy CONFIG_FILE
  if [ ! -d "$PROJECTS_DIR" ] || [ -z "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
    return
  fi

  # Check GLOBAL_CONFIG for default_project
  local default_alias=""
  if [ -f "$GLOBAL_CONFIG" ]; then
    default_alias=$(yq -r '.default_project // ""' "$GLOBAL_CONFIG" 2>/dev/null)
    [ "$default_alias" = "null" ] && default_alias=""
  fi

  if [ -n "$default_alias" ]; then
    local project_file="$PROJECTS_DIR/${default_alias}.yaml"
    if [ -f "$project_file" ]; then
      CONFIG_FILE="$project_file"
      PROJECT_ALIAS="$default_alias"
      return
    fi
    warn "Default project '@$default_alias' not found, ignoring."
  fi

  # If exactly 1 project exists, auto-select it
  local count=0
  local single_file=""
  for f in "$PROJECTS_DIR"/*.yaml; do
    [ -f "$f" ] || continue
    count=$((count + 1))
    single_file="$f"
  done

  if [ "$count" -eq 1 ]; then
    local alias=$(basename "$single_file" .yaml)
    CONFIG_FILE="$single_file"
    PROJECT_ALIAS="$alias"
    return
  fi

  # Multiple projects, no default — keep legacy CONFIG_FILE (will fail on validate if needed)
}

# List all registered project aliases
list_project_aliases() {
  if [ ! -d "$PROJECTS_DIR" ]; then
    return
  fi
  for f in "$PROJECTS_DIR"/*.yaml; do
    [ -f "$f" ] || continue
    local alias=$(basename "$f" .yaml)
    local repo=$(yq -r '.main_repo // ""' "$f" 2>/dev/null)
    echo "@$alias ($repo)"
  done
}

# Try to resolve the correct project from the current working directory
# Scans all project configs to find one whose workspace_base matches cwd
resolve_project_from_cwd() {
  local cwd=$(pwd)

  if [ ! -d "$PROJECTS_DIR" ]; then
    return 1
  fi

  for f in "$PROJECTS_DIR"/*.yaml; do
    [ -f "$f" ] || continue
    local ws_base=$(yq -r '.workspace_base // ""' "$f" 2>/dev/null)
    [ -z "$ws_base" ] || [ "$ws_base" = "null" ] && continue
    # Expand ~ in workspace_base
    ws_base="${ws_base/#\~/$HOME}"

    if [[ "$cwd" == "$ws_base"* ]]; then
      local alias=$(basename "$f" .yaml)
      CONFIG_FILE="$f"
      PROJECT_ALIAS="$alias"
      return 0
    fi

    # Also check main_repo (user might be in the main repo dir)
    local repo=$(yq -r '.main_repo // ""' "$f" 2>/dev/null)
    [ -z "$repo" ] || [ "$repo" = "null" ] && continue
    repo="${repo/#\~/$HOME}"

    if [[ "$cwd" == "$repo"* ]]; then
      local alias=$(basename "$f" .yaml)
      CONFIG_FILE="$f"
      PROJECT_ALIAS="$alias"
      return 0
    fi
  done

  return 1
}

# Check if we're in legacy single-project mode
is_legacy_config() {
  # Legacy = config.yaml has main_repo AND projects/ dir is empty/missing
  if [ ! -f "$CONFIG_DIR/config.yaml" ]; then
    return 1
  fi
  local has_main_repo=$(yq -r '.main_repo // ""' "$CONFIG_DIR/config.yaml" 2>/dev/null)
  if [ -z "$has_main_repo" ] || [ "$has_main_repo" = "null" ]; then
    return 1
  fi
  # Check projects dir
  if [ -d "$PROJECTS_DIR" ] && [ -n "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
    return 1
  fi
  return 0
}

# Prompt user to migrate legacy config.yaml → projects/<alias>.yaml
check_legacy_migration() {
  echo -e "${CYAN}Multi-project support detected.${NC}"
  echo ""
  echo "Your config at ~/.crabcode/config.yaml can be migrated to the new"
  echo "per-project format. This enables managing multiple repos with crab."
  echo ""
  read -p "Migrate now? [Y/n]: " migrate
  if [ "$migrate" = "n" ] || [ "$migrate" = "N" ]; then
    return
  fi

  # Ask for alias
  local repo_path=$(yq -r '.main_repo // ""' "$CONFIG_DIR/config.yaml" 2>/dev/null)
  local default_alias=$(basename "$repo_path" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g')
  echo ""
  read -p "Project alias [$default_alias]: " alias_input
  alias_input=${alias_input:-$default_alias}

  # Validate alias
  if ! [[ "$alias_input" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Alias must be alphanumeric (dashes and underscores allowed)"
    return 1
  fi

  # Create projects dir and copy config
  mkdir -p "$PROJECTS_DIR"
  cp "$CONFIG_DIR/config.yaml" "$PROJECTS_DIR/${alias_input}.yaml"

  # Rename tmux session if it's running under the old name
  local old_session=$(yq -r '.session_name // ""' "$PROJECTS_DIR/${alias_input}.yaml" 2>/dev/null)
  if [ -n "$old_session" ] && [ "$old_session" != "null" ] && [ "$old_session" != "$alias_input" ]; then
    if tmux has-session -t "$old_session" 2>/dev/null; then
      tmux rename-session -t "$old_session" "$alias_input" 2>/dev/null && \
        echo -e "  ${GREEN}Renamed tmux session: $old_session → $alias_input${NC}"
    fi
  fi

  # Update session_name in the project config to use the alias
  yq -i ".session_name = \"$alias_input\"" "$PROJECTS_DIR/${alias_input}.yaml"

  # Backup old config and create new global config
  cp "$CONFIG_DIR/config.yaml" "$CONFIG_DIR/config.yaml.bak"

  # Write new global config with just default_project
  cat > "$GLOBAL_CONFIG" << EOF
# Crabcode Global Configuration
default_project: $alias_input
EOF

  CONFIG_FILE="$PROJECTS_DIR/${alias_input}.yaml"
  PROJECT_ALIAS="$alias_input"

  echo ""
  success "Migrated to @$alias_input"
  echo "  Project config: $PROJECTS_DIR/${alias_input}.yaml"
  echo "  Backup: ~/.crabcode/config.yaml.bak"
  echo "  Default set to: @$alias_input"
  echo ""
}

# =============================================================================
# Config Variables (loaded lazily)
# =============================================================================

_config_loaded=false

load_config() {
  if [ "$_config_loaded" = true ]; then
    return
  fi

  check_yq

  if ! config_exists; then
    return
  fi

  SESSION_NAME=$(config_get "session_name" "crab")
  WORKSPACE_BASE=$(expand_path "$(config_get "workspace_base")")
  MAIN_REPO=$(expand_path "$(config_get "main_repo")")

  WORKSPACE_COUNT=$(config_get "workspaces.count" "5")
  WORKSPACE_PREFIX=$(config_get "workspaces.prefix" "workspace")
  BRANCH_PATTERN=$(config_get "workspaces.branch_pattern" "workspace-{N}")

  API_PORT_BASE=$(config_get "ports.api_base" "3200")
  APP_PORT_BASE=$(config_get "ports.app_base" "3000")

  # Shared volume settings
  SHARED_VOLUME_PATH=$(expand_path "$(config_get "shared_volume.path" "$CONFIG_DIR/shared")")
  SHARED_VOLUME_LINK=$(config_get "shared_volume.link_as" ".local")
  SHARED_VOLUME_ENABLED=$(config_get "shared_volume.enabled" "true")

  _config_loaded=true

  # WIP isolation: per-project WIP directories
  if [ -n "${PROJECT_ALIAS:-}" ]; then
    WIP_BASE="$CONFIG_DIR/wip/$PROJECT_ALIAS"
  fi
}

# =============================================================================
# Tmux Pane Helpers
# =============================================================================

# Get tmux pane indices based on pane-base-index setting
# Layout: terminal (top-left), main (right), server (bottom-left)
# Returns: "terminal_pane:main_pane:server_pane"
get_pane_indices() {
  local pane_base=$(tmux show-options -gv pane-base-index 2>/dev/null || echo "0")
  local p_terminal=$pane_base
  local p_server=$((pane_base + 1))
  local p_main=$((pane_base + 2))
  echo "$p_terminal:$p_main:$p_server"
}

# =============================================================================
# Port Management
# =============================================================================

# Find an available port starting from a base
find_available_port() {
  local base_port=$1
  local port=$base_port
  while lsof -i ":$port" &>/dev/null; do
    port=$((port + 1))
    # Safety limit - don't scan forever
    if [ $port -gt $((base_port + 100)) ]; then
      echo "$base_port"  # Give up, return original
      return
    fi
  done
  echo "$port"
}

# Get workspace ports (api and app) for workspace N
# Returns: api_port:app_port:need_override
get_workspace_ports() {
  local num=$1
  local dir=$2

  # Use port_spacing from config (default 10) for proper spacing between workspaces
  local port_spacing=$(yq -r '.env_sync.port_spacing // 10' "$CONFIG_FILE" 2>/dev/null)
  [ "$port_spacing" = "null" ] && port_spacing=10

  local default_api=$((API_PORT_BASE + (num * port_spacing)))
  local default_app=$((APP_PORT_BASE + (num * port_spacing)))

  # Read from .env if env_sync is configured
  local env_api=$(read_env_port "$dir" "api")
  local env_app=$(read_env_port "$dir" "app")

  [ -z "$env_api" ] && env_api="$default_api"
  [ -z "$env_app" ] && env_app="$default_app"

  local actual_api=$(find_available_port "$env_api")
  local actual_app=$(find_available_port "$env_app")

  local need_override="false"
  if [ "$actual_api" != "$env_api" ] || [ "$actual_app" != "$env_app" ]; then
    need_override="true"
  fi

  echo "$actual_api:$actual_app:$need_override:$env_api:$env_app"
}

# Read port from .env file based on env_sync config
read_env_port() {
  local dir=$1
  local port_type=$2  # "api" or "app"

  local env_files_count=$(yq -r '.env_sync.files | length // 0' "$CONFIG_FILE" 2>/dev/null)

  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local port_var=$(yq -r ".env_sync.files[$i].port_var" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    if [ -f "$full_path" ] && [ -n "$port_var" ] && [ "$port_var" != "null" ]; then
      local value=$(grep "^${port_var}=" "$full_path" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]')
      if [ -n "$value" ]; then
        # If it's a URL, extract port
        if [[ "$value" =~ :([0-9]+) ]]; then
          echo "${BASH_REMATCH[1]}"
          return
        elif [[ "$value" =~ ^[0-9]+$ ]]; then
          echo "$value"
          return
        fi
      fi
    fi
  done
}

# Sync .env files for a workspace
# New format supports:
#   - copy_from: template file to copy from
#   - ports: array of port vars to manage (increment per workspace)
#   - refs: map of URL vars that reference managed ports
sync_env_files() {
  local dir=$1
  local workspace_num=$2
  local quiet=${3:-false}

  local env_files_count=$(yq -r '.env_sync.files | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$env_files_count" = "0" ] && return

  # Temp file to store resolved ports (bash 3.x compatible)
  local ports_file=$(mktemp)
  trap "rm -f '$ports_file'" RETURN

  # First pass: resolve all managed ports
  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local copy_from=$(yq -r ".env_sync.files[$i].copy_from // \"\"" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    local template_path=""

    # Determine template path
    if [ -n "$copy_from" ] && [ "$copy_from" != "null" ]; then
      template_path="$dir/$copy_from"
    else
      # Fallback: look for .env.example
      template_path="$dir/${env_path}.example"
      [ ! -f "$template_path" ] && template_path="$dir/${env_path%.env}.env.example"
    fi

    # Create from template if target doesn't exist
    if [ ! -f "$full_path" ] && [ -f "$template_path" ]; then
      mkdir -p "$(dirname "$full_path")"
      cp "$template_path" "$full_path"
      [ "$quiet" != "true" ] && echo -e "  ${YELLOW}Created $env_path from template${NC}"
    fi

    # Skip if file still doesn't exist
    [ ! -f "$full_path" ] && continue

    # Get ports array (supports both old port_var and new ports[] format)
    local ports_json=$(yq -r ".env_sync.files[$i].ports // []" "$CONFIG_FILE" 2>/dev/null)
    local old_port_var=$(yq -r ".env_sync.files[$i].port_var // \"\"" "$CONFIG_FILE" 2>/dev/null)

    # Handle old format (port_var: single var)
    if [ -n "$old_port_var" ] && [ "$old_port_var" != "null" ]; then
      ports_json="[\"$old_port_var\"]"
    fi

    # Process each port var
    local ports_count=$(echo "$ports_json" | yq -r 'length // 0' 2>/dev/null)
    for ((p=0; p<ports_count; p++)); do
      local port_var=$(echo "$ports_json" | yq -r ".[$p]" 2>/dev/null)
      [ -z "$port_var" ] || [ "$port_var" = "null" ] && continue

      # ALWAYS read base value from main repo to get consistent base port
      # This prevents compounding port increments on repeated syncs
      local base_value=""
      local main_env="$MAIN_REPO/$env_path"
      [ -f "$main_env" ] && base_value=$(grep "^${port_var}=" "$main_env" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]"'"'")

      # Fallback to workspace .env only if main repo doesn't have it
      if [ -z "$base_value" ]; then
        base_value=$(grep "^${port_var}=" "$full_path" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]"'"'")
      fi

      # Also read current workspace value for updating
      local current_value=$(grep "^${port_var}=" "$full_path" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]"'"'")
      [ -z "$current_value" ] && current_value="$base_value"

      # Extract base port number from main repo value
      local base_port=""
      if echo "$base_value" | grep -qE '^[0-9]+$'; then
        base_port="$base_value"
      elif echo "$base_value" | grep -qE ':[0-9]+'; then
        base_port=$(echo "$base_value" | grep -oE ':[0-9]+' | tail -1 | tr -d ':')
      fi

      [ -z "$base_port" ] && continue

      # Get port spacing (default 10 to allow multiple services per workspace)
      local port_spacing=$(yq -r '.env_sync.port_spacing // 10' "$CONFIG_FILE" 2>/dev/null)
      [ "$port_spacing" = "null" ] && port_spacing=10

      # Calculate workspace port: base + (workspace_num * spacing)
      # This ensures each workspace has a range of ports to avoid collisions
      local new_port=$((base_port + (workspace_num * port_spacing)))

      # Check if port is available, find next free if not
      while lsof -i ":$new_port" &>/dev/null; do
        new_port=$((new_port + 1))
        # Safety limit - stay within this workspace's range
        if [ $new_port -gt $((base_port + (workspace_num * port_spacing) + port_spacing - 1)) ]; then
          new_port=$((base_port + (workspace_num * port_spacing)))
          break
        fi
      done

      # Store resolved port for refs lookup
      echo "$port_var=$new_port" >> "$ports_file"

      # Update the .env file
      local new_value
      if echo "$current_value" | grep -qE '^[0-9]+$'; then
        new_value="$new_port"
      else
        # Replace port in URL/string
        new_value=$(echo "$current_value" | sed "s/:${base_port}/:${new_port}/g")
      fi

      if [ "$current_value" != "$new_value" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
          sed -i '' "s|^${port_var}=.*|${port_var}=$new_value|" "$full_path"
        else
          sed -i "s|^${port_var}=.*|${port_var}=$new_value|" "$full_path"
        fi
        [ "$quiet" != "true" ] && echo -e "  ${GREEN}$env_path: $port_var → $new_port${NC}"
      fi
    done
  done

  # Second pass: process refs (URL vars that reference managed ports)
  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    [ ! -f "$full_path" ] && continue

    # Get refs map
    local refs_keys=$(yq -r ".env_sync.files[$i].refs // {} | keys | .[]" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$refs_keys" ] && continue

    echo "$refs_keys" | while read -r ref_var; do
      [ -z "$ref_var" ] && continue

      local ref_source=$(yq -r ".env_sync.files[$i].refs[\"$ref_var\"]" "$CONFIG_FILE" 2>/dev/null)
      [ -z "$ref_source" ] || [ "$ref_source" = "null" ] && continue

      # Check for :port suffix (e.g., API_URL:port extracts just the port number)
      local extract_port_only=false
      local ref_port_var="$ref_source"
      if [[ "$ref_source" == *":port" ]]; then
        extract_port_only=true
        ref_port_var="${ref_source%:port}"
      fi

      # Look up the resolved port
      local resolved_port=$(grep "^${ref_port_var}=" "$ports_file" 2>/dev/null | cut -d= -f2)
      [ -z "$resolved_port" ] && continue

      # Read current value
      local current_value=$(grep "^${ref_var}=" "$full_path" 2>/dev/null | cut -d= -f2-)

      if [ "$extract_port_only" = true ]; then
        # Set target to plain port number
        if [ "$current_value" != "$resolved_port" ]; then
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s|^${ref_var}=.*|${ref_var}=$resolved_port|" "$full_path"
          else
            sed -i "s|^${ref_var}=.*|${ref_var}=$resolved_port|" "$full_path"
          fi
          [ "$quiet" != "true" ] && echo -e "  ${GREEN}$env_path: $ref_var → $resolved_port${NC}"
        fi
      else
        # Replace port in URL (existing behavior)
        [ -z "$current_value" ] && continue

        # Extract current port from URL
        local current_port=$(echo "$current_value" | grep -oE ':[0-9]+' | tail -1 | tr -d ':')
        [ -z "$current_port" ] && continue

        if [ "$current_port" != "$resolved_port" ]; then
          local new_value=$(echo "$current_value" | sed "s/:${current_port}/:${resolved_port}/g")

          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s|^${ref_var}=.*|${ref_var}=$new_value|" "$full_path"
          else
            sed -i "s|^${ref_var}=.*|${ref_var}=$new_value|" "$full_path"
          fi
          [ "$quiet" != "true" ] && echo -e "  ${GREEN}$env_path: $ref_var → :$resolved_port${NC}"
        fi
      fi
    done
  done
}

# Show port usage across all workspaces
show_ports() {
  load_config
  validate_config

  echo -e "${CYAN}Port Usage Across Workspaces${NC}"
  echo ""
  printf "  %-20s %-8s %-8s %-20s\n" "WORKSPACE" "API" "APP" "STATUS"
  echo "  ────────────────────────────────────────────────────────"

  for ((i=1; i<=WORKSPACE_COUNT; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ ! -d "$dir" ]; then
      continue
    fi

    local port_spacing=$(yq -r '.env_sync.port_spacing // 10' "$CONFIG_FILE" 2>/dev/null)
    [ "$port_spacing" = "null" ] && port_spacing=10
    local default_api=$((API_PORT_BASE + (i * port_spacing)))
    local default_app=$((APP_PORT_BASE + (i * port_spacing)))
    local api_port=$(read_env_port "$dir" "api")
    local app_port=$(read_env_port "$dir" "app")
    [ -z "$api_port" ] && api_port="$default_api"
    [ -z "$app_port" ] && app_port="$default_app"

    # Check API port status
    local api_status="free"
    if lsof -i ":$api_port" &>/dev/null; then
      local pid=$(lsof -t -i ":$api_port" 2>/dev/null | head -1)
      local cwd=$(lsof -p "$pid" 2>/dev/null | grep cwd | awk '{print $NF}')
      if [[ "$cwd" == *"$WORKSPACE_PREFIX-$i"* ]]; then
        api_status="running"
      elif [[ "$cwd" == *"$WORKSPACE_PREFIX-"* ]]; then
        local other_ws=$(echo "$cwd" | grep -oE "${WORKSPACE_PREFIX}-[0-9]+" | sed "s/${WORKSPACE_PREFIX}-/ws/")
        api_status="TAKEN:$other_ws"
      else
        api_status="in-use"
      fi
    fi

    # Check APP port status
    local app_status="free"
    if lsof -i ":$app_port" &>/dev/null; then
      local pid=$(lsof -t -i ":$app_port" 2>/dev/null | head -1)
      local cwd=$(lsof -p "$pid" 2>/dev/null | grep cwd | awk '{print $NF}')
      if [[ "$cwd" == *"$WORKSPACE_PREFIX-$i"* ]]; then
        app_status="running"
      elif [[ "$cwd" == *"$WORKSPACE_PREFIX-"* ]]; then
        local other_ws=$(echo "$cwd" | grep -oE "${WORKSPACE_PREFIX}-[0-9]+" | sed "s/${WORKSPACE_PREFIX}-/ws/")
        app_status="TAKEN:$other_ws"
      else
        app_status="in-use"
      fi
    fi

    # Color code status
    local api_display app_display
    case "$api_status" in
      "free") api_display="${YELLOW}free${NC}" ;;
      "running") api_display="${GREEN}●${NC}" ;;
      TAKEN:*) api_display="${RED}${api_status}${NC}" ;;
      *) api_display="${YELLOW}busy${NC}" ;;
    esac
    case "$app_status" in
      "free") app_display="${YELLOW}free${NC}" ;;
      "running") app_display="${GREEN}●${NC}" ;;
      TAKEN:*) app_display="${RED}${app_status}${NC}" ;;
      *) app_display="${YELLOW}busy${NC}" ;;
    esac

    printf "  %-20s %-8s %-8s " "$WORKSPACE_PREFIX-$i" "$api_port" "$app_port"
    echo -e "API: $api_display  APP: $app_display"
  done
  echo ""
  echo -e "  Legend: ${GREEN}●${NC}=running  ${YELLOW}free${NC}=available  ${RED}TAKEN:wsN${NC}=conflict"
}

# =============================================================================
# Git Operations
# =============================================================================

# Get the branch name for workspace N
get_branch_name() {
  local num=$1
  echo "${BRANCH_PATTERN//\{N\}/$num}"
}

# Create workspace directory with git worktree
create_workspace() {
  local num=$1
  local workspace_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local branch_name=$(get_branch_name "$num")

  if [ -d "$workspace_dir" ]; then
    echo -e "  ${YELLOW}Workspace $num already exists${NC}"
    return 0
  fi

  echo -e "${CYAN}Creating workspace $num...${NC}"

  # Check if main repo exists
  if [ ! -d "$MAIN_REPO" ]; then
    error "Main repo not found at $MAIN_REPO"
    exit 1
  fi

  # Ensure workspace base exists
  mkdir -p "$WORKSPACE_BASE"

  # Create git worktree
  echo "  Creating git worktree..."
  cd "$MAIN_REPO"
  git fetch origin 2>/dev/null || true  # May fail if no remote

  # Check if branch exists
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git worktree add "$workspace_dir" "$branch_name"
  elif git show-ref --verify --quiet "refs/remotes/origin/main"; then
    git worktree add -b "$branch_name" "$workspace_dir" origin/main
  else
    # No origin/main - use current HEAD
    git worktree add -b "$branch_name" "$workspace_dir" HEAD
  fi

  # Initialize submodules if configured
  init_submodules "$workspace_dir"

  # Setup shared volume
  setup_shared_volume "$workspace_dir"

  # Sync .env files (pass workspace number for port calculation)
  sync_env_files "$workspace_dir" "$num"

  # Install dependencies (force install for new workspaces)
  local install_cmd=$(config_get "install_command" "")
  if [ -n "$install_cmd" ]; then
    echo -e "${YELLOW}Installing dependencies...${NC}"
    cd "$workspace_dir"
    # Get env vars from install_env config
    local install_env=$(config_get "install_env" "")
    local run_cmd="$install_cmd"
    if [ -n "$install_env" ] && [ "$install_env" != "null" ]; then
      # Prepend env var to command so it's passed to subprocesses
      run_cmd="$install_env $install_cmd"
    fi
    if bash -c "$run_cmd"; then
      touch "$workspace_dir/node_modules/.crabcode-installed"
      echo -e "${GREEN}Dependencies installed${NC}"
    else
      warn "Failed to install dependencies - run manually: $install_cmd"
    fi

    # Install submodule dependencies
    local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
    for ((i=0; i<submodules_count; i++)); do
      local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
      local sub_install=$(yq -r ".submodules[$i].install_command // \"\"" "$CONFIG_FILE" 2>/dev/null)
      [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue
      [ -z "$sub_install" ] || [ "$sub_install" = "null" ] && continue

      if [ -d "$workspace_dir/$sub_path" ]; then
        echo -e "${YELLOW}Installing $sub_path dependencies...${NC}"
        cd "$workspace_dir/$sub_path"
        # Prepend env var to submodule install command too
        local sub_run_cmd="$sub_install"
        if [ -n "$install_env" ] && [ "$install_env" != "null" ]; then
          sub_run_cmd="$install_env $sub_install"
        fi
        if bash -c "$sub_run_cmd"; then
          # Only touch marker if node_modules exists
          [ -d "node_modules" ] && touch "node_modules/.crabcode-installed"
        fi
        cd "$workspace_dir"
      fi
    done
  fi

  # Sync MCP servers from main repo to new workspace
  sync_mcp_servers "$workspace_dir"

  success "Workspace $num created at $workspace_dir"
}

# Initialize submodules in workspace
init_submodules() {
  local dir=$1

  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$submodules_count" = "0" ] && return

  cd "$dir"

  # Find the main git dir (worktrees share .git/modules with main repo)
  local git_dir=$(git rev-parse --git-common-dir 2>/dev/null)

  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local reset_to=$(yq -r ".submodules[$i].reset_to" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    # Check if submodule already exists in this worktree
    if [ -d "$dir/$sub_path/.git" ] || [ -f "$dir/$sub_path/.git" ]; then
      echo "  Submodule $sub_path already initialized"
      continue
    fi

    # FAST PATH: Copy submodule from main repo if it exists there
    # This is MUCH faster than git submodule update which re-checksout all files
    local main_sub="$MAIN_REPO/$sub_path"
    if [ -d "$main_sub" ] && { [ -d "$main_sub/.git" ] || [ -f "$main_sub/.git" ]; }; then
      echo "  Copying submodule: $sub_path (fast copy from main repo)"

      # Remove empty directory if exists
      [ -d "$dir/$sub_path" ] && rm -rf "$dir/$sub_path"

      # Copy the submodule directory (uses copy-on-write on APFS/modern filesystems)
      cp -R "$MAIN_REPO/$sub_path" "$dir/$sub_path"

      # Fix the .git file to point to the shared modules dir
      # Submodules use a .git file (not directory) pointing to ../.git/modules/name
      if [ -f "$dir/$sub_path/.git" ]; then
        # Update gitdir path to point to shared modules
        local modules_dir="$git_dir/modules/$sub_path"
        if [ -d "$modules_dir" ]; then
          echo "gitdir: $modules_dir" > "$dir/$sub_path/.git"
        fi
      fi
    else
      # SLOW PATH: Fall back to git submodule update
      local modules_dir="$git_dir/modules/$sub_path"
      if [ -d "$modules_dir" ]; then
        echo "  Checking out submodule: $sub_path (using cached git data)"
        git submodule update "$sub_path" 2>/dev/null || git submodule update --init "$sub_path" 2>/dev/null || true
      else
        echo "  Fetching submodule: $sub_path (first time, may take a moment)"
        git submodule update --init "$sub_path" 2>/dev/null || true
      fi
    fi

    # Reset to configured ref if specified
    if [ -n "$reset_to" ] && [ "$reset_to" != "null" ] && [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      # Only fetch if the ref doesn't exist locally
      if ! git rev-parse --verify "$reset_to" &>/dev/null; then
        echo "  Fetching $reset_to for $sub_path..."
        git fetch origin --quiet 2>/dev/null || true
      fi
      git checkout main 2>/dev/null || git checkout -b main 2>/dev/null || true
      git reset --hard "$reset_to" 2>/dev/null || true
      cd "$dir"
    fi
  done
}

# Reset submodules to configured state
reset_submodules() {
  local dir=$1

  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$submodules_count" = "0" ] && return

  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local reset_to=$(yq -r ".submodules[$i].reset_to" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      echo "  Resetting submodule: $sub_path"
      cd "$dir/$sub_path"
      git checkout -- . 2>/dev/null || true
      git clean -fd 2>/dev/null || true
      git checkout main 2>/dev/null || git checkout -b main origin/main 2>/dev/null || true
      git fetch origin main --quiet 2>/dev/null || true
      if [ -n "$reset_to" ] && [ "$reset_to" != "null" ]; then
        git reset --hard "$reset_to"
      else
        git reset --hard origin/main
      fi
      cd "$dir"
      echo -e "  ${GREEN}Submodule $sub_path reset${NC}"
    fi
  done
}

# =============================================================================
# Shared Volume Management
# =============================================================================

# Setup shared volume symlink in a workspace
# Handles migration of existing .local directories
setup_shared_volume() {
  local dir=$1

  # Skip if shared volume is disabled
  if [ "$SHARED_VOLUME_ENABLED" != "true" ]; then
    return 0
  fi

  local link_name="$SHARED_VOLUME_LINK"
  local link_path="$dir/$link_name"
  local shared_path="$SHARED_VOLUME_PATH"

  # Create shared volume directory if it doesn't exist
  if [ ! -d "$shared_path" ]; then
    echo "  Creating shared volume at $shared_path..."
    mkdir -p "$shared_path"
  fi

  # Check current state of link path
  if [ -L "$link_path" ]; then
    # Already a symlink - check if it points to the right place
    local current_target=$(readlink "$link_path")
    if [ "$current_target" = "$shared_path" ]; then
      # Already correctly linked
      return 0
    else
      # Wrong target - remove and recreate
      echo "  Updating $link_name symlink..."
      rm "$link_path"
    fi
  elif [ -d "$link_path" ]; then
    # Existing directory - migrate contents to shared volume
    echo "  Migrating existing $link_name to shared volume..."

    # Copy contents to shared volume (preserving existing shared files)
    if [ "$(ls -A "$link_path" 2>/dev/null)" ]; then
      # Directory has contents - migrate them
      local migrated=0
      for item in "$link_path"/*; do
        [ ! -e "$item" ] && continue
        local basename=$(basename "$item")
        if [ -e "$shared_path/$basename" ]; then
          # File/dir exists in shared - create workspace-specific backup
          local ws_name=$(basename "$dir")
          local backup_name="${basename}.from-${ws_name}"
          echo "    $basename exists in shared, saving as $backup_name"
          mv "$item" "$shared_path/$backup_name"
        else
          echo "    Moving $basename to shared volume"
          mv "$item" "$shared_path/"
        fi
        migrated=$((migrated + 1))
      done
      if [ $migrated -gt 0 ]; then
        echo -e "  ${GREEN}Migrated $migrated item(s) to shared volume${NC}"
      fi
    fi

    # Remove the now-empty directory
    rmdir "$link_path" 2>/dev/null || rm -rf "$link_path"
  elif [ -e "$link_path" ]; then
    # Some other file type - backup and remove
    echo "  Backing up existing $link_name..."
    mv "$link_path" "$link_path.backup.$(date +%Y%m%d%H%M%S)"
  fi

  # Create symlink
  ln -s "$shared_path" "$link_path"
  echo -e "  ${GREEN}Linked $link_name → $shared_path${NC}"

  # Add to .gitignore if not already there
  local gitignore="$dir/.gitignore"
  if [ -f "$gitignore" ]; then
    if ! grep -q "^${link_name}$" "$gitignore" 2>/dev/null; then
      echo "" >> "$gitignore"
      echo "# Shared local volume (crabcode)" >> "$gitignore"
      echo "$link_name" >> "$gitignore"
      echo "  Added $link_name to .gitignore"
    fi
  else
    # Create .gitignore with the link name
    echo "# Shared local volume (crabcode)" > "$gitignore"
    echo "$link_name" >> "$gitignore"
    echo "  Created .gitignore with $link_name"
  fi
}

# =============================================================================
# Workspace Operations
# =============================================================================

# List all workspaces
list_workspaces() {
  load_config

  echo -e "${CYAN}Crabcode Workspaces${NC}"
  echo ""

  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo ""
    echo "Run 'crabcode init' to set up crabcode."
    return
  fi

  validate_config

  # Check if main session exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${GREEN}Active session: $SESSION_NAME${NC}"
    echo "Windows:"
    tmux list-windows -t "$SESSION_NAME" 2>/dev/null | while read -r line; do
      echo "  $line"
    done
    echo ""
  else
    echo -e "${YELLOW}No active $SESSION_NAME session.${NC}"
    echo ""
  fi

  echo -e "${YELLOW}Available workspaces:${NC}"
  local found=false

  # Find all existing workspaces (may be more than configured count)
  local max_ws=$WORKSPACE_COUNT
  for dir in "$WORKSPACE_BASE/$WORKSPACE_PREFIX-"*; do
    if [ -d "$dir" ]; then
      local num=$(basename "$dir" | sed "s/${WORKSPACE_PREFIX}-//")
      if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -gt "$max_ws" ]; then
        max_ws=$num
      fi
    fi
  done

  for ((i=1; i<=max_ws; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ -d "$dir" ]; then
      found=true
      local branch=$(cd "$dir" && git branch --show-current 2>/dev/null || echo "unknown")
      local port_spacing=$(yq -r '.env_sync.port_spacing // 10' "$CONFIG_FILE" 2>/dev/null)
      [ "$port_spacing" = "null" ] && port_spacing=10
      local api_port=$((API_PORT_BASE + (i * port_spacing)))
      local env_port=$(read_env_port "$dir" "api")
      [ -n "$env_port" ] && api_port="$env_port"

      # Check if this workspace has a window in the session
      local status="${YELLOW}[available]${NC}"
      if tmux has-session -t "$SESSION_NAME" 2>/dev/null && \
         tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^ws$i$"; then
        status="${GREEN}[active]${NC}"
      fi
      echo -e "  $i: $WORKSPACE_PREFIX-$i ($branch) :$api_port $status"
    fi
  done

  if [ "$found" = false ]; then
    echo "  No workspaces found."
    echo ""
    echo "Run 'crab ws new' or 'crab ws 1' to create a workspace."
  fi
}

# Interactive workspace menu
interactive_workspace_menu() {
  load_config

  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo ""
    echo "Run 'crab init' to set up crabcode."
    return
  fi

  validate_config

  # Show workspaces
  echo -e "${CYAN}Crabcode Workspaces${NC}"
  echo ""

  # Check if main session exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${GREEN}Active session: $SESSION_NAME${NC}"
    echo "Windows:"
    tmux list-windows -t "$SESSION_NAME" 2>/dev/null | while read -r line; do
      echo "  $line"
    done
    echo ""
  else
    echo -e "${YELLOW}No active $SESSION_NAME session.${NC}"
    echo ""
  fi

  # Find all existing workspaces
  local max_ws=$WORKSPACE_COUNT
  local existing_workspaces=""
  for dir in "$WORKSPACE_BASE/$WORKSPACE_PREFIX-"*; do
    if [ -d "$dir" ]; then
      local num=$(basename "$dir" | sed "s/${WORKSPACE_PREFIX}-//")
      if [[ "$num" =~ ^[0-9]+$ ]]; then
        existing_workspaces="$existing_workspaces $num"
        [ "$num" -gt "$max_ws" ] && max_ws=$num
      fi
    fi
  done

  echo -e "${YELLOW}Workspaces:${NC}"
  local found=false
  for ((i=1; i<=max_ws; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ -d "$dir" ]; then
      found=true
      local branch=$(cd "$dir" && git branch --show-current 2>/dev/null || echo "unknown")
      local port_spacing=$(yq -r '.env_sync.port_spacing // 10' "$CONFIG_FILE" 2>/dev/null)
      [ "$port_spacing" = "null" ] && port_spacing=10
      local api_port=$((API_PORT_BASE + (i * port_spacing)))
      local env_port=$(read_env_port "$dir" "api")
      [ -n "$env_port" ] && api_port="$env_port"

      local status="${YELLOW}[available]${NC}"
      if tmux has-session -t "$SESSION_NAME" 2>/dev/null && \
         tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^ws$i$"; then
        status="${GREEN}[active]${NC}"
      fi
      echo -e "  $i: $WORKSPACE_PREFIX-$i ($branch) :$api_port $status"
    fi
  done

  if [ "$found" = false ]; then
    echo "  (none created yet)"
  fi

  # Show menu
  echo ""
  echo -e "${CYAN}Actions:${NC}"
  echo "  [1-9] Open workspace    [n] New    [r] Restart    [c] Cleanup    [q] Quit"
  echo ""
  printf "  > "

  read -r choice

  case "$choice" in
    q|Q|quit|exit|"")
      return 0
      ;;
    n|N|new)
      create_new_workspace
      ;;
    r|R|restart)
      echo -n "  Restart which workspace? [1-9]: "
      read -r ws_num
      if [[ "$ws_num" =~ ^[0-9]+$ ]]; then
        restart_workspace "$ws_num"
      else
        error "Invalid workspace number"
      fi
      ;;
    c|C|cleanup)
      echo -n "  Cleanup which workspace? [1-9]: "
      read -r ws_num
      if [[ "$ws_num" =~ ^[0-9]+$ ]]; then
        cleanup_workspace "$ws_num"
      else
        error "Invalid workspace number"
      fi
      ;;
    *)
      if [[ "$choice" =~ ^[0-9]+$ ]]; then
        open_workspace "$choice"
      else
        error "Unknown option: $choice"
      fi
      ;;
  esac
}

# Open or create workspace
open_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  # Create if doesn't exist
  if [ ! -d "$dir" ]; then
    create_workspace "$num"
  fi

  # Get port info
  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)
  local env_api_port=$(echo "$port_info" | cut -d: -f4)

  # Check dependencies
  check_and_setup_workspace "$dir" "$num"

  # Build commands from config
  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  # Always ensure team context exists in CLAUDE.md
  local team_file="$dir/.claude/CLAUDE.md"
  mkdir -p "$dir/.claude"

  # Add team section if not present
  if ! grep -q "^## Team Mode$" "$team_file" 2>/dev/null; then
    cat >> "$team_file" << 'EOF'

## Team Mode

You can spawn agent teammates for complex tasks. Use the Task tool to create specialized agents (researcher, implementer, reviewer, debugger) that work in parallel. Coordinate the team, assign tasks, and synthesize results. Only spawn teams when the task benefits from parallel work.
EOF
  fi

  # Port override if needed
  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    echo -e "${YELLOW}  Port $env_api_port in use, using $api_port instead${NC}"
  fi

  local port_msg="Using port $env_api_port"
  [ "$need_override" = "true" ] && port_msg="Port $env_api_port in use → using $api_port"

  # Check if session exists
  if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    # Create new session
    echo -e "${CYAN}Starting $SESSION_NAME session with workspace $num...${NC}"
    echo "  Directory: $dir"
    echo -e "  ${YELLOW}$port_msg${NC}"

    create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "new"
    tmux attach -t "$SESSION_NAME"
  else
    # Session exists
    if tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
      echo -e "${CYAN}Switching to workspace $num...${NC}"
      if [ -n "$TMUX" ]; then
        tmux select-window -t "$SESSION_NAME:$window_name"
      else
        tmux attach -t "$SESSION_NAME" \; select-window -t "$window_name"
      fi
    else
      echo -e "${CYAN}Adding workspace $num to session...${NC}"
      echo "  Directory: $dir"
      echo -e "  ${YELLOW}$port_msg${NC}"

      create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "add"

      if [ -n "$TMUX" ]; then
        tmux select-window -t "$SESSION_NAME:$window_name"
      else
        tmux attach -t "$SESSION_NAME" \; select-window -t "$window_name"
      fi
    fi
  fi
}

# Create the tmux layout for a workspace
create_workspace_layout() {
  local window_name=$1
  local dir=$2
  local dev_cmd=$3
  local claude_cmd=$4
  local port_msg=$5
  local mode=$6  # "new" or "add"

  if [ "$mode" = "new" ]; then
    tmux new-session -d -s "$SESSION_NAME" -n "$window_name" -c "$dir"
  else
    tmux new-window -t "$SESSION_NAME" -n "$window_name" -c "$dir"
  fi

  # Create 3-pane layout:
  # ┌─────────┬─────────┐
  # │terminal │         │
  # ├─────────┤ main    │
  # │ server  │         │
  # └─────────┴─────────┘

  # Get pane indices (handles pane-base-index setting)
  local pane_indices=$(get_pane_indices)
  local p_terminal=$(echo "$pane_indices" | cut -d: -f1)
  local p_main=$(echo "$pane_indices" | cut -d: -f2)
  local p_server=$(echo "$pane_indices" | cut -d: -f3)

  # Create layout: start with one pane, split right for main, then split left for server
  tmux split-window -h -t "$SESSION_NAME:$window_name" -c "$dir"
  tmux select-pane -t "$SESSION_NAME:$window_name.$p_terminal"
  tmux split-window -v -t "$SESSION_NAME:$window_name" -c "$dir"

  # After splits: terminal=base, main=base+1, server=base+2
  [ -n "$dev_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" "echo '$port_msg' && $dev_cmd" C-m
  [ -n "$claude_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_main" "$claude_cmd" C-m
  tmux select-pane -t "$SESSION_NAME:$window_name.$p_main"
}

# Get command for a pane from config
get_pane_command() {
  local pane_name=$1
  local panes_count=$(yq -r '.layout.panes | length // 0' "$CONFIG_FILE" 2>/dev/null)

  for ((i=0; i<panes_count; i++)); do
    local name=$(yq -r ".layout.panes[$i].name" "$CONFIG_FILE" 2>/dev/null)
    if [ "$name" = "$pane_name" ]; then
      yq -r ".layout.panes[$i].command // \"\"" "$CONFIG_FILE" 2>/dev/null
      return
    fi
  done
  echo ""
}

# Check and setup workspace (dependencies, .env sync, shared volume)
check_and_setup_workspace() {
  local dir=$1
  local num=$2

  check_and_install_deps "$dir"

  # Setup shared volume (handles migration if needed)
  setup_shared_volume "$dir"

  echo -e "${BLUE}Syncing .env files for workspace $num...${NC}"
  sync_env_files "$dir" "$num"
}

# Check if dependencies need installing
check_and_install_deps() {
  local dir=$1
  local install_cmd=$(config_get "install_command" "")

  [ -z "$install_cmd" ] && return

  cd "$dir"

  local marker="$dir/node_modules/.crabcode-installed"
  local need_install="false"

  if [ ! -d "$dir/node_modules" ]; then
    need_install="true"
  elif [ ! -f "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/pnpm-lock.yaml" ] && [ "$dir/pnpm-lock.yaml" -nt "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/package-lock.json" ] && [ "$dir/package-lock.json" -nt "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/yarn.lock" ] && [ "$dir/yarn.lock" -nt "$marker" ]; then
    need_install="true"
  fi

  if [ "$need_install" = "true" ]; then
    echo -e "${YELLOW}Installing dependencies...${NC}"
    # Get env vars from install_env config
    local install_env=$(config_get "install_env" "")
    local run_cmd="$install_cmd"
    if [ -n "$install_env" ] && [ "$install_env" != "null" ]; then
      # Prepend env var to command so it's passed to subprocesses
      run_cmd="$install_env $install_cmd"
    fi
    if bash -c "$run_cmd"; then
      touch "$marker"
      echo -e "${GREEN}Dependencies installed${NC}"
    else
      error "Failed to install dependencies"
      return 1
    fi
  fi

  # Check submodule dependencies
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local sub_install=$(yq -r ".submodules[$i].install_command // \"\"" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue
    [ -z "$sub_install" ] || [ "$sub_install" = "null" ] && continue

    local sub_dir="$dir/$sub_path"
    if [ -d "$sub_dir" ]; then
      local sub_marker="$sub_dir/node_modules/.crabcode-installed"
      local sub_need_install="false"

      if [ ! -d "$sub_dir/node_modules" ]; then
        sub_need_install="true"
      elif [ ! -f "$sub_marker" ]; then
        sub_need_install="true"
      fi

      if [ "$sub_need_install" = "true" ]; then
        echo -e "${YELLOW}Installing $sub_path dependencies...${NC}"
        cd "$sub_dir"
        # Prepend env var to submodule install command too
        local sub_run_cmd="$sub_install"
        if [ -n "$install_env" ] && [ "$install_env" != "null" ]; then
          sub_run_cmd="$install_env $sub_install"
        fi
        if bash -c "$sub_run_cmd"; then
          # Only touch marker if node_modules exists
          [ -d "node_modules" ] && touch "$sub_marker"
          echo -e "${GREEN}$sub_path dependencies installed${NC}"
        else
          warn "Failed to install $sub_path dependencies"
        fi
        cd "$dir"
      fi
    fi
  done
}

# =============================================================================
# Cleanup / Restart / Continue
# =============================================================================

cleanup_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${YELLOW}Cleaning up workspace $num...${NC}"

  # Kill the window in the session if it exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    tmux kill-window -t "$SESSION_NAME:$window_name" 2>/dev/null || true
  fi

  # Kill any running processes for this workspace
  local kill_pattern=$(config_get "cleanup.kill_pattern" "")
  if [ -n "$kill_pattern" ]; then
    kill_pattern="${kill_pattern//\{N\}/$num}"
    kill_pattern="${kill_pattern//\{PREFIX\}/$WORKSPACE_PREFIX}"
    pkill -f "$kill_pattern" 2>/dev/null || true
  fi

  cd "$dir"

  echo "  Fetching origin..."
  git fetch origin

  echo "  Resetting to origin/main..."
  git checkout main 2>/dev/null || git checkout -b main origin/main
  git reset --hard origin/main

  echo "  Cleaning untracked files..."
  local exclude_pattern=$(config_get "cleanup.preserve_files" ".env")
  git clean -fd --exclude="$exclude_pattern"

  reset_submodules "$dir"

  # Record mood event
  mood_record_event "cleanup" "workspace $num"

  success "Workspace $num cleaned and reset to origin/main"
}

# Completely destroy a workspace (remove worktree and all files)
destroy_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"
  local branch_name=$(get_branch_name "$num")

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${RED}Destroying workspace $num...${NC}"
  echo -e "${YELLOW}This will permanently delete all files in the workspace!${NC}"
  echo ""

  # Confirm unless --force is passed
  if [ "${2:-}" != "--force" ] && [ "${2:-}" != "-f" ]; then
    echo -n "Are you sure? (y/N) "
    read -r confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo "Aborted."
      return 1
    fi
  fi

  # Kill the tmux window if it exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo "  Killing tmux window..."
    tmux kill-window -t "$SESSION_NAME:$window_name" 2>/dev/null || true
  fi

  # Kill any running processes for this workspace
  local kill_pattern=$(config_get "cleanup.kill_pattern" "")
  if [ -n "$kill_pattern" ]; then
    kill_pattern="${kill_pattern//\{N\}/$num}"
    kill_pattern="${kill_pattern//\{PREFIX\}/$WORKSPACE_PREFIX}"
    echo "  Killing processes..."
    pkill -f "$kill_pattern" 2>/dev/null || true
  fi

  # Remove the git worktree properly
  echo "  Removing git worktree..."
  cd "$MAIN_REPO"
  git worktree remove "$dir" --force 2>/dev/null || true

  # If worktree remove failed, force delete
  if [ -d "$dir" ]; then
    echo "  Force removing directory..."
    rm -rf "$dir"
  fi

  # Clean up the branch if it exists and is not checked out elsewhere
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    # Check if branch is used by another worktree
    local branch_in_use=$(git worktree list | grep "\[$branch_name\]" | wc -l | tr -d ' ')
    if [ "$branch_in_use" = "0" ]; then
      echo "  Deleting branch $branch_name..."
      git branch -D "$branch_name" 2>/dev/null || true
    fi
  fi

  # Clean up snapshots for this workspace
  if [ -d "$SNAPSHOT_DIR/ws-$num" ]; then
    echo "  Removing snapshots..."
    rm -rf "$SNAPSHOT_DIR/ws-$num"
  fi

  success "Workspace $num destroyed"
}

restart_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"
  local branch_name=$(get_branch_name "$num")

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${YELLOW}Restarting workspace $num...${NC}"

  cd "$dir"

  local current_branch=$(git branch --show-current)

  echo "  Fetching origin..."
  git fetch origin

  if [ "$current_branch" != "$branch_name" ]; then
    echo "  Switching from $current_branch to $branch_name..."
    git checkout "$branch_name" 2>/dev/null || git checkout -b "$branch_name"
  fi

  echo "  Resetting $branch_name to origin/main content..."
  git reset --hard origin/main

  echo "  Cleaning untracked files..."
  local exclude_pattern=$(config_get "cleanup.preserve_files" ".env")
  git clean -fd --exclude="$exclude_pattern"

  reset_submodules "$dir"

  # Ensure shared volume is set up (migrates existing .local if needed)
  setup_shared_volume "$dir"

  # Reinstall dependencies (lockfile may have changed after reset)
  check_and_install_deps "$dir"

  success "Git reset complete (on branch: $branch_name)"

  # Rebuild the tmux window with full layout
  if [ -n "$TMUX" ]; then
    local port_info=$(get_workspace_ports "$num" "$dir")
    local api_port=$(echo "$port_info" | cut -d: -f1)
    local app_port=$(echo "$port_info" | cut -d: -f2)
    local need_override=$(echo "$port_info" | cut -d: -f3)
    local env_api_port=$(echo "$port_info" | cut -d: -f4)

    local dev_cmd=$(get_pane_command "server")
    local claude_cmd=$(get_pane_command "main")

    if [ "$need_override" = "true" ]; then
      dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    fi

    local port_msg="Using port $env_api_port"
    [ "$need_override" = "true" ] && port_msg="Port $env_api_port in use → using $api_port"

    local current_window=$(tmux display-message -p '#{window_name}' 2>/dev/null)
    local old_window=""

    # Determine which window to replace
    if tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
      old_window="$window_name"
    elif [[ "$(pwd)" == "$dir"* ]] && [ -n "$current_window" ]; then
      old_window="$current_window"
    fi

    if [ -n "$old_window" ]; then
      echo "  Recreating workspace layout..."

      # Create new window with correct name directly
      # First, rename old window to temp so we can use the proper name
      local temp_old="_old_$$"
      tmux rename-window -t "$SESSION_NAME:$old_window" "$temp_old" 2>/dev/null || true

      # Now create new window with correct name
      create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "add"

      # Switch to new window
      tmux select-window -t "$SESSION_NAME:$window_name"

      # Kill old window (now named temp_old) via run-shell so it doesn't kill us
      tmux run-shell -t "$SESSION_NAME" "tmux kill-window -t '$SESSION_NAME:$temp_old' 2>/dev/null || true"

      # Record mood event
      mood_record_event "restart" "workspace $num"

      success "Workspace $num restarted with fresh layout!"
    else
      echo -e "${YELLOW}  No existing window found - creating new...${NC}"
      create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "add"
      tmux select-window -t "$SESSION_NAME:$window_name"
    fi
  else
    echo -e "${YELLOW}  Not in tmux session - run 'crabcode $num' to start${NC}"
  fi
}

continue_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${CYAN}Continuing workspace $num...${NC}"

  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)

  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  # Add --continue to claude command if it contains "claude"
  if [[ "$claude_cmd" == *"claude"* ]]; then
    claude_cmd="$claude_cmd --continue"
  fi

  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
  fi

  if [ -n "$TMUX" ] && tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
    echo "  Window exists, restarting with --continue..."

    # Get pane indices
    local pane_indices=$(get_pane_indices)
    local p_main=$(echo "$pane_indices" | cut -d: -f2)
    local p_server=$(echo "$pane_indices" | cut -d: -f3)

    tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" C-c
    sleep 0.3
    [ -n "$dev_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" "$dev_cmd" C-m

    tmux respawn-pane -k -t "$SESSION_NAME:$window_name.$p_main" -c "$dir"
    sleep 0.5
    [ -n "$claude_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_main" "clear && $claude_cmd" C-m

    success "Workspace $num continued with previous session"
  else
    echo "  Creating window with --continue..."
    create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "" "add"

    if [ -n "$TMUX" ]; then
      tmux select-window -t "$SESSION_NAME:$window_name"
    fi

    success "Workspace $num started with previous session"
  fi
}

# Open workspace in separate terminal
open_workspace_separate() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local session="$SESSION_NAME-$num"

  # Create if doesn't exist
  if [ ! -d "$dir" ]; then
    create_workspace "$num"
  fi

  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)
  local env_api_port=$(echo "$port_info" | cut -d: -f4)

  echo -e "${CYAN}Starting workspace $num in separate window...${NC}"

  check_and_setup_workspace "$dir" "$num"

  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    echo -e "${YELLOW}  Port $env_api_port in use, using $api_port instead${NC}"
  fi

  if tmux has-session -t "$session" 2>/dev/null; then
    if command_exists osascript; then
      osascript -e "tell application \"Terminal\" to do script \"tmux attach -t $session\""
    else
      echo "Open a new terminal and run: tmux attach -t $session"
    fi
  else
    tmux new-session -d -s "$session" -n "dev" -c "$dir"
    tmux split-window -h -t "$session" -c "$dir"
    tmux select-pane -t "$session:dev.1"
    tmux split-window -v -t "$session" -c "$dir"

    [ -n "$dev_cmd" ] && tmux send-keys -t "$session:dev.2" "$dev_cmd" C-m
    [ -n "$claude_cmd" ] && tmux send-keys -t "$session:dev.3" "$claude_cmd" C-m
    tmux select-pane -t "$session:dev.3"

    if command_exists osascript; then
      osascript -e "tell application \"Terminal\" to do script \"tmux attach -t $session\""
    else
      echo "Open a new terminal and run: tmux attach -t $session"
    fi
  fi
}

# Detect workspace number from current directory only (not tmux)
detect_workspace_from_dir() {
  local cwd=$(pwd)
  if [[ "$cwd" =~ $WORKSPACE_PREFIX-([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
    return
  fi
  echo ""
}

# Detect workspace number from current directory or tmux window
detect_workspace() {
  # First try: current directory
  local cwd=$(pwd)
  if [[ "$cwd" =~ $WORKSPACE_PREFIX-([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
    return
  fi

  # Second try: tmux window name (ws1, ws2, etc.)
  if [ -n "$TMUX" ]; then
    local window_name=$(tmux display-message -p '#{window_name}' 2>/dev/null)
    if [[ "$window_name" =~ ^ws([0-9]+)$ ]]; then
      echo "${BASH_REMATCH[1]}"
      return
    fi
  fi

  echo ""
}

# Find the next available workspace number
find_next_workspace() {
  local num=1
  while true; do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
    if [ ! -d "$dir" ]; then
      echo "$num"
      return
    fi
    num=$((num + 1))
    # Safety limit
    if [ $num -gt 100 ]; then
      echo ""
      return
    fi
  done
}

# Create a new workspace with the next available number
create_new_workspace() {
  local next_num=$(find_next_workspace)

  if [ -z "$next_num" ]; then
    error "Could not find an available workspace number"
    exit 1
  fi

  echo -e "${CYAN}Creating new workspace $next_num...${NC}"
  open_workspace "$next_num"
}

# =============================================================================
# WIP Management
# =============================================================================

get_wip_dir() {
  local num=$1
  echo "$WIP_BASE/$WORKSPACE_PREFIX-$num"
}

wip_save() {
  local num=$1
  local do_restart=$2
  local custom_name="${3:-}"
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local wip_dir=$(get_wip_dir "$num")
  local timestamp=$(date +%Y%m%d-%H%M%S)
  local branch_name=$(get_branch_name "$num")

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist"
    return 1
  fi

  echo -e "${CYAN}Saving WIP state for workspace $num...${NC}"

  cd "$dir"
  local diff=$(git diff HEAD 2>/dev/null || echo "")
  local staged=$(git diff --cached HEAD 2>/dev/null || echo "")
  local status=$(git status --porcelain 2>/dev/null || echo "")
  local branch=$(git branch --show-current 2>/dev/null || echo "unknown")

  # Get untracked files
  local untracked_files=$(git ls-files --others --exclude-standard 2>/dev/null || echo "")

  git fetch origin main --quiet 2>/dev/null || true
  local commits_ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo "0")
  local commit_log=""
  if [ "$commits_ahead" -gt 0 ] 2>/dev/null; then
    commit_log=$(git log --oneline origin/main..HEAD 2>/dev/null || echo "")
  fi

  # Collect submodule changes
  local submodule_diffs=""
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local sub_diff=$(git diff HEAD 2>/dev/null || echo "")
      local sub_staged=$(git diff --cached HEAD 2>/dev/null || echo "")
      [ -n "$sub_diff" ] && submodule_diffs="$submodule_diffs$sub_diff"
      [ -n "$sub_staged" ] && submodule_diffs="$submodule_diffs$sub_staged"
      cd "$dir"
    fi
  done

  # Check if there's anything to save
  local has_changes="false"
  if [ -n "$diff" ] || [ -n "$staged" ] || [ -n "$status" ] || [ -n "$submodule_diffs" ] || [ -n "$untracked_files" ]; then
    has_changes="true"
  elif [ "$commits_ahead" -gt 0 ] 2>/dev/null; then
    has_changes="true"
  elif [ "$branch" != "$branch_name" ] && [ "$branch" != "main" ]; then
    has_changes="true"
  fi

  if [ "$has_changes" = "false" ]; then
    echo -e "${YELLOW}No changes to save.${NC}"
    return 0
  fi

  local slug=""
  local summary=""

  # Use custom name if provided
  if [ -n "$custom_name" ]; then
    slug=$(echo "$custom_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g')
    summary="$custom_name"
  else
    # Try to generate AI summary if claude is available
    slug="wip-$(date +%H%M)"
    summary="Work in progress"
    if command_exists claude; then
      local all_diffs="$diff$staged$submodule_diffs"
      local summary_json=$(generate_wip_summary "$all_diffs")
      local parsed_slug=$(echo "$summary_json" | sed -n 's/.*"slug"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
      local parsed_summary=$(echo "$summary_json" | sed -n 's/.*"summary"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
      [ -n "$parsed_slug" ] && slug="$parsed_slug"
      [ -n "$parsed_summary" ] && summary="$parsed_summary"
    fi
  fi

  local wip_path="$wip_dir/$timestamp-$slug"
  mkdir -p "$wip_path"

  local saved_count=0

  # Save patches
  if [ -n "$diff" ]; then
    echo "$diff" > "$wip_path/main-unstaged.patch"
    ((saved_count++))
  fi
  if [ -n "$staged" ]; then
    echo "$staged" > "$wip_path/main-staged.patch"
    ((saved_count++))
  fi
  [ -n "$status" ] && echo "$status" > "$wip_path/main-status.txt"
  [ -n "$commit_log" ] && echo "$commit_log" > "$wip_path/main-commits.txt"

  # Save untracked files (copy actual content)
  if [ -n "$untracked_files" ]; then
    local untracked_dir="$wip_path/untracked"
    mkdir -p "$untracked_dir"
    echo "$untracked_files" | while read -r file; do
      [ -z "$file" ] && continue
      local file_dir=$(dirname "$file")
      mkdir -p "$untracked_dir/$file_dir"
      cp "$dir/$file" "$untracked_dir/$file" 2>/dev/null && ((saved_count++))
    done
    echo "$untracked_files" > "$wip_path/untracked-files.txt"
  fi

  # Save submodule patches
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local sub_diff=$(git diff HEAD 2>/dev/null || echo "")
      local sub_staged=$(git diff --cached HEAD 2>/dev/null || echo "")
      local sub_status=$(git status --porcelain 2>/dev/null || echo "")
      local safe_name=$(echo "$sub_path" | tr '/' '-')
      [ -n "$sub_diff" ] && echo "$sub_diff" > "$wip_path/${safe_name}-unstaged.patch"
      [ -n "$sub_staged" ] && echo "$sub_staged" > "$wip_path/${safe_name}-staged.patch"
      [ -n "$sub_status" ] && echo "$sub_status" > "$wip_path/${safe_name}-status.txt"
      cd "$dir"
    fi
  done

  cat > "$wip_path/metadata.json" << EOF
{
  "timestamp": "$timestamp",
  "slug": "$slug",
  "summary": "$summary",
  "workspace": $num,
  "branch": "$branch",
  "commits_ahead": $commits_ahead,
  "created_at": "$(date -Iseconds)"
}
EOF

  # Record mood event
  mood_record_event "wip_save" "$slug"

  success "WIP saved: $slug"
  echo -e "   ${GRAY}$summary${NC}"

  if [ "$do_restart" = "true" ]; then
    echo ""
    restart_workspace "$num"
  fi
}

generate_wip_summary() {
  local diff_content="$1"
  local max_lines=100
  local truncated_diff=$(echo "$diff_content" | head -n $max_lines)

  if command_exists claude; then
    local prompt="Based on this git diff, provide a JSON response with exactly this format (no markdown, just raw JSON):
{\"slug\": \"short-kebab-case-name-max-30-chars\", \"summary\": \"One sentence describing the changes\"}

Git diff:
$truncated_diff"

    local result=$(echo "$prompt" | timeout 30 claude --print 2>/dev/null || echo "")

    if [ -n "$result" ]; then
      local json=$(echo "$result" | grep -o '{[^}]*}' | head -1)
      if [ -n "$json" ]; then
        echo "$json"
        return
      fi
    fi
  fi

  echo "{\"slug\": \"wip-$(date +%H%M)\", \"summary\": \"Work in progress\"}"
}

wip_list() {
  local num=$1
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    echo -e "${YELLOW}No WIP states saved for workspace $num${NC}"
    return 0
  fi

  local wips=($(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r))

  if [ ${#wips[@]} -eq 0 ]; then
    echo -e "${YELLOW}No WIP states saved for workspace $num${NC}"
    return 0
  fi

  echo -e "${CYAN}WIP States for Workspace $num${NC}"
  echo ""

  local i=1
  for wip in "${wips[@]}"; do
    local name=$(basename "$wip")
    local metadata="$wip/metadata.json"

    if [ -f "$metadata" ]; then
      local summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      local created=$(grep -o '"created_at"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"created_at"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')

      # Handle both new format (branch) and old format (cloud_branch)
      local branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      if [ -z "$branch" ]; then
        branch=$(grep -o '"cloud_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"cloud_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      fi

      # Format date nicely
      local display_date=$(echo "$created" | cut -d'T' -f1)
      local display_time=$(echo "$created" | cut -d'T' -f2 | cut -d'+' -f1 | cut -d'-' -f1 | cut -c1-5)

      echo -e "  ${GREEN}[$i]${NC} $name"
      echo -e "      ${BLUE}$summary${NC}"
      echo -e "      Branch: $branch | Created: $display_date $display_time"
      echo ""
    else
      echo -e "  ${GREEN}[$i]${NC} $name (no metadata)"
      echo ""
    fi

    ((i++))
  done
}

# List all WIPs globally across all workspaces
wip_list_global() {
  if [ ! -d "$WIP_BASE" ]; then
    echo -e "${YELLOW}No WIP states saved${NC}"
    echo "  Save your work with: crab wip save"
    return 0
  fi

  # Collect all WIPs with their metadata
  local all_wips=()
  local wip_data=()

  # Scan all workspace WIP directories
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        # Get timestamp for sorting
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    echo -e "${YELLOW}No WIP states saved${NC}"
    echo "  Save your work with: crab wip save"
    return 0
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  echo -e "${CYAN}${BOLD}All WIP States${NC}"
  echo ""

  local i=1
  for entry in "${sorted_wips[@]}"; do
    local ws_name=$(echo "$entry" | cut -d'|' -f2)
    local wip_path=$(echo "$entry" | cut -d'|' -f3)
    local wip_name=$(basename "$wip_path")
    local metadata="$wip_path/metadata.json"

    # Extract workspace number from ws_name (e.g., cloud-workspace-1 -> 1)
    local ws_num=$(echo "$ws_name" | grep -o '[0-9]*$')

    # Count patch files
    local file_count=$(ls -1 "$wip_path"/*.patch 2>/dev/null | wc -l | tr -d ' ')
    [ -z "$file_count" ] && file_count=0

    if [ -f "$metadata" ]; then
      local summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      local created=$(grep -o '"created_at"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"created_at"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')

      # Handle both new format (branch) and old format (cloud_branch)
      local branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      if [ -z "$branch" ]; then
        branch=$(grep -o '"cloud_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"cloud_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      fi

      # Handle both new format (commits_ahead) and old format (cloud_commits_ahead)
      local commits_ahead=$(grep -o '"commits_ahead"[[:space:]]*:[[:space:]]*[0-9]*' "$metadata" | sed 's/"commits_ahead"[[:space:]]*:[[:space:]]*//')
      if [ -z "$commits_ahead" ]; then
        commits_ahead=$(grep -o '"cloud_commits_ahead"[[:space:]]*:[[:space:]]*[0-9]*' "$metadata" | sed 's/"cloud_commits_ahead"[[:space:]]*:[[:space:]]*//')
      fi

      # Format the date nicely
      local display_date=$(echo "$created" | cut -d'T' -f1)
      local display_time=$(echo "$created" | cut -d'T' -f2 | cut -d'+' -f1 | cut -d'-' -f1 | cut -c1-5)

      echo -e "  ${GREEN}[$i]${NC} ${BOLD}$wip_name${NC}"
      echo -e "      ${BLUE}$summary${NC}"
      echo -e "      ${GRAY}Workspace: ${NC}$ws_num  ${GRAY}Branch: ${NC}$branch  ${GRAY}Files: ${NC}$file_count patches"
      if [ -n "$commits_ahead" ] && [ "$commits_ahead" != "0" ]; then
        echo -e "      ${GRAY}Commits ahead: ${NC}$commits_ahead  ${GRAY}Created: ${NC}$display_date $display_time"
      else
        echo -e "      ${GRAY}Created: ${NC}$display_date $display_time"
      fi
      echo ""
    else
      echo -e "  ${GREEN}[$i]${NC} ${BOLD}$wip_name${NC} ${GRAY}(no metadata)${NC}"
      echo -e "      ${GRAY}Workspace: ${NC}$ws_num  ${GRAY}Files: ${NC}$file_count patches"
      echo ""
    fi

    ((i++))
  done

  echo -e "${GRAY}Restore with: crab wip restore <number> [--to <workspace>]${NC}"
}

# Interactive restore from global WIP list
wip_restore_global() {
  local target_ws="${1:-}"
  local open_after="${2:-true}"

  if [ ! -d "$WIP_BASE" ]; then
    error "No WIP states found"
    return 1
  fi

  # Collect all WIPs
  local all_wips=()
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    error "No WIP states found"
    return 1
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  echo -e "${CYAN}Select WIP to restore:${NC}"
  echo ""

  local i=1
  for entry in "${sorted_wips[@]}"; do
    local ws_name=$(echo "$entry" | cut -d'|' -f2)
    local wip_path=$(echo "$entry" | cut -d'|' -f3)
    local wip_name=$(basename "$wip_path")
    local metadata="$wip_path/metadata.json"
    local ws_num=$(echo "$ws_name" | grep -o '[0-9]*$')
    local summary=""

    if [ -f "$metadata" ]; then
      summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    echo -e "  ${GREEN}[$i]${NC} $wip_name ${GRAY}(ws $ws_num)${NC}"
    [ -n "$summary" ] && echo -e "      ${BLUE}$summary${NC}"
    ((i++))
  done

  echo ""
  echo -e "  ${YELLOW}[0]${NC} Cancel"
  echo ""

  read -p "Select WIP [1-${#sorted_wips[@]}]: " selection

  if [ "$selection" = "0" ] || [ -z "$selection" ]; then
    echo "Cancelled."
    return 0
  fi

  if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#sorted_wips[@]} ]; then
    error "Invalid selection"
    return 1
  fi

  local selected_entry="${sorted_wips[$((selection-1))]}"
  local selected_ws=$(echo "$selected_entry" | cut -d'|' -f2)
  local selected_wip=$(echo "$selected_entry" | cut -d'|' -f3)
  local original_ws_num=$(echo "$selected_ws" | grep -o '[0-9]*$')

  # Determine target workspace
  local restore_to_ws="$original_ws_num"
  if [ -n "$target_ws" ]; then
    restore_to_ws="$target_ws"
  fi

  # Check if target workspace exists
  local target_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$restore_to_ws"
  if [ ! -d "$target_dir" ]; then
    echo -e "${YELLOW}Workspace $restore_to_ws does not exist.${NC}"
    read -p "Create it? [y/N]: " create_ws
    if [ "$create_ws" = "y" ] || [ "$create_ws" = "Y" ]; then
      create_workspace "$restore_to_ws"
    else
      echo "Cancelled."
      return 0
    fi
  else
    # Check if target workspace has uncommitted changes
    if _workspace_has_changes "$target_dir"; then
      echo -e "${YELLOW}Workspace $restore_to_ws has uncommitted changes.${NC}"
      echo ""
      echo "  [1] Restore anyway (may conflict)"
      echo "  [2] Create a new workspace"
      echo "  [0] Cancel"
      echo ""
      read -p "Choice [0-2]: " conflict_choice
      case "$conflict_choice" in
        1) ;; # Continue with restore
        2)
          # Find next available workspace
          local next_ws=$(find_next_workspace)
          echo -e "${CYAN}Creating workspace $next_ws...${NC}"
          create_workspace "$next_ws"
          restore_to_ws="$next_ws"
          ;;
        *)
          echo "Cancelled."
          return 0
          ;;
      esac
    fi
  fi

  local wip_name=$(basename "$selected_wip")
  echo ""
  echo -e "${CYAN}Restoring WIP: $wip_name -> workspace $restore_to_ws${NC}"

  _restore_wip "$restore_to_ws" "$selected_wip" "true"
}

# Check if workspace directory has uncommitted changes
_workspace_has_changes() {
  local dir="$1"
  [ ! -d "$dir" ] && return 1
  cd "$dir"
  # Check for any changes (staged, unstaged, or untracked)
  if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
    return 0
  fi
  # Check for untracked files
  if [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
    return 0
  fi
  return 1
}

# Restore by index from global list
wip_restore_by_index() {
  local index="$1"
  local target_ws="$2"
  local open_after="${3:-true}"

  if [ ! -d "$WIP_BASE" ]; then
    error "No WIP states found"
    return 1
  fi

  # Collect all WIPs
  local all_wips=()
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    error "No WIP states found"
    return 1
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 1 ] || [ "$index" -gt ${#sorted_wips[@]} ]; then
    error "Invalid WIP index: $index (valid range: 1-${#sorted_wips[@]})"
    return 1
  fi

  local selected_entry="${sorted_wips[$((index-1))]}"
  local selected_ws=$(echo "$selected_entry" | cut -d'|' -f2)
  local selected_wip=$(echo "$selected_entry" | cut -d'|' -f3)
  local original_ws_num=$(echo "$selected_ws" | grep -o '[0-9]*$')

  # Determine target workspace
  local restore_to_ws="$original_ws_num"
  if [ -n "$target_ws" ]; then
    restore_to_ws="$target_ws"
  fi

  # Check if target workspace exists
  local target_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$restore_to_ws"
  if [ ! -d "$target_dir" ]; then
    echo -e "${YELLOW}Workspace $restore_to_ws does not exist.${NC}"
    read -p "Create it? [y/N]: " create_ws
    if [ "$create_ws" = "y" ] || [ "$create_ws" = "Y" ]; then
      create_workspace "$restore_to_ws"
    else
      echo "Cancelled."
      return 0
    fi
  else
    # Check if target workspace has uncommitted changes
    if _workspace_has_changes "$target_dir"; then
      echo -e "${YELLOW}Workspace $restore_to_ws has uncommitted changes.${NC}"
      echo ""
      echo "  [1] Restore anyway (may conflict)"
      echo "  [2] Create a new workspace"
      echo "  [0] Cancel"
      echo ""
      read -p "Choice [0-2]: " conflict_choice
      case "$conflict_choice" in
        1) ;; # Continue with restore
        2)
          # Find next available workspace
          local next_ws=$(find_next_workspace)
          echo -e "${CYAN}Creating workspace $next_ws...${NC}"
          create_workspace "$next_ws"
          restore_to_ws="$next_ws"
          ;;
        *)
          echo "Cancelled."
          return 0
          ;;
      esac
    fi
  fi

  local wip_name=$(basename "$selected_wip")
  echo -e "${CYAN}Restoring WIP: $wip_name -> workspace $restore_to_ws${NC}"

  _restore_wip "$restore_to_ws" "$selected_wip" "true"
}

wip_continue() {
  local num=$1
  local open_after="${2:-true}"
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local latest_wip=$(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r | head -1)

  if [ -z "$latest_wip" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local wip_name=$(basename "$latest_wip")
  echo -e "${CYAN}Restoring WIP: $wip_name${NC}"

  _restore_wip "$num" "$latest_wip" "$open_after"
}

wip_resume() {
  local num=$1
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local wips=($(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r))

  if [ ${#wips[@]} -eq 0 ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  echo -e "${CYAN}Select WIP to restore:${NC}"
  echo ""

  local i=1
  for wip in "${wips[@]}"; do
    local name=$(basename "$wip")
    local metadata="$wip/metadata.json"
    local summary=""

    if [ -f "$metadata" ]; then
      summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    echo -e "  ${GREEN}[$i]${NC} $name"
    [ -n "$summary" ] && echo -e "      ${BLUE}$summary${NC}"
    ((i++))
  done

  echo ""
  echo -e "  ${YELLOW}[0]${NC} Cancel"
  echo ""

  read -p "Select WIP [1-${#wips[@]}]: " selection

  if [ "$selection" = "0" ] || [ -z "$selection" ]; then
    echo "Cancelled."
    return 0
  fi

  if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#wips[@]} ]; then
    error "Invalid selection"
    return 1
  fi

  local selected_wip="${wips[$((selection-1))]}"
  local wip_name=$(basename "$selected_wip")

  echo ""
  echo -e "${CYAN}Restoring WIP: $wip_name${NC}"

  _restore_wip "$num" "$selected_wip"
}

_restore_wip() {
  local num=$1
  local wip_path=$2
  local open_after="${3:-true}"
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local wip_name=$(basename "$wip_path")
  local branch_name=$(get_branch_name "$num")
  local original_dir=$(pwd)  # Save original directory before cd'ing

  local metadata="$wip_path/metadata.json"
  local saved_branch="$branch_name"
  if [ -f "$metadata" ]; then
    # Handle both new format (branch) and old format (cloud_branch)
    saved_branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    if [ -z "$saved_branch" ]; then
      saved_branch=$(grep -o '"cloud_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"cloud_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi
    # If still empty, use default branch name
    if [ -z "$saved_branch" ]; then
      saved_branch="$branch_name"
    fi
  fi

  cd "$dir"

  # Switch to saved branch
  local current_branch=$(git branch --show-current)
  if [ "$current_branch" != "$saved_branch" ] && [ -n "$saved_branch" ]; then
    echo "  Switching to branch $saved_branch..."
    git checkout "$saved_branch" 2>/dev/null || git checkout -b "$saved_branch"
  fi

  # Cherry-pick saved commits (handle both main-commits.txt and cloud-commits.txt)
  local commits_file=""
  if [ -f "$wip_path/main-commits.txt" ] && [ -s "$wip_path/main-commits.txt" ]; then
    commits_file="$wip_path/main-commits.txt"
  elif [ -f "$wip_path/cloud-commits.txt" ] && [ -s "$wip_path/cloud-commits.txt" ]; then
    commits_file="$wip_path/cloud-commits.txt"
  fi

  if [ -n "$commits_file" ]; then
    echo "  Restoring commits..."
    # Read commit hashes in reverse order (oldest first) and cherry-pick
    local commit_hashes=$(awk '{print $1}' "$commits_file" | tac)
    local cherry_pick_failed=false
    for hash in $commit_hashes; do
      if git cat-file -e "$hash" 2>/dev/null; then
        if ! git cherry-pick "$hash" --no-commit 2>/dev/null; then
          echo "    (commit $hash may need manual resolution)"
          cherry_pick_failed=true
        fi
      else
        echo "    (commit $hash not found in repo - may need to fetch)"
      fi
    done
    if [ "$cherry_pick_failed" = "false" ] && [ -n "$commit_hashes" ]; then
      # Commit the cherry-picked changes
      git commit --no-edit 2>/dev/null || true
    fi
  fi

  # Apply main patches
  if [ -f "$wip_path/main-staged.patch" ] && [ -s "$wip_path/main-staged.patch" ]; then
    echo "  Applying staged changes..."
    git apply "$wip_path/main-staged.patch" 2>/dev/null && git add -A || echo "    (some hunks may have failed)"
  fi

  if [ -f "$wip_path/main-unstaged.patch" ] && [ -s "$wip_path/main-unstaged.patch" ]; then
    echo "  Applying unstaged changes..."
    git apply "$wip_path/main-unstaged.patch" 2>/dev/null || echo "    (some hunks may have failed)"
  fi

  # Apply submodule patches
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local safe_name=$(echo "$sub_path" | tr '/' '-')

      # Check for saved submodule branch in metadata
      local sub_branch=""
      if [ -f "$metadata" ]; then
        sub_branch=$(grep -o "\"${safe_name}_branch\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" "$metadata" | sed "s/\"${safe_name}_branch\"[[:space:]]*:[[:space:]]*\"//" | sed 's/"$//')
        # Also try promptfoo_branch for backwards compatibility
        if [ -z "$sub_branch" ] && [ "$sub_path" = "promptfoo" ]; then
          sub_branch=$(grep -o '"promptfoo_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"promptfoo_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        fi
      fi

      # Switch submodule to saved branch if specified
      if [ -n "$sub_branch" ] && [ "$sub_branch" != "null" ]; then
        local current_sub_branch=$(git branch --show-current 2>/dev/null)
        if [ "$current_sub_branch" != "$sub_branch" ]; then
          echo "  Switching $sub_path to branch $sub_branch..."
          git checkout "$sub_branch" 2>/dev/null || git checkout -b "$sub_branch" 2>/dev/null || true
        fi
      fi

      # Cherry-pick submodule commits
      local sub_commits_file=""
      if [ -f "$wip_path/${safe_name}-commits.txt" ] && [ -s "$wip_path/${safe_name}-commits.txt" ]; then
        sub_commits_file="$wip_path/${safe_name}-commits.txt"
      fi

      if [ -n "$sub_commits_file" ]; then
        echo "  Restoring $sub_path commits..."
        local sub_hashes=$(awk '{print $1}' "$sub_commits_file" | tac)
        for hash in $sub_hashes; do
          if git cat-file -e "$hash" 2>/dev/null; then
            git cherry-pick "$hash" --no-commit 2>/dev/null || echo "    (commit $hash may need manual resolution)"
          fi
        done
        git commit --no-edit 2>/dev/null || true
      fi

      if [ -f "$wip_path/${safe_name}-staged.patch" ] && [ -s "$wip_path/${safe_name}-staged.patch" ]; then
        echo "  Applying $sub_path staged changes..."
        git apply "$wip_path/${safe_name}-staged.patch" 2>/dev/null && git add -A || echo "    (some hunks may have failed)"
      fi

      if [ -f "$wip_path/${safe_name}-unstaged.patch" ] && [ -s "$wip_path/${safe_name}-unstaged.patch" ]; then
        echo "  Applying $sub_path unstaged changes..."
        git apply "$wip_path/${safe_name}-unstaged.patch" 2>/dev/null || echo "    (some hunks may have failed)"
      fi

      cd "$dir"
    fi
  done

  # Restore untracked files
  if [ -d "$wip_path/untracked" ]; then
    echo "  Restoring untracked files..."
    cp -r "$wip_path/untracked/." "$dir/" 2>/dev/null || true
  fi

  success "WIP restored: $wip_name"

  # Check if user was already in the workspace when they started
  if [[ "$original_dir" == "$dir"* ]]; then
    # Already in workspace, no need to open it
    :
  elif [ "$open_after" = "true" ]; then
    echo ""
    echo "  Opening workspace $num..."
    open_workspace "$num"
  else
    echo ""
    echo "  Run 'crab $num' to open the workspace"
  fi
}

wip_delete() {
  local num=$1
  local wip_name=$2
  local wip_dir=$(get_wip_dir "$num")

  if [ -z "$wip_name" ]; then
    error "Usage: crabcode wip delete <wip-name>"
    return 1
  fi

  local wip_path="$wip_dir/$wip_name"

  if [ ! -d "$wip_path" ]; then
    wip_path=$(ls -1d "$wip_dir"/*"$wip_name"*/ 2>/dev/null | head -1)
  fi

  if [ ! -d "$wip_path" ]; then
    error "WIP not found: $wip_name"
    return 1
  fi

  local actual_name=$(basename "$wip_path")
  read -p "Delete WIP '$actual_name'? [y/N]: " confirm

  if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
    rm -rf "$wip_path"
    success "Deleted: $actual_name"
  else
    echo "Cancelled."
  fi
}

# =============================================================================
# Toolkit - Share
# =============================================================================

# Default exclude patterns for sharing (dependencies, build artifacts)
SHARE_EXCLUDE_PATTERNS=(
  "node_modules"
  ".git"
  "vendor"
  "venv"
  ".venv"
  "__pycache__"
  ".pytest_cache"
  "dist"
  "build"
  ".next"
  ".nuxt"
  "target"
  ".cache"
  "*.pyc"
  "*.pyo"
  ".DS_Store"
  "Thumbs.db"
)

# Create a clean archive of a path, excluding dependencies
# Returns the path to the created archive
tk_create_archive() {
  local source_path="$1"
  local include_git="${2:-false}"
  local include_deps="${3:-false}"

  local abs_path=$(cd "$source_path" 2>/dev/null && pwd || echo "$source_path")
  local base_name=$(basename "$abs_path")
  local timestamp=$(date +%Y%m%d-%H%M%S)
  local archive_name="${base_name}-${timestamp}.zip"
  local archive_path="/tmp/$archive_name"

  echo -e "${CYAN}Creating archive...${NC}"

  # Build exclude arguments for zip
  local exclude_args=""

  if [ "$include_deps" != "true" ]; then
    for pattern in "${SHARE_EXCLUDE_PATTERNS[@]}"; do
      # Skip .git if include_git is true
      if [ "$pattern" = ".git" ] && [ "$include_git" = "true" ]; then
        continue
      fi
      exclude_args="$exclude_args -x '$base_name/$pattern/*' -x '$base_name/$pattern'"
    done
    echo "  Excluding: dependencies and build artifacts"
  fi

  if [ "$include_git" != "true" ]; then
    echo "  Excluding: .git/"
  fi

  # Check if it's a git repo and respect .gitignore
  if [ -d "$abs_path/.git" ] || [ -f "$abs_path/.git" ]; then
    # Get list of gitignored files and add to excludes
    local gitignored=$(cd "$abs_path" && git ls-files --others --ignored --exclude-standard 2>/dev/null | head -100)
    if [ -n "$gitignored" ]; then
      echo "  Respecting: .gitignore patterns"
    fi
  fi

  # Create the archive
  cd "$(dirname "$abs_path")"

  # Use eval to properly handle the exclude args
  if eval "zip -rq '$archive_path' '$base_name' $exclude_args" 2>/dev/null; then
    local size=$(du -h "$archive_path" | cut -f1)
    echo -e "  ${GREEN}Created: $archive_name ($size)${NC}"
    echo "$archive_path"
  else
    error "Failed to create archive"
    return 1
  fi
}

# Upload to transfer.sh
tk_upload_transfersh() {
  local file_path="$1"
  local filename=$(basename "$file_path")
  local filesize=$(du -h "$file_path" | cut -f1)

  echo -e "${CYAN}Uploading to transfer.sh ($filesize)...${NC}"

  # Create temp file for error output
  local error_file=$(mktemp)

  # Use -f to fail silently on HTTP errors, capture response
  local response
  response=$(curl -f --progress-bar --upload-file "$file_path" "https://transfer.sh/$filename" 2>"$error_file")
  local curl_exit=$?

  # Read any error output
  local error_output=$(cat "$error_file" 2>/dev/null)
  rm -f "$error_file"

  if [ $curl_exit -eq 0 ] && [ -n "$response" ] && [[ "$response" == http* ]]; then
    echo ""
    echo -e "${GREEN}Upload complete!${NC}"
    echo ""
    echo -e "  URL: ${BOLD}$response${NC}"
    echo "  Expires: 14 days"
    echo ""

    # Copy to clipboard if possible
    if command_exists pbcopy; then
      echo -n "$response" | pbcopy
      echo "  (Copied to clipboard)"
    elif command_exists xclip; then
      echo -n "$response" | xclip -selection clipboard
      echo "  (Copied to clipboard)"
    fi

    return 0
  else
    # Show error details for debugging
    if [ -n "$error_output" ]; then
      echo -e "${YELLOW}transfer.sh error: $error_output${NC}" >&2
    fi
    if [ -n "$response" ] && [[ "$response" != http* ]]; then
      echo -e "${YELLOW}Unexpected response: $response${NC}" >&2
    fi
    return 1
  fi
}

# Upload to 0x0.st (alternative service)
tk_upload_0x0() {
  local file_path="$1"
  local filesize=$(du -h "$file_path" | cut -f1)

  echo -e "${CYAN}Uploading to 0x0.st ($filesize)...${NC}"

  # Create temp file for error output
  local error_file=$(mktemp)

  local response
  response=$(curl -f -F "file=@$file_path" https://0x0.st 2>"$error_file")
  local curl_exit=$?

  local error_output=$(cat "$error_file" 2>/dev/null)
  rm -f "$error_file"

  if [ $curl_exit -eq 0 ] && [ -n "$response" ] && [[ "$response" == http* ]]; then
    echo ""
    echo -e "${GREEN}Upload complete!${NC}"
    echo ""
    echo -e "  URL: ${BOLD}$response${NC}"
    echo ""

    # Copy to clipboard
    if command_exists pbcopy; then
      echo -n "$response" | pbcopy
      echo "  (Copied to clipboard)"
    elif command_exists xclip; then
      echo -n "$response" | xclip -selection clipboard
      echo "  (Copied to clipboard)"
    fi

    return 0
  else
    if [ -n "$error_output" ]; then
      echo -e "${YELLOW}0x0.st error: $error_output${NC}" >&2
    fi
    return 1
  fi
}

# Upload with automatic fallback between services
tk_upload_with_fallback() {
  local file_path="$1"

  # Try transfer.sh first
  if tk_upload_transfersh "$file_path"; then
    return 0
  fi

  echo ""
  echo -e "${YELLOW}transfer.sh failed, trying 0x0.st...${NC}"
  echo ""

  # Fallback to 0x0.st
  if tk_upload_0x0 "$file_path"; then
    return 0
  fi

  echo ""
  error "All upload services failed"
  echo "Try using SSH transfer instead: crab tk share <path> --to ssh:user@host"
  return 1
}

# Transfer via SSH/rsync
tk_transfer_ssh() {
  local file_path="$1"
  local destination="$2"

  # Parse destination: user@host:/path or just host
  local user_host="${destination%%:*}"
  local remote_path="${destination#*:}"

  # Default to ~/Downloads if no path specified
  if [ "$remote_path" = "$destination" ]; then
    remote_path="~/Downloads/"
  fi

  echo -e "${CYAN}Transferring via SSH...${NC}"
  echo "  Destination: $user_host:$remote_path"

  if command_exists rsync; then
    rsync -avz --progress "$file_path" "$user_host:$remote_path"
  else
    scp "$file_path" "$user_host:$remote_path"
  fi

  if [ $? -eq 0 ]; then
    echo ""
    success "Transfer complete!"
  else
    error "Transfer failed"
    return 1
  fi
}

# Upload to Slack
tk_upload_slack() {
  local file_path="$1"
  local target="${2:-}"

  # Use same token as crab slack commands
  local slack_token=$(config_get "slack.bot_token" "")

  # Check for slackcat first (easier)
  if command_exists slackcat && [ -n "$target" ]; then
    echo -e "${CYAN}Uploading to Slack via slackcat...${NC}"
    slackcat --channel "$target" "$file_path"
    return $?
  fi

  # Otherwise use curl with Slack API
  if [ -z "$slack_token" ]; then
    error "Slack not configured. Set CRAB_SLACK_BOT_TOKEN env var:"
    echo ""
    echo "  export CRAB_SLACK_BOT_TOKEN=xoxb-your-bot-token"
    return 1
  fi

  if [ -z "$target" ]; then
    error "No target specified. Use --to slack:@user or --to slack:#channel"
    return 1
  fi

  # Resolve target to channel ID (supports @user and #channel)
  local channel_id
  if [[ "$target" == "@"* ]]; then
    local username="${target#@}"
    echo -e "${CYAN}Looking up user: $username...${NC}"
    local user_id=$(slack_get_user_id "$username")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
    echo -e "${CYAN}Uploading file to @$username...${NC}"
  else
    # Remove # prefix if present
    local channel_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$channel_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
    echo -e "${CYAN}Uploading file to #$channel_name...${NC}"
  fi

  # Step 1: Get upload URL (new Slack API)
  local filename=$(basename "$file_path")
  local filesize=$(stat -f%z "$file_path" 2>/dev/null || stat -c%s "$file_path" 2>/dev/null)

  local upload_response=$(curl -s -X POST "https://slack.com/api/files.getUploadURLExternal" \
    -H "Authorization: Bearer $slack_token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "filename=$filename&length=$filesize")

  local upload_url=$(echo "$upload_response" | jq -r '.upload_url // empty')
  local file_id=$(echo "$upload_response" | jq -r '.file_id // empty')

  if [ -z "$upload_url" ] || [ -z "$file_id" ]; then
    error "Failed to get upload URL from Slack"
    echo "$upload_response" | jq -r '.error // .'
    return 1
  fi

  # Step 2: Upload file to the URL
  curl -s -X POST "$upload_url" \
    -F "file=@$file_path" > /dev/null

  # Step 3: Complete upload and share to channel/DM
  local complete_response=$(curl -s -X POST "https://slack.com/api/files.completeUploadExternal" \
    -H "Authorization: Bearer $slack_token" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg file_id "$file_id" --arg channel_id "$channel_id" \
      '{files: [{id: $file_id}], channel_id: $channel_id}')")

  local ok=$(echo "$complete_response" | jq -r '.ok')
  if [ "$ok" = "true" ]; then
    echo ""
    success "File uploaded to $target!"
  else
    error "Failed to complete Slack upload"
    echo "$complete_response" | jq -r '.error // .'
    return 1
  fi
}

# Send via email
tk_send_email() {
  local file_path="$1"
  local recipient="$2"
  local filename=$(basename "$file_path")

  echo -e "${CYAN}Sending via email...${NC}"

  # Check for mutt (preferred for attachments)
  if command_exists mutt; then
    local subject="Shared file: $filename"
    local body="Shared via crabcode toolkit.\n\nFile: $filename"

    echo -e "$body" | mutt -s "$subject" -a "$file_path" -- "$recipient"

    if [ $? -eq 0 ]; then
      success "Email sent to $recipient"
      return 0
    else
      error "Failed to send email"
      return 1
    fi
  fi

  # macOS: Open in Mail.app
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "Opening Mail.app..."
    open -a Mail "$file_path"
    echo -e "${YELLOW}Please compose and send the email manually${NC}"
    return 0
  fi

  # Fallback: check for mail/mailx
  if command_exists mail; then
    echo -e "${YELLOW}Note: mail command may not support attachments on all systems${NC}"
    echo "File: $file_path"
    echo ""
    echo "To send manually:"
    echo "  echo 'See attached' | mutt -s 'Shared file' -a '$file_path' -- $recipient"
    return 1
  fi

  error "No email client found. Install mutt:"
  echo "  brew install mutt    # macOS"
  echo "  apt install mutt     # Linux"
  return 1
}

# Start local HTTP server
tk_serve() {
  local source_path="$1"
  local port="${2:-8080}"

  local abs_path=$(cd "$source_path" 2>/dev/null && pwd || echo "$source_path")

  # If it's a directory, create an archive first
  local file_to_serve="$abs_path"
  if [ -d "$abs_path" ]; then
    file_to_serve=$(tk_create_archive "$abs_path")
  fi

  local filename=$(basename "$file_to_serve")
  local filesize=$(du -h "$file_to_serve" | cut -f1)

  # Get local IP
  local local_ip=""
  if command_exists ipconfig; then
    # macOS
    local_ip=$(ipconfig getifaddr en0 2>/dev/null || ipconfig getifaddr en1 2>/dev/null)
  else
    # Linux
    local_ip=$(hostname -I 2>/dev/null | awk '{print $1}')
  fi

  echo ""
  echo -e "${CYAN}Starting file server...${NC}"
  echo ""
  echo -e "  File:    ${BOLD}$filename${NC} ($filesize)"
  echo -e "  Local:   ${BOLD}http://localhost:$port/$filename${NC}"
  [ -n "$local_ip" ] && echo -e "  Network: ${BOLD}http://$local_ip:$port/$filename${NC}"
  echo ""

  # Generate QR code if qrencode is available
  if command_exists qrencode && [ -n "$local_ip" ]; then
    echo "QR Code (scan to download):"
    qrencode -t ANSI256 "http://$local_ip:$port/$filename" 2>/dev/null || true
    echo ""
  fi

  echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
  echo ""

  # Create a temporary directory for serving
  local serve_dir=$(mktemp -d)
  cp "$file_to_serve" "$serve_dir/"

  # Use Python's built-in HTTP server
  if command_exists python3; then
    cd "$serve_dir" && python3 -m http.server "$port"
  elif command_exists python; then
    cd "$serve_dir" && python -m SimpleHTTPServer "$port"
  else
    error "Python not found. Cannot start HTTP server."
    rm -rf "$serve_dir"
    return 1
  fi

  # Cleanup
  rm -rf "$serve_dir"
}

# Main toolkit share handler
handle_tk_share() {
  local path="${1:-.}"
  shift || true

  # Parse options
  local to=""
  local include_git="false"
  local include_deps="false"
  local zip_only="false"
  local serve_mode="false"
  local port="8080"

  while [ $# -gt 0 ]; do
    case "$1" in
      --to)
        to="$2"
        shift 2
        ;;
      --to=*)
        to="${1#--to=}"
        shift
        ;;
      --include-git)
        include_git="true"
        shift
        ;;
      --include-deps)
        include_deps="true"
        shift
        ;;
      --zip)
        zip_only="true"
        shift
        ;;
      --serve)
        serve_mode="true"
        shift
        ;;
      --port)
        port="$2"
        shift 2
        ;;
      --port=*)
        port="${1#--port=}"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  # Validate path
  if [ ! -e "$path" ]; then
    error "Path not found: $path"
    return 1
  fi

  # Handle serve mode
  if [ "$serve_mode" = "true" ]; then
    tk_serve "$path" "$port"
    return $?
  fi

  # Create archive if it's a directory
  local file_to_share="$path"
  if [ -d "$path" ]; then
    file_to_share=$(tk_create_archive "$path" "$include_git" "$include_deps")
    if [ $? -ne 0 ]; then
      return 1
    fi
  fi

  # Just create zip
  if [ "$zip_only" = "true" ]; then
    local filename=$(basename "$file_to_share")
    local dest="./$filename"
    cp "$file_to_share" "$dest"
    success "Archive created: $dest"
    return 0
  fi

  # Handle different destinations
  case "$to" in
    ""|url)
      # Default: use auto-fallback between transfer.sh and 0x0.st
      tk_upload_with_fallback "$file_to_share"
      ;;
    transfer.sh)
      # Explicit transfer.sh (no fallback)
      tk_upload_transfersh "$file_to_share"
      ;;
    0x0|0x0.st)
      tk_upload_0x0 "$file_to_share"
      ;;
    ssh:*|scp:*|rsync:*)
      local dest="${to#*:}"
      tk_transfer_ssh "$file_to_share" "$dest"
      ;;
    slack:*|slack)
      local channel="${to#slack:}"
      [ "$channel" = "slack" ] && channel=""
      tk_upload_slack "$file_to_share" "$channel"
      ;;
    email:*|mail:*)
      local recipient="${to#*:}"
      tk_send_email "$file_to_share" "$recipient"
      ;;
    *)
      # Assume it's an SSH destination if it contains @
      if [[ "$to" == *"@"* ]]; then
        tk_transfer_ssh "$file_to_share" "$to"
      else
        error "Unknown destination: $to"
        echo "Use: --to=url, --to=ssh:user@host, --to=slack:#channel, --to=email:addr"
        return 1
      fi
      ;;
  esac
}

# Show toolkit help
show_tk_help() {
  echo -e "${CYAN}Toolkit Commands${NC}"
  echo ""
  echo "Share files and folders:"
  echo "  crab tk share <path>                    Upload and get temp URL"
  echo "  crab tk share <path> --to ssh:user@host Transfer via SSH"
  echo "  crab tk share <path> --to slack:#chan   Upload to Slack"
  echo "  crab tk share <path> --to email:addr    Send via email"
  echo "  crab tk share <path> --zip              Just create archive"
  echo "  crab tk share <path> --serve            Start local HTTP server"
  echo ""
  echo "Options:"
  echo "  --include-git     Include .git folder"
  echo "  --include-deps    Include dependencies (node_modules, etc.)"
  echo "  --port=8080       Port for --serve mode"
  echo ""
  echo "For git repos, automatically excludes:"
  echo "  node_modules, vendor, venv, dist, build, .git, etc."
}

# Handle toolkit subcommand
handle_tk_command() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    "share")
      handle_tk_share "$@"
      ;;
    "serve")
      tk_serve "${1:-.}" "${2:-8080}"
      ;;
    ""|"help"|"-h"|"--help")
      show_tk_help
      ;;
    *)
      error "Unknown toolkit command: $cmd"
      echo "Run 'crab tk help' for usage"
      return 1
      ;;
  esac
}

# =============================================================================
# Slack Integration
# =============================================================================

# Get Slack bot token from env var (preferred) or config
slack_get_token() {
  if [ -n "${CRAB_SLACK_BOT_TOKEN:-}" ]; then
    echo "$CRAB_SLACK_BOT_TOKEN"
  else
    config_get "slack.bot_token" ""
  fi
}

# Get display name for messages (git config or override)
slack_get_display_name() {
  local configured=$(config_get "slack.display_name" "")
  if [ -n "$configured" ] && [ "$configured" != "null" ]; then
    echo "$configured"
  else
    git config user.name 2>/dev/null || whoami
  fi
}

# Lookup Slack user ID from @username
slack_get_user_id() {
  local username="$1"
  local token=$(slack_get_token)

  # Remove @ prefix if present
  username="${username#@}"

  # Get user list and find matching username
  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.list?limit=500")

  # Extract user ID where name or display_name matches
  echo "$response" | jq -r --arg name "$username" \
    '.members[] | select(.name == $name or .profile.display_name == $name or .real_name == $name) | .id' | head -1
}

# Lookup Slack channel ID from #channel
slack_get_channel_id() {
  local channel="$1"
  local token=$(slack_get_token)

  # Remove # prefix if present
  channel="${channel#\#}"

  # Get channel list
  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.list?types=public_channel,private_channel&limit=500")

  echo "$response" | jq -r --arg name "$channel" \
    '.channels[] | select(.name == $name) | .id' | head -1
}

# Open a DM channel with a user
slack_open_dm() {
  local user_id="$1"
  local token=$(slack_get_token)

  local response=$(curl -s -X POST -H "Authorization: Bearer $token" \
    -H "Content-Type: application/json" \
    -d "{\"users\":\"$user_id\"}" \
    "https://slack.com/api/conversations.open")

  echo "$response" | jq -r '.channel.id'
}

# Send a message to Slack
slack_post_message() {
  local channel_id="$1"
  local message="$2"
  local token=$(slack_get_token)
  local display_name=$(slack_get_display_name)

  # Format: 🦀 [Name] message - with crab icon as bot avatar
  local full_message="*[$display_name]* $message"

  local response=$(curl -s -X POST -H "Authorization: Bearer $token" \
    -H "Content-Type: application/json" \
    -d "$(jq -n \
      --arg channel "$channel_id" \
      --arg text "$full_message" \
      --arg username "crab ($display_name)" \
      '{channel: $channel, text: $text, icon_emoji: ":crab:", username: $username}')" \
    "https://slack.com/api/chat.postMessage")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" = "true" ]; then
    return 0
  else
    local err=$(echo "$response" | jq -r '.error')
    error "Slack API error: $err"
    return 1
  fi
}

# Read message history from a channel/DM
slack_read_history() {
  local channel_id="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.history?channel=$channel_id&limit=$limit")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" != "true" ]; then
    local err=$(echo "$response" | jq -r '.error')
    error "Failed to read history: $err"
    return 1
  fi

  # Parse and display messages (oldest first)
  echo "$response" | jq -r '.messages | reverse | .[] |
    "\(.ts | tonumber | strftime("%H:%M")) \(.user // "bot"): \(.text)"' 2>/dev/null
}

# Get username from user ID (for display)
slack_get_username() {
  local user_id="$1"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.info?user=$user_id")

  echo "$response" | jq -r '.user.profile.display_name // .user.real_name // .user.name'
}

# Cache for user ID to name mapping (file-based for bash 3.x compatibility)
SLACK_USER_CACHE_DIR="/tmp/crab-slack-cache-$$"

slack_get_username_cached() {
  local user_id="$1"
  local cache_file="$SLACK_USER_CACHE_DIR/$user_id"

  mkdir -p "$SLACK_USER_CACHE_DIR" 2>/dev/null

  if [ -f "$cache_file" ]; then
    cat "$cache_file"
  else
    local name=$(slack_get_username "$user_id")
    echo "$name" > "$cache_file"
    echo "$name"
  fi
}

# Format and display messages with usernames
slack_display_messages() {
  local channel_id="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.history?channel=$channel_id&limit=$limit")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" != "true" ]; then
    return 1
  fi

  # Get messages as JSON array (reversed for chronological order)
  local messages=$(echo "$response" | jq -c '.messages | reverse | .[]')

  while IFS= read -r msg; do
    local ts=$(echo "$msg" | jq -r '.ts | tonumber | strftime("%H:%M")')
    local user_id=$(echo "$msg" | jq -r '.user // empty')
    local text=$(echo "$msg" | jq -r '.text')
    local bot_name=$(echo "$msg" | jq -r '.bot_profile.name // empty')

    local sender
    if [ -n "$bot_name" ]; then
      sender="$bot_name"
    elif [ -n "$user_id" ]; then
      sender=$(slack_get_username_cached "$user_id")
    else
      sender="unknown"
    fi

    echo -e "${GRAY}[$ts]${NC} ${CYAN}$sender${NC}: $text"
  done <<< "$messages"
}

# Interactive chat mode
slack_chat() {
  local target="$1"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Set CRAB_SLACK_BOT_TOKEN env var"
    return 1
  fi

  # Resolve target to channel ID
  local channel_id
  local target_name

  if [[ "$target" == "#"* ]]; then
    target_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$target_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    target_name="${target#@}"
    local user_id=$(slack_get_user_id "$target_name")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  # Display chat header
  echo ""
  echo -e "${CYAN}━━ Chat with $target ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${GRAY}Type messages and press Enter. Ctrl+C to exit.${NC}"
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""

  # Show recent history
  slack_display_messages "$channel_id" 10

  echo ""
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

  # Chat loop
  local last_check=$(date +%s)

  while true; do
    # Non-blocking read with timeout for polling
    echo -ne "${GREEN}>${NC} "

    if read -t 5 -r message; then
      if [ -n "$message" ]; then
        if slack_post_message "$channel_id" "$message"; then
          echo -e "${GRAY}[sent]${NC}"
        fi
      fi
    fi

    # Poll for new messages every 5 seconds
    local now=$(date +%s)
    if [ $((now - last_check)) -ge 5 ]; then
      # Check for new messages (would need to track last seen timestamp for proper implementation)
      last_check=$now
    fi
  done
}

# Log file for sent messages
SLACK_SENT_LOG="$CONFIG_DIR/slack_sent.log"

# Log a sent message
slack_log_sent() {
  local target="$1"
  local message="$2"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local display_name=$(slack_get_display_name)

  mkdir -p "$CONFIG_DIR"
  echo "[$timestamp] $display_name → $target: $message" >> "$SLACK_SENT_LOG"
}

# View sent messages log
slack_view_sent() {
  local count="${1:-20}"

  if [ ! -f "$SLACK_SENT_LOG" ]; then
    echo "No sent messages yet."
    return
  fi

  echo -e "${CYAN}━━ Sent Messages ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  tail -n "$count" "$SLACK_SENT_LOG" | while IFS= read -r line; do
    echo -e "  ${GRAY}$line${NC}"
  done
  echo ""
}

# Quick send message
slack_send() {
  local target="$1"
  local message="$2"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Set CRAB_SLACK_BOT_TOKEN env var"
    return 1
  fi

  if [ -z "$target" ] || [ -z "$message" ]; then
    error "Usage: crab slack @user \"message\" or crab slack #channel \"message\""
    return 1
  fi

  # Resolve target to channel ID
  local channel_id

  if [[ "$target" == "#"* ]]; then
    local channel_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$channel_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    local username="${target#@}"
    local user_id=$(slack_get_user_id "$username")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  if slack_post_message "$channel_id" "$message"; then
    slack_log_sent "$target" "$message"
    success "Message sent to $target"
  fi
}

# Read recent messages from a conversation
slack_read() {
  local target="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Set CRAB_SLACK_BOT_TOKEN env var"
    return 1
  fi

  if [ -z "$target" ]; then
    error "Usage: crab slack read @user [count]"
    return 1
  fi

  # Resolve target to channel ID
  local channel_id
  local target_name

  if [[ "$target" == "#"* ]]; then
    target_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$target_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    target_name="${target#@}"
    local user_id=$(slack_get_user_id "$target_name")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  echo ""
  echo -e "${CYAN}━━ Messages with $target ━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  slack_display_messages "$channel_id" "$limit"
  echo ""
}

# List available users
slack_list_users() {
  local token=$(slack_get_token)
  local filter="${1:-}"

  echo -e "${CYAN}Slack Users:${NC}"
  echo ""

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.list?limit=200")

  if [ -n "$filter" ]; then
    echo "$response" | jq -r --arg filter "$filter" \
      '.members[] | select(.deleted == false and .is_bot == false) | select(.name | contains($filter)) | "  @\(.name)  \(.profile.display_name // .real_name // "-")"'
  else
    echo "$response" | jq -r \
      '.members[] | select(.deleted == false and .is_bot == false) | "  @\(.name)  \(.profile.display_name // .real_name // "-")"'
  fi
}

# Handle slack command
handle_slack_command() {
  local first="${1:-}"

  if [ -z "$first" ]; then
    show_slack_help
    return
  fi

  case "$first" in
    "chat")
      shift
      slack_chat "$@"
      ;;
    "read"|"history")
      shift
      slack_read "$@"
      ;;
    "sent"|"log")
      shift
      slack_view_sent "$@"
      ;;
    "users"|"list")
      shift
      slack_list_users "$@"
      ;;
    "help"|"-h"|"--help")
      show_slack_help
      ;;
    "@"*|"#"*)
      # Quick send: crab slack @user "message" or crab slack #channel "message"
      local target="$1"
      shift
      local message="$*"
      slack_send "$target" "$message"
      ;;
    *)
      error "Unknown slack command: $first"
      show_slack_help
      return 1
      ;;
  esac
}

show_slack_help() {
  echo -e "${CYAN}Slack Commands${NC}"
  echo ""
  echo "Quick send:"
  echo "  crab slack @user \"message\"      Send DM to a user"
  echo "  crab slack #channel \"message\"   Post to a channel"
  echo ""
  echo "Read messages:"
  echo "  crab slack read @user           Show recent DMs with user"
  echo "  crab slack read #channel        Show recent channel messages"
  echo "  crab slack read @user 20        Show last 20 messages"
  echo ""
  echo "Interactive chat:"
  echo "  crab slack chat @user           Open chat session with user"
  echo "  crab slack chat #channel        Open chat session in channel"
  echo ""
  echo "Utilities:"
  echo "  crab slack sent                 View your sent messages log"
  echo "  crab slack sent 50              Show last 50 sent messages"
  echo "  crab slack users                List all users"
  echo "  crab slack users mike           Search users by name"
  echo ""
  echo "Examples:"
  echo "  crab slack @michael \"hey, can you review my PR?\""
  echo "  crab slack read @michael"
  echo "  crab slack chat @michael"
  echo ""
  echo "Configuration:"
  echo "  export CRAB_SLACK_BOT_TOKEN=xoxb-your-token  # add to shell profile"
  echo ""
  echo "Optional (~/.crabcode/config.yaml):"
  echo "  slack:"
  echo "    display_name: \"Your Name\"  # defaults to git config"
}

# =============================================================================
# Init / Config / Doctor
# =============================================================================

# -- Template System ----------------------------------------------------------

template_promptfoo_cloud() {
  cat << 'TEMPLATE_EOF'
# Crabcode Configuration - Promptfoo Cloud Template
# Generated by 'crabcode init --template promptfoo-cloud'

session_name: ALIAS_PLACEHOLDER
workspace_base: WORKSPACE_BASE_PLACEHOLDER
main_repo: MAIN_REPO_PLACEHOLDER

workspaces:
  prefix: cloud-workspace
  branch_pattern: workspace-{N}

layout:
  panes:
    - name: terminal
      command: ""
    - name: server
      command: pnpm dev
    - name: main
      command: claude --dangerously-skip-permissions --chrome

install_command: pnpm install
install_env: PROMPTFOO_NODE_MODULES_CACHED=true

submodules:
  - path: promptfoo
    reset_to: origin/main
    install_command: pnpm install

env_sync:
  port_spacing: 10
  files:
    - path: server/.env
      copy_from: server/.env.example
      ports: [API_URL, APP_URL]
      refs:
        API_PORT: API_URL:port
    - path: app/.env
      copy_from: app/.env.example
      refs:
        VITE_API_BASE_URL: API_URL
        PORT: APP_URL:port
    - path: admin-app/.env
      copy_from: admin-app/.env.example
      refs:
        VITE_API_BASE_URL: API_URL
    - path: promptfoo/.env
      refs:
        PROMPTFOO_REMOTE_GENERATION_URL: API_URL
        PROMPTFOO_UNALIGNED_INFERENCE_ENDPOINT: API_URL
        API_HOST: API_URL

cleanup:
  preserve_files: ".env"
  kill_pattern: "cloud-workspace-{N}.*pnpm|cloud-workspace-{N}.*node"

shared_volume:
  enabled: true
  path: ~/.crabcode/shared
  link_as: .local
TEMPLATE_EOF
}

detect_template() {
  local repo_path="${1:-.}"

  # Check for promptfoo-cloud: has .gitmodules with "promptfoo" AND server/.env.example
  if [ -f "$repo_path/.gitmodules" ] && grep -q "promptfoo" "$repo_path/.gitmodules" 2>/dev/null \
     && [ -f "$repo_path/server/.env.example" ]; then
    echo "promptfoo-cloud"
    return
  fi

  # Fallback: directory name contains "promptfoo-cloud"
  if [[ "$(basename "$repo_path")" == *"promptfoo-cloud"* ]]; then
    echo "promptfoo-cloud"
    return
  fi

  echo ""
}

apply_template() {
  local template_name="$1"
  local main_repo="$2"
  local workspace_base="$3"
  local alias="${4:-crab}"

  local template_content=""
  case "$template_name" in
    "promptfoo-cloud")
      template_content="$(template_promptfoo_cloud)"
      ;;
    *)
      error "Unknown template: $template_name"
      return 1
      ;;
  esac

  mkdir -p "$PROJECTS_DIR"
  echo "$template_content" \
    | sed "s|MAIN_REPO_PLACEHOLDER|$main_repo|g" \
    | sed "s|WORKSPACE_BASE_PLACEHOLDER|$workspace_base|g" \
    | sed "s|ALIAS_PLACEHOLDER|$alias|g" \
    > "$CONFIG_FILE"
}

show_templates() {
  echo -e "${CYAN}Available Templates${NC}"
  echo ""
  echo -e "  ${GREEN}promptfoo-cloud${NC}  Full config for promptfoo-cloud repos"
  echo "                    Includes env_sync, submodules, port_spacing, install_env"
  echo ""
  echo "Usage:"
  echo "  crab init --template promptfoo-cloud"
  echo "  crab init -t promptfoo-cloud"
}

# -- End Template System ------------------------------------------------------

show_init() {
  # Parse arguments
  local template_name=""
  local alias_input=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --template|-t)
        template_name="$2"
        shift 2
        ;;
      --alias|-a)
        alias_input="$2"
        shift 2
        ;;
      --list-templates)
        show_templates
        return
        ;;
      *)
        shift
        ;;
    esac
  done

  echo -e "${CYAN}Crabcode Setup${NC}"
  echo ""

  # Main repo
  local default_repo=$(pwd)
  echo -e "Path to your main repo"
  read -p "  [$default_repo]: " main_repo
  main_repo=${main_repo:-$default_repo}

  # Expand ~
  main_repo="${main_repo/#\~/$HOME}"

  if [ ! -d "$main_repo" ]; then
    error "Directory does not exist: $main_repo"
    return 1
  fi

  if [ ! -d "$main_repo/.git" ]; then
    warn "Not a git repository: $main_repo"
    read -p "Continue anyway? [y/N]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      return 1
    fi
  fi

  # Project alias
  if [ -z "$alias_input" ]; then
    local default_alias=$(basename "$main_repo" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g')
    echo ""
    echo -e "Project alias (used in ${GREEN}crab @alias ws 1${NC})"
    read -p "  [$default_alias]: " alias_input
    alias_input=${alias_input:-$default_alias}
  fi

  # Validate alias
  if ! [[ "$alias_input" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Alias must be alphanumeric (dashes and underscores allowed)"
    return 1
  fi

  # Check for existing project with same alias
  if [ -f "$PROJECTS_DIR/${alias_input}.yaml" ]; then
    echo -e "${YELLOW}Project @$alias_input already exists.${NC}"
    read -p "Overwrite? [y/N]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo "Cancelled."
      return
    fi
  fi

  # Set CONFIG_FILE to the project-specific path
  CONFIG_FILE="$PROJECTS_DIR/${alias_input}.yaml"
  PROJECT_ALIAS="$alias_input"

  # Workspace base - derive from main repo
  local repo_name=$(basename "$main_repo")
  local repo_parent=$(dirname "$main_repo")
  local default_base="$repo_parent/${repo_name}-workspaces"

  echo ""
  echo -e "Where should workspaces be created?"
  echo -e "  (Each workspace is a git worktree, e.g., ${repo_name}-workspaces/ws-1)"
  read -p "  [$default_base]: " workspace_base
  workspace_base=${workspace_base:-$default_base}

  # Expand ~
  workspace_base="${workspace_base/#\~/$HOME}"

  # Check for project-level config in repo directory
  local project_config="$main_repo/.crabcode.yaml"
  if [ -f "$project_config" ]; then
    echo ""
    echo -e "${GREEN}Found project config: .crabcode.yaml${NC}"
    read -p "Import settings from it? [Y/n]: " use_project
    if [ "$use_project" != "n" ] && [ "$use_project" != "N" ]; then
      mkdir -p "$PROJECTS_DIR"
      cp "$project_config" "$CONFIG_FILE"

      # Update paths to absolute if they use relative paths
      local main_repo_val=$(yq -r '.main_repo // ""' "$CONFIG_FILE" 2>/dev/null)
      if [ -z "$main_repo_val" ] || [ "$main_repo_val" = "null" ] || [[ "$main_repo_val" == "~/"* ]] || [[ "$main_repo_val" == "./"* ]]; then
        yq -i ".main_repo = \"$main_repo\"" "$CONFIG_FILE"
      fi

      local ws_base_val=$(yq -r '.workspace_base // ""' "$CONFIG_FILE" 2>/dev/null)
      if [ -z "$ws_base_val" ] || [ "$ws_base_val" = "null" ]; then
        yq -i ".workspace_base = \"$workspace_base\"" "$CONFIG_FILE"
      fi

      # Set session_name to alias
      yq -i ".session_name = \"$alias_input\"" "$CONFIG_FILE"

      # Set as default if first project
      _init_set_default_if_first "$alias_input"

      echo ""
      success "Project @$alias_input registered at $CONFIG_FILE"
      echo ""
      echo -e "${CYAN}Next steps:${NC}"
      echo "  1. Review config: crab @$alias_input config"
      echo "  2. Run 'crab @$alias_input config scan' to detect ports"
      echo "  3. Run 'crab @$alias_input ws 1' to create your first workspace"
      return
    fi
    echo ""
  fi

  # Template handling: explicit flag or auto-detection
  if [ -n "$template_name" ]; then
    case "$template_name" in
      "promptfoo-cloud"|"pf")
        template_name="promptfoo-cloud"
        ;;
      *)
        error "Unknown template: $template_name"
        echo "Run 'crab init --list-templates' to see available templates."
        return 1
        ;;
    esac
    echo ""
    echo -e "Applying ${GREEN}$template_name${NC} template..."
    apply_template "$template_name" "$main_repo" "$workspace_base" "$alias_input"
    _init_set_default_if_first "$alias_input"
    echo ""
    success "Project @$alias_input registered at $CONFIG_FILE (template: $template_name)"
    echo ""
    echo -e "${CYAN}Next steps:${NC}"
    echo "  1. Review config: crab @$alias_input config"
    echo "  2. Run 'crab @$alias_input ws 1' to create your first workspace"
    return
  fi

  # Auto-detect template from repo contents
  local detected
  detected=$(detect_template "$main_repo")
  if [ -n "$detected" ]; then
    echo ""
    echo -e "Detected ${GREEN}$detected${NC} project."
    read -p "Use template? [Y/n]: " use_tpl
    if [ "$use_tpl" != "n" ] && [ "$use_tpl" != "N" ]; then
      echo ""
      echo -e "Applying ${GREEN}$detected${NC} template..."
      apply_template "$detected" "$main_repo" "$workspace_base" "$alias_input"
      _init_set_default_if_first "$alias_input"
      echo ""
      success "Project @$alias_input registered at $CONFIG_FILE (template: $detected)"
      echo ""
      echo -e "${CYAN}Next steps:${NC}"
      echo "  1. Review config: crab @$alias_input config"
      echo "  2. Run 'crab @$alias_input ws 1' to create your first workspace"
      return
    fi
    echo ""
  fi

  # No template - generate minimal config
  mkdir -p "$PROJECTS_DIR"

  cat > "$CONFIG_FILE" << EOF
# Crabcode Configuration
# Generated by 'crabcode init'
# Project: @$alias_input
# Run 'crab config scan' to auto-detect env files and ports

session_name: $alias_input
workspace_base: $workspace_base
main_repo: $main_repo

workspaces:
  prefix: ws
  branch_pattern: workspace-{N}

layout:
  panes:
    - name: terminal
      command: ""
    - name: server
      command: ""
    - name: main
      command: ""

# Run 'crab config scan' to detect .env files and generate env_sync config
# Then edit this file to customize:
#
# env_sync:
#   files:
#     - path: .env
#       ports: [PORT, API_PORT]
#
# layout:
#   panes:
#     - name: terminal
#       command: ""
#     - name: server
#       command: "npm run dev"
#     - name: main
#       command: "claude"
#
# shared_volume:
#   enabled: true
#   path: ~/.crabcode/shared
#   link_as: .local
#
# submodules:
#   - path: my-submodule
#     reset_to: origin/main
EOF

  _init_set_default_if_first "$alias_input"

  echo ""
  success "Project @$alias_input registered at $CONFIG_FILE"
  echo ""
  echo -e "${CYAN}Next steps:${NC}"
  echo ""
  echo "  1. Run 'crab @$alias_input config scan' to detect .env files and ports"
  echo "  2. Edit $CONFIG_FILE to set your layout commands:"
  echo "     - server pane: your dev server command (e.g., pnpm dev)"
  echo "     - main pane: your main tool (e.g., claude)"
  echo "  3. Run 'crab @$alias_input ws 1' to create your first workspace"
  echo ""
}

# Helper: set as default project if it's the first one registered
_init_set_default_if_first() {
  local alias="$1"
  local count=0
  for f in "$PROJECTS_DIR"/*.yaml; do
    [ -f "$f" ] || continue
    count=$((count + 1))
  done

  if [ "$count" -le 1 ]; then
    mkdir -p "$CONFIG_DIR"
    # Use yq to set default_project if global config exists, else create it
    if [ -f "$GLOBAL_CONFIG" ] && yq -r '.default_project' "$GLOBAL_CONFIG" &>/dev/null; then
      yq -i ".default_project = \"$alias\"" "$GLOBAL_CONFIG"
    else
      cat > "$GLOBAL_CONFIG" << EOF
# Crabcode Global Configuration
default_project: $alias
EOF
    fi
    echo -e "  ${GREEN}Set as default project${NC} (use 'crab default' to change)"
  fi
}

# =============================================================================
# Config Scan - Discover env files and provide template
# =============================================================================

config_scan() {
  echo -e "${CYAN}Scanning for .env files...${NC}"
  echo ""

  if ! config_exists; then
    error "No config file found. Run 'crab init' first."
    return 1
  fi

  load_config

  local repo_path=$(expand_path "$MAIN_REPO")
  if [ ! -d "$repo_path" ]; then
    error "Main repo not found: $repo_path"
    return 1
  fi

  # Find all .env and .env.example files (bash 3.x compatible)
  local env_files=""
  local file_count=0

  while IFS= read -r file; do
    [ -z "$file" ] && continue
    env_files="$env_files$file"$'\n'
    file_count=$((file_count + 1))
  done < <(find "$repo_path" -maxdepth 3 -type f \( -name ".env" -o -name ".env.example" \) ! -path "*/node_modules/*" ! -path "*/.git/*" 2>/dev/null | sort)

  if [ $file_count -eq 0 ]; then
    echo "  No .env files found in $repo_path"
    echo ""
    echo "  You can manually configure env_sync in $CONFIG_FILE"
    return 0
  fi

  echo -e "Found ${GREEN}${file_count}${NC} env file(s):"
  echo ""

  # Group files by directory, prioritize .env over .env.example
  local dirs_seen=""
  local files_to_show=""

  echo "$env_files" | while IFS= read -r file; do
    [ -z "$file" ] && continue
    local rel_path="${file#$repo_path/}"
    local dir_path=$(dirname "$rel_path")
    local file_name=$(basename "$file")

    # Determine the target .env path (without .example)
    local target_path="$rel_path"
    local copy_from=""

    case "$file_name" in
      .env.example)
        target_path="${rel_path%.example}"
        # Check if .env exists (prioritize it)
        if [ -f "$repo_path/$target_path" ]; then
          # .env exists, skip .env.example
          continue
        fi
        copy_from="$rel_path"
        ;;
      .env)
        # Check if .env.example also exists
        if [ -f "$file.example" ]; then
          copy_from="${rel_path}.example"
        fi
        ;;
    esac

    echo -e "  ${BOLD}$target_path${NC}"
    if [ -n "$copy_from" ]; then
      echo -e "    └─ copy from: ${CYAN}$copy_from${NC}"
    fi
  done

  echo ""
  echo -e "${CYAN}Add to $CONFIG_FILE:${NC}"
  echo ""
  echo "env_sync:"
  echo "  files:"

  # Generate template
  local shown_paths=""
  echo "$env_files" | while IFS= read -r file; do
    [ -z "$file" ] && continue
    local rel_path="${file#$repo_path/}"
    local file_name=$(basename "$file")

    local target_path="$rel_path"
    local copy_from=""

    case "$file_name" in
      .env.example)
        target_path="${rel_path%.example}"
        if [ -f "$repo_path/$target_path" ]; then
          continue
        fi
        copy_from="$rel_path"
        ;;
      .env)
        if [ -f "$file.example" ]; then
          copy_from="${rel_path}.example"
        fi
        ;;
    esac

    # Skip if already shown
    case "$shown_paths" in
      *"$target_path"*) continue ;;
    esac
    shown_paths="$shown_paths $target_path"

    echo "    - path: $target_path"
    if [ -n "$copy_from" ]; then
      echo "      copy_from: $copy_from"
    fi
    echo "      ports: []           # e.g., [API_PORT, ADMIN_PORT]"
    echo "      # refs:             # optional: URL vars that reference ports"
    echo "      #   VITE_API_URL: API_PORT"
  done

  echo ""
  echo -e "${CYAN}How it works:${NC}"
  echo "  - ports: vars crab manages (increments per workspace, checks availability)"
  echo "  - refs: URL vars that reference a managed port (auto-rewritten)"
  echo "  - other vars: just copied from copy_from template"
  echo ""
  echo -e "${CYAN}Example for promptfoo-cloud:${NC}"
  echo ""
  echo "env_sync:"
  echo "  files:"
  echo "    - path: server/.env"
  echo "      copy_from: server/.env.example"
  echo "      ports: [API_PORT, ADMIN_PORT]"
  echo "    - path: app/.env"
  echo "      copy_from: app/.env.example"
  echo "      ports: [VITE_PORT]"
  echo "      refs:"
  echo "        VITE_API_URL: API_PORT"
}

show_config() {
  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo "Run 'crabcode init' to create one."
    return
  fi

  echo -e "${CYAN}Crabcode Configuration${NC}"
  if [ -n "${PROJECT_ALIAS:-}" ]; then
    echo "Project: @$PROJECT_ALIAS"
  fi
  echo "File: $CONFIG_FILE"
  echo ""
  cat "$CONFIG_FILE"
}

show_doctor() {
  echo -e "${CYAN}    \\___/${NC}"
  echo -e "${CYAN}   ( •_•)  Crabcode Doctor${NC}"
  echo -e "${CYAN}  /)🦀(\\${NC}"
  echo ""

  if [ -n "${PROJECT_ALIAS:-}" ]; then
    echo -e "  project: ${GREEN}@$PROJECT_ALIAS${NC}"
  fi

  local issues=0

  # Check yq
  echo -n "  yq: "
  if command_exists yq; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check tmux
  echo -n "  tmux: "
  if command_exists tmux; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check git
  echo -n "  git: "
  if command_exists git; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check config
  echo -n "  config: "
  if config_exists; then
    echo -e "${GREEN}exists${NC}"

    # Validate config
    load_config

    echo -n "  session_name: "
    if [ -n "$SESSION_NAME" ]; then
      echo -e "${GREEN}$SESSION_NAME${NC}"
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

    echo -n "  workspace_base: "
    if [ -n "$WORKSPACE_BASE" ]; then
      if [ -d "$WORKSPACE_BASE" ] || [ -d "$(dirname "$WORKSPACE_BASE")" ]; then
        echo -e "${GREEN}$WORKSPACE_BASE${NC}"
      else
        echo -e "${YELLOW}$WORKSPACE_BASE (will be created)${NC}"
      fi
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

    echo -n "  main_repo: "
    if [ -n "$MAIN_REPO" ]; then
      if [ -d "$MAIN_REPO" ]; then
        echo -e "${GREEN}$MAIN_REPO${NC}"
      else
        echo -e "${RED}$MAIN_REPO (not found)${NC}"
        issues=$((issues + 1))
      fi
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

  else
    echo -e "${YELLOW}not found${NC}"
    echo ""
    echo "Run 'crabcode init' to create a config file."
    return
  fi

  # Check shared volume
  echo -n "  shared_volume: "
  if [ "$SHARED_VOLUME_ENABLED" = "true" ]; then
    if [ -d "$SHARED_VOLUME_PATH" ]; then
      echo -e "${GREEN}$SHARED_VOLUME_PATH${NC}"
    else
      echo -e "${YELLOW}$SHARED_VOLUME_PATH (will be created)${NC}"
    fi
  else
    echo -e "${YELLOW}disabled${NC}"
  fi

  echo ""
  if [ $issues -eq 0 ]; then
    echo -e "${GREEN}   \\o/${NC}"
    echo -e "${GREEN}  ( ˆᴗˆ )  All checks passed!${NC}"
    echo -e "${GREEN}  /)🦀(\\${NC}"
  else
    echo -e "${RED}   \\__/${NC}"
    echo -e "${RED}  ( •̩̩̩-•̩̩̩ )  $issues issue(s) found${NC}"
    echo -e "${RED}  /)🦀(\\${NC}"
  fi
}

# =============================================================================
# Crab Mood - Fun ASCII crab that reacts to your work
# =============================================================================

MOOD_FILE="$CONFIG_DIR/mood.json"

# ASCII art for different moods
crab_art_happy() {
  cat << 'EOF'
    \o/
   ( ˆ ᴗ ˆ )
  /)🦀(\

EOF
}

crab_art_excited() {
  cat << 'EOF'
   \(★ω★)/
  /)  🎉  (\
     🦀

EOF
}

crab_art_working() {
  cat << 'EOF'
      💻
   ( •_•)
  /)🦀(\

EOF
}

crab_art_nervous() {
  cat << 'EOF'
      😰
   (°△°;)
  /)🦀(\

EOF
}

crab_art_sleepy() {
  cat << 'EOF'
     💤
   ( -_-)
  /)🦀(\

EOF
}

crab_art_chill() {
  cat << 'EOF'
     🌴
   ( ˘ω˘)
  /)🦀(\  🍹

EOF
}

crab_art_celebrating() {
  cat << 'EOF'
   🎊\(^o^)/🎊
  /)  🦀  (\
   🎉 🎉 🎉

EOF
}

# Record a mood event
mood_record_event() {
  local event_type="$1"
  local details="${2:-}"
  local timestamp=$(date +%s)

  mkdir -p "$CONFIG_DIR"

  # Initialize mood file if doesn't exist
  if [ ! -f "$MOOD_FILE" ]; then
    echo '{"events":[],"stats":{"commits":0,"cleanups":0,"restarts":0,"wip_saves":0,"prs_merged":0}}' > "$MOOD_FILE"
  fi

  # Add event (keep last 50 events)
  if command_exists jq; then
    local tmp_file="/tmp/mood_$$"
    jq --arg type "$event_type" --arg details "$details" --arg ts "$timestamp" \
      '.events = ([{type: $type, details: $details, timestamp: ($ts | tonumber)}] + .events)[:50] |
       if $type == "commit" then .stats.commits += 1
       elif $type == "cleanup" then .stats.cleanups += 1
       elif $type == "restart" then .stats.restarts += 1
       elif $type == "wip_save" then .stats.wip_saves += 1
       elif $type == "pr_merged" then .stats.prs_merged += 1
       else . end' "$MOOD_FILE" > "$tmp_file" && mv "$tmp_file" "$MOOD_FILE"
  fi
}

# Calculate current mood based on events and context
mood_calculate() {
  local now=$(date +%s)
  local hour=$(date +%H)
  local day_of_week=$(date +%u)  # 1=Monday, 7=Sunday

  # Default mood
  local mood="working"
  local message="Keep coding!"

  # Check if we have jq for JSON parsing
  if ! command_exists jq; then
    echo "working:No jq installed - but keep up the great work!"
    return
  fi

  # Check if mood file exists
  if [ ! -f "$MOOD_FILE" ]; then
    echo "working:Fresh start - let's build something awesome!"
    return
  fi

  # Get recent events (last hour)
  local recent_commits=$(jq "[.events[] | select(.type == \"commit\" and .timestamp > ($now - 3600))] | length" "$MOOD_FILE" 2>/dev/null || echo 0)
  local recent_prs=$(jq "[.events[] | select(.type == \"pr_merged\" and .timestamp > ($now - 86400))] | length" "$MOOD_FILE" 2>/dev/null || echo 0)
  local total_commits=$(jq ".stats.commits // 0" "$MOOD_FILE" 2>/dev/null || echo 0)
  local last_event_time=$(jq ".events[0].timestamp // 0" "$MOOD_FILE" 2>/dev/null || echo 0)
  local last_event_type=$(jq -r ".events[0].type // \"none\"" "$MOOD_FILE" 2>/dev/null || echo "none")

  # Calculate time since last event
  local time_since_last=$((now - last_event_time))

  # Check workspace state
  local has_dirty_workspace=false
  if [ -n "${WORKSPACE_BASE:-}" ] && [ -d "$WORKSPACE_BASE" ]; then
    for ws_dir in "$WORKSPACE_BASE"/"${WORKSPACE_PREFIX:-workspace}"-*; do
      if [ -d "$ws_dir/.git" ]; then
        if [ -n "$(git -C "$ws_dir" status --porcelain 2>/dev/null)" ]; then
          has_dirty_workspace=true
          break
        fi
      fi
    done
  fi

  # Determine mood
  if [ "$recent_prs" -ge 2 ]; then
    mood="celebrating"
    message="$recent_prs PRs merged today! You're on fire! 🔥"
  elif [ "$recent_prs" -ge 1 ]; then
    mood="excited"
    message="PR merged! Time to celebrate! 🎉"
  elif [ "$recent_commits" -ge 5 ]; then
    mood="excited"
    message="$recent_commits commits in the last hour! Crushing it!"
  elif [ "$last_event_type" = "cleanup" ] && [ "$time_since_last" -lt 300 ]; then
    mood="happy"
    message="Fresh workspace, fresh start! ✨"
  elif [ "$has_dirty_workspace" = true ]; then
    mood="nervous"
    message="You have uncommitted changes... don't forget to commit!"
  elif [ "$time_since_last" -gt 7200 ]; then  # More than 2 hours since last event
    mood="sleepy"
    message="Been quiet... taking a break? 😴"
  elif [ "$day_of_week" -ge 6 ] && [ "$hour" -ge 18 ]; then  # Weekend evening
    mood="chill"
    message="Weekend vibes... maybe time to relax? 🌴"
  elif [ "$hour" -ge 22 ] || [ "$hour" -lt 6 ]; then  # Late night / early morning
    mood="sleepy"
    message="It's late... get some rest! 🌙"
  elif [ "$recent_commits" -ge 1 ]; then
    mood="happy"
    message="$recent_commits commits recently - nice progress!"
  else
    mood="working"
    message="In the zone... keep it up! 💪"
  fi

  echo "$mood:$message"
}

# Show current crab mood
show_mood() {
  load_config 2>/dev/null || true

  local result=$(mood_calculate)
  local mood=$(echo "$result" | cut -d: -f1)
  local message=$(echo "$result" | cut -d: -f2-)

  echo ""
  echo -e "${CYAN}╭──────────────────────────────────────╮${NC}"

  # Show the ASCII art
  case "$mood" in
    "happy")
      echo -e "${GREEN}"
      crab_art_happy
      echo -e "${NC}"
      ;;
    "excited")
      echo -e "${YELLOW}"
      crab_art_excited
      echo -e "${NC}"
      ;;
    "celebrating")
      echo -e "${MAGENTA}"
      crab_art_celebrating
      echo -e "${NC}"
      ;;
    "nervous")
      echo -e "${YELLOW}"
      crab_art_nervous
      echo -e "${NC}"
      ;;
    "sleepy")
      echo -e "${GRAY}"
      crab_art_sleepy
      echo -e "${NC}"
      ;;
    "chill")
      echo -e "${CYAN}"
      crab_art_chill
      echo -e "${NC}"
      ;;
    *)
      echo -e "${BLUE}"
      crab_art_working
      echo -e "${NC}"
      ;;
  esac

  echo -e "${CYAN}╰──────────────────────────────────────╯${NC}"
  echo ""
  echo -e "  ${BOLD}Mood:${NC} $mood"
  echo -e "  ${message}"
  echo ""

  # Show quick stats if available
  if command_exists jq && [ -f "$MOOD_FILE" ]; then
    local total_commits=$(jq ".stats.commits // 0" "$MOOD_FILE" 2>/dev/null || echo 0)
    local total_cleanups=$(jq ".stats.cleanups // 0" "$MOOD_FILE" 2>/dev/null || echo 0)
    local total_wip=$(jq ".stats.wip_saves // 0" "$MOOD_FILE" 2>/dev/null || echo 0)

    if [ "$total_commits" -gt 0 ] || [ "$total_cleanups" -gt 0 ]; then
      echo -e "  ${GRAY}Stats: $total_commits commits, $total_cleanups cleanups, $total_wip WIPs saved${NC}"
      echo ""
    fi
  fi
}

# Check for git events in a workspace and record them
mood_check_git_activity() {
  local workspace_dir="$1"

  if [ ! -d "$workspace_dir/.git" ]; then
    return
  fi

  # Check for new commits in last 5 minutes
  local recent_commits=$(git -C "$workspace_dir" log --oneline --since="5 minutes ago" 2>/dev/null | wc -l | tr -d ' ')
  if [ "$recent_commits" -gt 0 ]; then
    mood_record_event "commit" "$recent_commits new commits"
  fi
}

# =============================================================================
# Mobile Companion - Check status and get notifications from your phone
# =============================================================================

MOBILE_CONFIG_FILE="$CONFIG_DIR/mobile.json"

# Initialize mobile config
mobile_init() {
  if [ ! -f "$MOBILE_CONFIG_FILE" ]; then
    # Generate a random topic name for ntfy.sh
    local random_topic="crab-$(openssl rand -hex 4 2>/dev/null || echo $RANDOM$RANDOM)"
    echo "{\"ntfy_topic\":\"$random_topic\",\"enabled\":true}" > "$MOBILE_CONFIG_FILE"
  fi
}

# Get ntfy topic
mobile_get_topic() {
  mobile_init
  if command_exists jq && [ -f "$MOBILE_CONFIG_FILE" ]; then
    jq -r ".ntfy_topic // \"\"" "$MOBILE_CONFIG_FILE" 2>/dev/null
  else
    echo ""
  fi
}

# Send push notification via ntfy.sh
crab_notify() {
  local title="${1:-Crab Update}"
  local message="${2:-}"
  local priority="${3:-default}"  # min, low, default, high, urgent

  mobile_init
  local topic=$(mobile_get_topic)

  if [ -z "$topic" ]; then
    error "Mobile notifications not configured. Run 'crab mobile setup'"
    return 1
  fi

  # Map priority to ntfy format
  local ntfy_priority="3"
  case "$priority" in
    "urgent") ntfy_priority="5" ;;
    "high") ntfy_priority="4" ;;
    "default") ntfy_priority="3" ;;
    "low") ntfy_priority="2" ;;
    "min") ntfy_priority="1" ;;
  esac

  # Send notification
  if curl -s \
    -H "Title: 🦀 $title" \
    -H "Priority: $ntfy_priority" \
    -H "Tags: crab" \
    -d "$message" \
    "https://ntfy.sh/$topic" > /dev/null 2>&1; then
    success "Notification sent!"
  else
    error "Failed to send notification"
    return 1
  fi
}

# Generate status JSON for mobile API
generate_status_json() {
  load_config 2>/dev/null || true

  local workspaces_json="[]"

  if [ -n "${WORKSPACE_BASE:-}" ] && [ -d "$WORKSPACE_BASE" ]; then
    local ws_array="["
    local first=true

    for ws_dir in "$WORKSPACE_BASE"/"${WORKSPACE_PREFIX:-workspace}"-*; do
      [ -d "$ws_dir" ] || continue

      local ws_name=$(basename "$ws_dir")
      local num=$(echo "$ws_name" | sed 's/.*-//')
      local branch=""
      local status="clean"
      local changes=0

      if [ -d "$ws_dir/.git" ]; then
        branch=$(git -C "$ws_dir" branch --show-current 2>/dev/null || echo "unknown")
        local git_status=$(git -C "$ws_dir" status --porcelain 2>/dev/null || echo "")
        if [ -n "$git_status" ]; then
          status="dirty"
          changes=$(echo "$git_status" | wc -l | tr -d ' ')
        fi
      fi

      [ "$first" = true ] || ws_array+=","
      first=false
      ws_array+="{\"number\":$num,\"branch\":\"$branch\",\"status\":\"$status\",\"changes\":$changes}"
    done

    ws_array+="]"
    workspaces_json="$ws_array"
  fi

  # Get mood
  local mood_result=$(mood_calculate 2>/dev/null || echo "working:Keep coding!")
  local mood=$(echo "$mood_result" | cut -d: -f1)
  local mood_message=$(echo "$mood_result" | cut -d: -f2-)

  # Get stats
  local stats_json="{}"
  if command_exists jq && [ -f "$MOOD_FILE" ]; then
    stats_json=$(jq ".stats // {}" "$MOOD_FILE" 2>/dev/null || echo "{}")
  fi

  cat << EOF
{
  "timestamp": "$(date -Iseconds)",
  "hostname": "$(hostname)",
  "mood": "$mood",
  "mood_message": "$mood_message",
  "workspaces": $workspaces_json,
  "stats": $stats_json
}
EOF
}

# Show status in terminal or JSON format
show_status() {
  local format="${1:-terminal}"

  if [ "$format" = "json" ] || [ "$format" = "--json" ]; then
    generate_status_json
    return
  fi

  load_config 2>/dev/null || true

  echo ""
  echo -e "${CYAN}╭────────────────────────────────────────────────────╮${NC}"
  if [ -n "${PROJECT_ALIAS:-}" ]; then
    echo -e "${CYAN}│${NC}         ${BOLD}🦀 CRAB STATUS (@$PROJECT_ALIAS)${NC}$(printf '%*s' $((18 - ${#PROJECT_ALIAS})) '')${CYAN}│${NC}"
  else
    echo -e "${CYAN}│${NC}              ${BOLD}🦀 CRAB STATUS${NC}                       ${CYAN}│${NC}"
  fi
  echo -e "${CYAN}╰────────────────────────────────────────────────────╯${NC}"
  echo ""

  # Show mood summary
  local mood_result=$(mood_calculate 2>/dev/null || echo "working:Keep coding!")
  local mood=$(echo "$mood_result" | cut -d: -f1)
  echo -e "  ${BOLD}Mood:${NC} $mood"
  echo ""

  # Show workspaces
  if [ -n "${WORKSPACE_BASE:-}" ] && [ -d "$WORKSPACE_BASE" ]; then
    echo -e "  ${BOLD}Workspaces:${NC}"
    for ws_dir in "$WORKSPACE_BASE"/"${WORKSPACE_PREFIX:-workspace}"-*; do
      [ -d "$ws_dir" ] || continue

      local ws_name=$(basename "$ws_dir")
      local num=$(echo "$ws_name" | sed 's/.*-//')
      local branch=""
      local status_icon="✓"
      local status_color="${GREEN}"

      if [ -d "$ws_dir/.git" ]; then
        branch=$(git -C "$ws_dir" branch --show-current 2>/dev/null || echo "unknown")
        local git_status=$(git -C "$ws_dir" status --porcelain 2>/dev/null || echo "")
        if [ -n "$git_status" ]; then
          local changes=$(echo "$git_status" | wc -l | tr -d ' ')
          status_icon="●"
          status_color="${YELLOW}"
          echo -e "    ${status_color}${status_icon}${NC} ws-$num: $branch (${YELLOW}$changes changes${NC})"
        else
          echo -e "    ${status_color}${status_icon}${NC} ws-$num: $branch"
        fi
      fi
    done
  fi
  echo ""
}

# Start simple HTTP server for mobile dashboard
start_mobile_server() {
  local port="${1:-8888}"

  echo -e "${CYAN}Starting mobile dashboard server...${NC}"
  echo ""
  echo -e "  ${BOLD}Local:${NC}   http://localhost:$port"
  echo -e "  ${BOLD}Network:${NC} http://$(ipconfig getifaddr en0 2>/dev/null || hostname -I 2>/dev/null | awk '{print $1}' || echo 'localhost'):$port"
  echo ""
  echo -e "${GRAY}Press Ctrl+C to stop${NC}"
  echo ""

  # Check if python is available
  if command_exists python3; then
    # Create a simple HTML dashboard
    local tmp_dir="/tmp/crab-mobile-$$"
    mkdir -p "$tmp_dir"

    # Generate dashboard HTML
    cat > "$tmp_dir/index.html" << 'HTMLEOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🦀 Crab Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 600px; margin: 0 auto; }
    .header {
      text-align: center;
      padding: 30px 0;
    }
    .header h1 { font-size: 2.5em; }
    .mood-card {
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      margin-bottom: 20px;
    }
    .mood-emoji { font-size: 4em; }
    .mood-text { font-size: 1.2em; color: #aaa; margin-top: 10px; }
    .workspace-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px 20px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .ws-name { font-weight: bold; }
    .ws-branch { color: #888; font-size: 0.9em; }
    .ws-status { font-size: 1.5em; }
    .ws-status.clean { color: #4ade80; }
    .ws-status.dirty { color: #fbbf24; }
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-top: 20px;
    }
    .stat-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
    }
    .stat-number { font-size: 2em; font-weight: bold; color: #60a5fa; }
    .stat-label { color: #888; font-size: 0.85em; margin-top: 5px; }
    .actions {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 20px;
    }
    .action-btn {
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      border: none;
      border-radius: 12px;
      padding: 15px;
      color: white;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
    }
    .action-btn:active { transform: scale(0.98); }
    .action-btn.danger { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }
    .refresh-note { text-align: center; color: #666; margin-top: 20px; font-size: 0.85em; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🦀 Crab</h1>
    </div>

    <div class="mood-card">
      <div class="mood-emoji" id="mood-emoji">💻</div>
      <div class="mood-text" id="mood-text">Loading...</div>
    </div>

    <h3 style="margin-bottom: 15px;">Workspaces</h3>
    <div id="workspaces"></div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-number" id="stat-commits">-</div>
        <div class="stat-label">Commits</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="stat-cleanups">-</div>
        <div class="stat-label">Cleanups</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="stat-wips">-</div>
        <div class="stat-label">WIPs</div>
      </div>
    </div>

    <div class="refresh-note">Pull down to refresh</div>
  </div>

  <script>
    const moodEmojis = {
      happy: '😊', excited: '🎉', celebrating: '🎊',
      working: '💻', nervous: '😰', sleepy: '😴', chill: '🌴'
    };

    async function loadStatus() {
      try {
        const res = await fetch('/api/status');
        const data = await res.json();

        document.getElementById('mood-emoji').textContent = moodEmojis[data.mood] || '🦀';
        document.getElementById('mood-text').textContent = data.mood_message;

        const wsContainer = document.getElementById('workspaces');
        wsContainer.innerHTML = data.workspaces.map(ws => `
          <div class="workspace-card">
            <div>
              <div class="ws-name">ws-${ws.number}</div>
              <div class="ws-branch">${ws.branch}</div>
            </div>
            <div class="ws-status ${ws.status}">${ws.status === 'clean' ? '✓' : '●'}</div>
          </div>
        `).join('');

        if (data.stats) {
          document.getElementById('stat-commits').textContent = data.stats.commits || 0;
          document.getElementById('stat-cleanups').textContent = data.stats.cleanups || 0;
          document.getElementById('stat-wips').textContent = data.stats.wip_saves || 0;
        }
      } catch (e) {
        console.error('Failed to load status:', e);
      }
    }

    loadStatus();
    setInterval(loadStatus, 5000);
  </script>
</body>
</html>
HTMLEOF

    # Create a simple Python server that serves both static files and API
    cat > "$tmp_dir/server.py" << PYEOF
import http.server
import json
import subprocess
import os

class CrabHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/api/status':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            try:
                result = subprocess.run(
                    ['$0', 'status', '--json'],
                    capture_output=True, text=True, timeout=10
                )
                self.wfile.write(result.stdout.encode())
            except Exception as e:
                self.wfile.write(json.dumps({"error": str(e)}).encode())
        else:
            super().do_GET()

os.chdir('$tmp_dir')
server = http.server.HTTPServer(('0.0.0.0', $port), CrabHandler)
server.serve_forever()
PYEOF

    # Run the server
    python3 "$tmp_dir/server.py"

    # Cleanup on exit
    rm -rf "$tmp_dir"
  else
    error "Python 3 is required for the mobile dashboard"
    echo "Install with: brew install python3"
    exit 1
  fi
}

# Mobile setup wizard
mobile_setup() {
  echo -e "${CYAN}╭────────────────────────────────────────────────────╮${NC}"
  echo -e "${CYAN}│${NC}         ${BOLD}🦀 Mobile Companion Setup${NC}                  ${CYAN}│${NC}"
  echo -e "${CYAN}╰────────────────────────────────────────────────────╯${NC}"
  echo ""

  mobile_init
  local topic=$(mobile_get_topic)

  echo -e "${BOLD}Push Notifications (via ntfy.sh)${NC}"
  echo ""
  echo "  1. Install the ntfy app on your phone:"
  echo "     - iOS: https://apps.apple.com/app/ntfy/id1625396347"
  echo "     - Android: https://play.google.com/store/apps/details?id=io.heckel.ntfy"
  echo ""
  echo "  2. Subscribe to your personal topic:"
  echo -e "     ${GREEN}$topic${NC}"
  echo ""
  echo "  3. Test it:"
  echo -e "     ${CYAN}crab notify \"Hello\" \"Testing from crab!\"${NC}"
  echo ""
  echo -e "${BOLD}Mobile Dashboard${NC}"
  echo ""
  echo "  Start the dashboard server:"
  echo -e "  ${CYAN}crab mobile serve${NC}"
  echo ""
  echo "  Then open the URL on your phone (same WiFi network)"
  echo ""

  # Show QR code for ntfy topic if qrencode is available
  if command_exists qrencode; then
    echo -e "${BOLD}Scan to subscribe:${NC}"
    qrencode -t ANSI "ntfy://$topic" 2>/dev/null || true
    echo ""
  fi
}

# Handle mobile commands
handle_mobile_command() {
  case "${1:-}" in
    "setup"|"init")
      mobile_setup
      ;;
    "serve"|"server"|"dashboard")
      start_mobile_server "${2:-8888}"
      ;;
    "notify"|"push")
      shift
      crab_notify "$@"
      ;;
    "topic")
      mobile_init
      echo "Your ntfy topic: $(mobile_get_topic)"
      echo "Subscribe URL: https://ntfy.sh/$(mobile_get_topic)"
      ;;
    "status")
      show_status "${2:-terminal}"
      ;;
    *)
      echo -e "${CYAN}Mobile Companion Commands:${NC}"
      echo ""
      echo "  crab mobile setup       Setup push notifications"
      echo "  crab mobile serve       Start mobile dashboard (default: port 8888)"
      echo "  crab mobile serve 9999  Start on custom port"
      echo "  crab mobile notify \"Title\" \"Message\""
      echo "  crab mobile topic       Show your ntfy topic"
      echo "  crab mobile status      Show status"
      echo "  crab mobile status --json  JSON output for API"
      echo ""
      ;;
  esac
}

# =============================================================================
# Workspace Handoff - Package and transfer entire context to teammate
# =============================================================================

HANDOFF_DIR="$CONFIG_DIR/handoffs"

# Create a handoff package
create_handoff() {
  local num="$1"
  local recipient="${2:-}"
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist"
    exit 1
  fi

  mkdir -p "$HANDOFF_DIR"

  local timestamp=$(date +%Y%m%d-%H%M%S)
  local handoff_name="handoff-ws$num-$timestamp"
  local handoff_path="$HANDOFF_DIR/$handoff_name"

  mkdir -p "$handoff_path"

  echo -e "${CYAN}Creating handoff package for workspace $num...${NC}"
  echo ""

  cd "$dir"

  # 1. Save git state
  echo "  📦 Saving git state..."
  local branch=$(git branch --show-current 2>/dev/null || echo "main")
  local commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
  local diff=$(git diff HEAD 2>/dev/null || echo "")
  local staged=$(git diff --cached HEAD 2>/dev/null || echo "")
  local status=$(git status --porcelain 2>/dev/null || echo "")
  local log=$(git log --oneline -20 origin/main..HEAD 2>/dev/null || echo "")

  echo "$branch" > "$handoff_path/branch.txt"
  echo "$commit" > "$handoff_path/commit.txt"
  [ -n "$diff" ] && echo "$diff" > "$handoff_path/unstaged.patch"
  [ -n "$staged" ] && echo "$staged" > "$handoff_path/staged.patch"
  [ -n "$status" ] && echo "$status" > "$handoff_path/status.txt"
  [ -n "$log" ] && echo "$log" > "$handoff_path/commits.txt"

  # 2. Save terminal history (last 100 commands from this session)
  echo "  📜 Saving terminal history..."
  if [ -n "$TMUX" ]; then
    local window_name="ws$num"
    # Capture pane content
    tmux capture-pane -t "$SESSION_NAME:$window_name.0" -p -S -100 2>/dev/null > "$handoff_path/terminal-history.txt" || true
    tmux capture-pane -t "$SESSION_NAME:$window_name.1" -p -S -100 2>/dev/null > "$handoff_path/server-output.txt" || true
    tmux capture-pane -t "$SESSION_NAME:$window_name.2" -p -S -100 2>/dev/null > "$handoff_path/main-output.txt" || true
  fi

  # 3. Save Claude conversation if available
  echo "  🤖 Looking for Claude context..."
  local claude_history="$HOME/.claude/projects"
  if [ -d "$claude_history" ]; then
    # Find recent conversation files
    local project_dir=$(find "$claude_history" -type d -name "*$(basename "$dir")*" 2>/dev/null | head -1)
    if [ -n "$project_dir" ] && [ -d "$project_dir" ]; then
      # Copy recent conversation (last file)
      local recent_conv=$(ls -t "$project_dir"/*.jsonl 2>/dev/null | head -1)
      if [ -n "$recent_conv" ] && [ -f "$recent_conv" ]; then
        cp "$recent_conv" "$handoff_path/claude-conversation.jsonl"
        echo "    Found Claude conversation"
      fi
    fi
  fi

  # 4. Save environment hints
  echo "  ⚙️  Saving environment info..."
  cat > "$handoff_path/environment.json" << EOF
{
  "workspace": $num,
  "branch": "$branch",
  "created_at": "$(date -Iseconds)",
  "created_by": "$(git config user.name 2>/dev/null || echo "$USER")",
  "recipient": "$recipient",
  "node_version": "$(node --version 2>/dev/null || echo 'unknown')",
  "working_directory": "$dir"
}
EOF

  # 5. Create summary
  echo "  📝 Generating summary..."
  local file_count=$(echo "$status" | grep -c "^" 2>/dev/null || echo "0")
  local commit_count=$(echo "$log" | grep -c "^" 2>/dev/null || echo "0")

  cat > "$handoff_path/README.md" << EOF
# Workspace Handoff: ws-$num

**Created by:** $(git config user.name 2>/dev/null || echo "$USER")
**Date:** $(date)
**Branch:** $branch

## Summary
- $file_count uncommitted changes
- $commit_count commits ahead of main

## To receive this handoff:
\`\`\`bash
crab receive $handoff_name
# or
crab receive $handoff_name --to <workspace-number>
\`\`\`

## Contents
- \`branch.txt\` - Current branch name
- \`commit.txt\` - Current commit hash
- \`unstaged.patch\` - Uncommitted changes
- \`staged.patch\` - Staged changes
- \`commits.txt\` - Commit history
- \`terminal-history.txt\` - Terminal pane history
- \`server-output.txt\` - Server pane output
- \`main-output.txt\` - Main pane output
- \`claude-conversation.jsonl\` - Claude Code context (if available)
EOF

  # 6. Create archive
  echo "  📦 Creating archive..."
  local archive_path="$HANDOFF_DIR/$handoff_name.tar.gz"
  tar -czf "$archive_path" -C "$HANDOFF_DIR" "$handoff_name"

  # Calculate size
  local size=$(du -h "$archive_path" | cut -f1)

  echo ""
  success "Handoff package created!"
  echo ""
  echo -e "  ${BOLD}Package:${NC} $handoff_name"
  echo -e "  ${BOLD}Size:${NC} $size"
  echo -e "  ${BOLD}Location:${NC} $archive_path"
  echo ""

  # 7. Share options
  if [ -n "$recipient" ]; then
    echo -e "${CYAN}Share with $recipient:${NC}"
    echo ""

    # Check if it's a Slack user
    if [[ "$recipient" == @* ]]; then
      echo "  Slack: crab slack $recipient \"Handoff ready: $handoff_name\""
      echo "         crab tk share $archive_path --to slack:$recipient"
    else
      echo "  Upload: crab tk share $archive_path"
      echo "  SSH:    crab tk share $archive_path --to ssh:$recipient"
    fi
    echo ""
  fi

  echo -e "${GRAY}Recipient runs: crab receive $handoff_name${NC}"

  # Cleanup temp directory
  rm -rf "$handoff_path"
}

# Receive and apply a handoff package
receive_handoff() {
  local handoff_name="$1"
  local target_ws="${2:-}"

  # Find the handoff archive
  local archive_path=""
  if [ -f "$handoff_name" ]; then
    archive_path="$handoff_name"
  elif [ -f "$HANDOFF_DIR/$handoff_name.tar.gz" ]; then
    archive_path="$HANDOFF_DIR/$handoff_name.tar.gz"
  elif [ -f "$HANDOFF_DIR/$handoff_name" ]; then
    archive_path="$HANDOFF_DIR/$handoff_name"
  else
    error "Handoff package not found: $handoff_name"
    echo ""
    echo "Looking in: $HANDOFF_DIR"
    echo ""
    echo "Available handoffs:"
    ls -1 "$HANDOFF_DIR"/*.tar.gz 2>/dev/null | while read f; do
      echo "  $(basename "$f" .tar.gz)"
    done
    exit 1
  fi

  echo -e "${CYAN}Receiving handoff package...${NC}"
  echo ""

  # Extract to temp directory
  local tmp_dir="/tmp/crab-handoff-$$"
  mkdir -p "$tmp_dir"
  tar -xzf "$archive_path" -C "$tmp_dir"

  # Find the handoff directory inside
  local handoff_dir=$(ls -d "$tmp_dir"/*/ 2>/dev/null | head -1)
  if [ -z "$handoff_dir" ]; then
    error "Invalid handoff package"
    rm -rf "$tmp_dir"
    exit 1
  fi

  # Read metadata
  local original_ws=$(jq -r ".workspace // 1" "$handoff_dir/environment.json" 2>/dev/null || echo "1")
  local branch=$(cat "$handoff_dir/branch.txt" 2>/dev/null || echo "main")
  local created_by=$(jq -r ".created_by // \"unknown\"" "$handoff_dir/environment.json" 2>/dev/null || echo "unknown")

  echo -e "  ${BOLD}From:${NC} $created_by"
  echo -e "  ${BOLD}Original workspace:${NC} $original_ws"
  echo -e "  ${BOLD}Branch:${NC} $branch"
  echo ""

  # Determine target workspace
  if [ -z "$target_ws" ]; then
    target_ws="$original_ws"
  fi

  local target_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$target_ws"

  # Create workspace if needed
  if [ ! -d "$target_dir" ]; then
    echo "  Creating workspace $target_ws..."
    create_workspace "$target_ws"
  fi

  cd "$target_dir"

  # Apply git state
  echo "  📦 Applying git state..."
  git fetch origin 2>/dev/null || true

  # Checkout the branch
  if [ "$branch" != "main" ]; then
    git checkout -B "$branch" 2>/dev/null || git checkout "$branch" 2>/dev/null || true
  fi

  # Cherry-pick commits if we have them
  if [ -f "$handoff_dir/commits.txt" ]; then
    local commit_count=$(wc -l < "$handoff_dir/commits.txt" | tr -d ' ')
    if [ "$commit_count" -gt 0 ]; then
      echo "    Found $commit_count commits to apply"
      # Read commit hashes and cherry-pick
      local base_commit=$(cat "$handoff_dir/commit.txt" 2>/dev/null)
      if [ -n "$base_commit" ] && git cat-file -t "$base_commit" >/dev/null 2>&1; then
        echo "    Cherry-picking from handoff..."
        while read -r commit_line; do
          local commit_hash=$(echo "$commit_line" | awk '{print $1}')
          git cherry-pick "$commit_hash" 2>/dev/null || true
        done < <(tac "$handoff_dir/commits.txt")
      fi
    fi
  fi

  # Apply patches
  if [ -f "$handoff_dir/staged.patch" ] && [ -s "$handoff_dir/staged.patch" ]; then
    echo "    Applying staged changes..."
    git apply --index "$handoff_dir/staged.patch" 2>/dev/null || true
  fi

  if [ -f "$handoff_dir/unstaged.patch" ] && [ -s "$handoff_dir/unstaged.patch" ]; then
    echo "    Applying unstaged changes..."
    git apply "$handoff_dir/unstaged.patch" 2>/dev/null || true
  fi

  # Copy Claude conversation if available
  if [ -f "$handoff_dir/claude-conversation.jsonl" ]; then
    echo "  🤖 Restoring Claude context..."
    local claude_project_dir="$HOME/.claude/projects/-$(echo "$target_dir" | tr '/' '-')"
    mkdir -p "$claude_project_dir"
    cp "$handoff_dir/claude-conversation.jsonl" "$claude_project_dir/handoff-$(date +%s).jsonl"
    echo "    Claude conversation saved (use --continue to resume)"
  fi

  # Show terminal history context
  if [ -f "$handoff_dir/terminal-history.txt" ]; then
    echo "  📜 Terminal context available"
  fi

  echo ""
  success "Handoff received to workspace $target_ws!"
  echo ""
  echo "  Next steps:"
  echo "    crab ws $target_ws              Open the workspace"
  echo "    crab ws $target_ws continue     Open with Claude --continue"
  echo ""

  # Show README
  if [ -f "$handoff_dir/README.md" ]; then
    echo -e "${GRAY}--- Handoff Notes ---${NC}"
    cat "$handoff_dir/README.md" | head -20
    echo -e "${GRAY}---${NC}"
  fi

  # Cleanup
  rm -rf "$tmp_dir"
}

# List available handoffs
list_handoffs() {
  echo -e "${CYAN}Available Handoffs:${NC}"
  echo ""

  if [ ! -d "$HANDOFF_DIR" ] || [ -z "$(ls -A "$HANDOFF_DIR" 2>/dev/null)" ]; then
    echo "  No handoffs found."
    echo ""
    echo "  Create one with: crab handoff [workspace-number] [@recipient]"
    return
  fi

  local count=0
  for archive in "$HANDOFF_DIR"/*.tar.gz; do
    [ -f "$archive" ] || continue
    count=$((count + 1))

    local name=$(basename "$archive" .tar.gz)
    local size=$(du -h "$archive" | cut -f1)
    local date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$archive" 2>/dev/null || stat -c "%y" "$archive" 2>/dev/null | cut -d' ' -f1-2)

    echo -e "  ${BOLD}$count.${NC} $name"
    echo -e "     Size: $size | Created: $date"
    echo ""
  done
}

# Handle handoff commands
handle_handoff_command() {
  load_config
  validate_config

  case "${1:-}" in
    "ls"|"list")
      list_handoffs
      ;;
    "receive"|"apply")
      if [ -z "${2:-}" ]; then
        error "Usage: crab handoff receive <handoff-name> [--to <workspace>]"
        exit 1
      fi
      local handoff_name="$2"
      local target_ws=""
      if [ "${3:-}" = "--to" ]; then
        target_ws="${4:-}"
      fi
      receive_handoff "$handoff_name" "$target_ws"
      ;;
    "")
      # Auto-detect workspace and create handoff
      local num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Not in a workspace. Use: crab handoff <workspace-number>"
        exit 1
      fi
      create_handoff "$num"
      ;;
    *)
      # First arg might be workspace number or recipient
      if [[ "$1" =~ ^[0-9]+$ ]]; then
        create_handoff "$1" "${2:-}"
      elif [[ "$1" == @* ]]; then
        # Recipient specified, auto-detect workspace
        local num=$(detect_workspace)
        if [ -z "$num" ]; then
          error "Not in a workspace. Use: crab handoff <workspace-number> $1"
          exit 1
        fi
        create_handoff "$num" "$1"
      else
        error "Unknown handoff command: $1"
        echo ""
        echo "Usage:"
        echo "  crab handoff                    Create from current workspace"
        echo "  crab handoff <N>                Create from workspace N"
        echo "  crab handoff <N> @recipient     Create and note recipient"
        echo "  crab handoff ls                 List available handoffs"
        echo "  crab handoff receive <name>     Apply a handoff"
        echo "  crab handoff receive <name> --to <N>  Apply to specific workspace"
        exit 1
      fi
      ;;
  esac
}

# =============================================================================
# Time Travel - Automatic snapshots and workspace rewind
# =============================================================================

SNAPSHOT_DIR="$CONFIG_DIR/snapshots"
SNAPSHOT_INTERVAL="${CRAB_SNAPSHOT_INTERVAL:-900}"  # Default: 15 minutes

# Create a snapshot of workspace state
create_snapshot() {
  local num="$1"
  local label="${2:-auto}"
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"

  if [ ! -d "$dir" ]; then
    return 1
  fi

  mkdir -p "$SNAPSHOT_DIR/ws-$num"

  local timestamp=$(date +%s)
  local snapshot_name="$timestamp-$label"
  local snapshot_path="$SNAPSHOT_DIR/ws-$num/$snapshot_name"

  mkdir -p "$snapshot_path"

  cd "$dir"

  # Save git state
  local branch=$(git branch --show-current 2>/dev/null || echo "main")
  local commit=$(git rev-parse HEAD 2>/dev/null || echo "")
  local diff=$(git diff HEAD 2>/dev/null || echo "")
  local staged=$(git diff --cached HEAD 2>/dev/null || echo "")
  local stash_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')

  echo "$branch" > "$snapshot_path/branch"
  echo "$commit" > "$snapshot_path/commit"
  [ -n "$diff" ] && echo "$diff" > "$snapshot_path/unstaged.patch"
  [ -n "$staged" ] && echo "$staged" > "$snapshot_path/staged.patch"

  # Save metadata
  cat > "$snapshot_path/metadata.json" << EOF
{
  "timestamp": $timestamp,
  "label": "$label",
  "branch": "$branch",
  "commit": "$commit",
  "has_unstaged": $([ -n "$diff" ] && echo "true" || echo "false"),
  "has_staged": $([ -n "$staged" ] && echo "true" || echo "false"),
  "stash_count": $stash_count,
  "created_at": "$(date -Iseconds)"
}
EOF

  # Prune old snapshots (keep last 50)
  local snapshot_count=$(ls -1d "$SNAPSHOT_DIR/ws-$num"/*/ 2>/dev/null | wc -l | tr -d ' ')
  if [ "$snapshot_count" -gt 50 ]; then
    ls -1d "$SNAPSHOT_DIR/ws-$num"/*/ 2>/dev/null | head -n -50 | xargs rm -rf 2>/dev/null || true
  fi

  echo "$snapshot_name"
}

# Manual snapshot with label
save_snapshot() {
  local num="$1"
  local label="${2:-manual}"

  echo -e "${CYAN}Creating snapshot...${NC}"
  local snapshot_name=$(create_snapshot "$num" "$label")

  if [ -n "$snapshot_name" ]; then
    success "Snapshot saved: $label"
    echo -e "  ${GRAY}Restore with: crab rewind $num $snapshot_name${NC}"
  else
    error "Failed to create snapshot"
  fi
}

# List snapshots for a workspace
list_snapshots() {
  local num="$1"
  local limit="${2:-20}"
  local snapshot_base="$SNAPSHOT_DIR/ws-$num"

  if [ ! -d "$snapshot_base" ]; then
    echo -e "${YELLOW}No snapshots for workspace $num${NC}"
    return
  fi

  echo -e "${CYAN}╭────────────────────────────────────────────────────╮${NC}"
  echo -e "${CYAN}│${NC}         ${BOLD}🕐 Time Travel - Workspace $num${NC}              ${CYAN}│${NC}"
  echo -e "${CYAN}╰────────────────────────────────────────────────────╯${NC}"
  echo ""

  local count=0
  for snapshot_dir in $(ls -1dr "$snapshot_base"/*/ 2>/dev/null); do
    [ -d "$snapshot_dir" ] || continue
    count=$((count + 1))
    [ $count -gt $limit ] && break

    local snapshot_name=$(basename "$snapshot_dir")
    local timestamp=$(echo "$snapshot_name" | cut -d'-' -f1)
    local label=$(echo "$snapshot_name" | cut -d'-' -f2-)

    # Format time relative to now
    local now=$(date +%s)
    local diff=$((now - timestamp))
    local time_ago=""

    if [ $diff -lt 60 ]; then
      time_ago="${diff}s ago"
    elif [ $diff -lt 3600 ]; then
      time_ago="$((diff / 60))m ago"
    elif [ $diff -lt 86400 ]; then
      time_ago="$((diff / 3600))h ago"
    else
      time_ago="$((diff / 86400))d ago"
    fi

    # Read metadata
    local branch=""
    local has_changes="clean"
    if [ -f "$snapshot_dir/metadata.json" ] && command_exists jq; then
      branch=$(jq -r ".branch // \"\"" "$snapshot_dir/metadata.json" 2>/dev/null)
      local has_unstaged=$(jq -r ".has_unstaged // false" "$snapshot_dir/metadata.json" 2>/dev/null)
      local has_staged=$(jq -r ".has_staged // false" "$snapshot_dir/metadata.json" 2>/dev/null)
      [ "$has_unstaged" = "true" ] || [ "$has_staged" = "true" ] && has_changes="changes"
    else
      [ -f "$snapshot_dir/branch" ] && branch=$(cat "$snapshot_dir/branch")
      [ -f "$snapshot_dir/unstaged.patch" ] || [ -f "$snapshot_dir/staged.patch" ] && has_changes="changes"
    fi

    local status_icon="✓"
    local status_color="${GREEN}"
    if [ "$has_changes" = "changes" ]; then
      status_icon="●"
      status_color="${YELLOW}"
    fi

    printf "  ${BOLD}%2d.${NC} %-12s ${GRAY}%-10s${NC} ${status_color}%s${NC} %s\n" \
      "$count" "$time_ago" "$label" "$status_icon" "$branch"
  done

  echo ""
  echo -e "${GRAY}Usage: crab rewind $num <N>  (restore snapshot #N)${NC}"
  echo -e "${GRAY}       crab rewind $num 1h   (restore from ~1 hour ago)${NC}"
  echo ""
}

# Rewind to a specific snapshot
rewind_to_snapshot() {
  local num="$1"
  local target="$2"
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local snapshot_base="$SNAPSHOT_DIR/ws-$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist"
    exit 1
  fi

  if [ ! -d "$snapshot_base" ]; then
    error "No snapshots for workspace $num"
    exit 1
  fi

  local snapshot_dir=""

  # Handle different target formats
  if [[ "$target" =~ ^[0-9]+$ ]]; then
    # Target is a snapshot number (1, 2, 3...)
    snapshot_dir=$(ls -1dr "$snapshot_base"/*/ 2>/dev/null | sed -n "${target}p")
  elif [[ "$target" =~ ^[0-9]+[mhd]$ ]]; then
    # Target is a time offset (30m, 2h, 1d)
    local amount=${target%?}
    local unit=${target: -1}
    local seconds=0

    case "$unit" in
      "m") seconds=$((amount * 60)) ;;
      "h") seconds=$((amount * 3600)) ;;
      "d") seconds=$((amount * 86400)) ;;
    esac

    local target_time=$(($(date +%s) - seconds))

    # Find snapshot closest to target time
    for sdir in $(ls -1dr "$snapshot_base"/*/ 2>/dev/null); do
      local snap_time=$(basename "$sdir" | cut -d'-' -f1)
      if [ "$snap_time" -le "$target_time" ]; then
        snapshot_dir="$sdir"
        break
      fi
    done
  else
    # Target is a snapshot name
    snapshot_dir="$snapshot_base/$target"
  fi

  if [ -z "$snapshot_dir" ] || [ ! -d "$snapshot_dir" ]; then
    error "Snapshot not found: $target"
    echo ""
    echo "Use 'crab rewind $num' to see available snapshots"
    exit 1
  fi

  local snapshot_name=$(basename "$snapshot_dir")
  local timestamp=$(echo "$snapshot_name" | cut -d'-' -f1)
  local label=$(echo "$snapshot_name" | cut -d'-' -f2-)
  local time_str=$(date -r "$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "unknown")

  echo -e "${CYAN}Rewinding workspace $num to: $label ($time_str)${NC}"
  echo ""

  # First, save current state as a snapshot
  echo "  💾 Saving current state before rewind..."
  create_snapshot "$num" "pre-rewind" >/dev/null

  cd "$dir"

  # Restore branch
  if [ -f "$snapshot_dir/branch" ]; then
    local branch=$(cat "$snapshot_dir/branch")
    echo "  🔀 Switching to branch: $branch"
    git checkout "$branch" 2>/dev/null || git checkout -b "$branch" 2>/dev/null || true
  fi

  # Restore commit
  if [ -f "$snapshot_dir/commit" ]; then
    local commit=$(cat "$snapshot_dir/commit")
    echo "  📌 Resetting to commit: ${commit:0:8}"
    git reset --hard "$commit" 2>/dev/null || true
  fi

  # Apply patches
  if [ -f "$snapshot_dir/staged.patch" ] && [ -s "$snapshot_dir/staged.patch" ]; then
    echo "  📄 Applying staged changes..."
    git apply --index "$snapshot_dir/staged.patch" 2>/dev/null || true
  fi

  if [ -f "$snapshot_dir/unstaged.patch" ] && [ -s "$snapshot_dir/unstaged.patch" ]; then
    echo "  📄 Applying unstaged changes..."
    git apply "$snapshot_dir/unstaged.patch" 2>/dev/null || true
  fi

  echo ""
  success "Rewound to: $label"
  echo ""
  echo -e "  ${GRAY}Pre-rewind state saved. Undo with: crab rewind $num 1${NC}"
}

# Auto-snapshot daemon (background)
start_snapshot_daemon() {
  local num="$1"
  local interval="${2:-$SNAPSHOT_INTERVAL}"

  echo -e "${CYAN}Starting snapshot daemon for workspace $num...${NC}"
  echo "  Interval: ${interval}s"
  echo ""

  while true; do
    create_snapshot "$num" "auto" >/dev/null 2>&1
    sleep "$interval"
  done
}

# Handle time travel commands
handle_rewind_command() {
  load_config
  validate_config

  local num="${1:-}"

  # Auto-detect workspace if not specified
  if [ -z "$num" ] || ! [[ "$num" =~ ^[0-9]+$ ]]; then
    num=$(detect_workspace)
    if [ -z "$num" ]; then
      error "Specify workspace number: crab rewind <N>"
      exit 1
    fi
    # First arg might be the target, shift it
    if [ -n "$1" ] && ! [[ "$1" =~ ^[0-9]+$ ]]; then
      set -- "$num" "$@"
    fi
  fi

  local action="${2:-}"

  case "$action" in
    "")
      list_snapshots "$num"
      ;;
    "save"|"snapshot")
      save_snapshot "$num" "${3:-manual}"
      ;;
    "daemon"|"auto")
      start_snapshot_daemon "$num" "${3:-$SNAPSHOT_INTERVAL}"
      ;;
    *)
      rewind_to_snapshot "$num" "$action"
      ;;
  esac
}

# =============================================================================
# Live Pairing - Real-time session sharing with teammates
# =============================================================================

PAIR_SOCKET_DIR="$CONFIG_DIR/pair"

# Start a pairing session (host)
start_pair_session() {
  local num="$1"
  local mode="${2:-pair}"  # pair or spectate

  mkdir -p "$PAIR_SOCKET_DIR"

  local socket_name="crab-pair-$num"
  local socket_path="$PAIR_SOCKET_DIR/$socket_name"

  # Check if session already exists
  if [ -S "$socket_path" ]; then
    echo -e "${YELLOW}Pairing session already active for workspace $num${NC}"
    echo ""
    echo "Share this command with your teammate:"
    echo -e "  ${GREEN}crab join $num${NC}"
    echo ""
    echo "Or for spectate-only mode:"
    echo -e "  ${GREEN}crab spectate $num${NC}"
    return
  fi

  echo -e "${CYAN}╭────────────────────────────────────────────────────╮${NC}"
  echo -e "${CYAN}│${NC}       ${BOLD}🦀 Live Pairing - Workspace $num${NC}              ${CYAN}│${NC}"
  echo -e "${CYAN}╰────────────────────────────────────────────────────╯${NC}"
  echo ""

  # Create shared tmux session with socket
  local window_name="ws$num"

  if ! tmux -S "$socket_path" has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo "  🔌 Creating shared session..."
    # Create a new session with the socket
    tmux -S "$socket_path" new-session -d -s "$SESSION_NAME" -n "$window_name"

    # Set permissions so others can join
    chmod 777 "$socket_path" 2>/dev/null || true
  fi

  echo ""
  echo -e "${GREEN}✓ Pairing session active!${NC}"
  echo ""
  echo -e "${BOLD}Share with teammates:${NC}"
  echo ""
  echo -e "  ${CYAN}Same machine:${NC}"
  echo "    crab join $num"
  echo "    crab spectate $num     (view only)"
  echo ""
  echo -e "  ${CYAN}Remote (via SSH):${NC}"
  echo "    ssh $(whoami)@$(hostname) -t 'crab join $num'"
  echo ""
  echo -e "  ${CYAN}Share via tmate (public URL):${NC}"
  if command_exists tmate; then
    echo "    crab pair $num --tmate"
  else
    echo "    Install tmate: brew install tmate"
  fi
  echo ""

  # Attach to the session
  tmux -S "$socket_path" attach-session -t "$SESSION_NAME"
}

# Join a pairing session
join_pair_session() {
  local num="$1"
  local mode="${2:-pair}"  # pair or spectate

  local socket_name="crab-pair-$num"
  local socket_path="$PAIR_SOCKET_DIR/$socket_name"

  if [ ! -S "$socket_path" ]; then
    error "No active pairing session for workspace $num"
    echo ""
    echo "Ask the host to start one with: crab pair $num"
    exit 1
  fi

  echo -e "${CYAN}Joining workspace $num...${NC}"

  if [ "$mode" = "spectate" ]; then
    echo -e "${YELLOW}Spectate mode: view only, no input${NC}"
    tmux -S "$socket_path" attach-session -t "$SESSION_NAME" -r
  else
    tmux -S "$socket_path" attach-session -t "$SESSION_NAME"
  fi
}

# Start tmate session for public sharing
start_tmate_session() {
  local num="$1"

  if ! command_exists tmate; then
    error "tmate is not installed"
    echo ""
    echo "Install with: brew install tmate"
    exit 1
  fi

  echo -e "${CYAN}╭────────────────────────────────────────────────────╮${NC}"
  echo -e "${CYAN}│${NC}     ${BOLD}🦀 Live Pairing via tmate - Workspace $num${NC}     ${CYAN}│${NC}"
  echo -e "${CYAN}╰────────────────────────────────────────────────────╯${NC}"
  echo ""
  echo "  Starting tmate session..."
  echo ""

  # Start tmate
  tmate -F -v -S "/tmp/tmate-crab-$num.sock" new-session -d -s "crab-$num" 2>/dev/null &
  local tmate_pid=$!

  sleep 2

  # Get connection info
  local ssh_url=$(tmate -S "/tmp/tmate-crab-$num.sock" display -p '#{tmate_ssh}' 2>/dev/null)
  local web_url=$(tmate -S "/tmp/tmate-crab-$num.sock" display -p '#{tmate_web}' 2>/dev/null)
  local ssh_ro_url=$(tmate -S "/tmp/tmate-crab-$num.sock" display -p '#{tmate_ssh_ro}' 2>/dev/null)
  local web_ro_url=$(tmate -S "/tmp/tmate-crab-$num.sock" display -p '#{tmate_web_ro}' 2>/dev/null)

  echo -e "${GREEN}✓ tmate session ready!${NC}"
  echo ""
  echo -e "${BOLD}Share these links with your teammate:${NC}"
  echo ""
  echo -e "  ${CYAN}Full access (pair):${NC}"
  [ -n "$ssh_url" ] && echo "    SSH: $ssh_url"
  [ -n "$web_url" ] && echo "    Web: $web_url"
  echo ""
  echo -e "  ${CYAN}View only (spectate):${NC}"
  [ -n "$ssh_ro_url" ] && echo "    SSH: $ssh_ro_url"
  [ -n "$web_ro_url" ] && echo "    Web: $web_ro_url"
  echo ""

  # Attach
  tmate -S "/tmp/tmate-crab-$num.sock" attach-session -t "crab-$num"
}

# List active pairing sessions
list_pair_sessions() {
  echo -e "${CYAN}Active Pairing Sessions:${NC}"
  echo ""

  local found=false
  for socket in "$PAIR_SOCKET_DIR"/crab-pair-*; do
    [ -S "$socket" ] || continue
    found=true

    local num=$(basename "$socket" | sed 's/crab-pair-//')
    local clients=$(tmux -S "$socket" list-clients 2>/dev/null | wc -l | tr -d ' ')

    echo -e "  ${BOLD}Workspace $num${NC} - $clients connected"
    echo "    Join: crab join $num"
    echo "    Spectate: crab spectate $num"
    echo ""
  done

  if [ "$found" = false ]; then
    echo "  No active sessions."
    echo ""
    echo "  Start one with: crab pair <workspace-number>"
  fi
}

# End a pairing session
end_pair_session() {
  local num="$1"
  local socket_path="$PAIR_SOCKET_DIR/crab-pair-$num"

  if [ ! -S "$socket_path" ]; then
    echo "No active session for workspace $num"
    return
  fi

  echo -e "${YELLOW}Ending pairing session for workspace $num...${NC}"
  tmux -S "$socket_path" kill-session -t "$SESSION_NAME" 2>/dev/null || true
  rm -f "$socket_path"
  success "Session ended"
}

# Handle pair commands
handle_pair_command() {
  load_config 2>/dev/null || true

  case "${1:-}" in
    "ls"|"list")
      list_pair_sessions
      ;;
    "end"|"stop")
      if [ -z "${2:-}" ]; then
        error "Usage: crab pair end <workspace-number>"
        exit 1
      fi
      end_pair_session "$2"
      ;;
    "")
      # Auto-detect workspace
      load_config
      validate_config
      local num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Specify workspace: crab pair <N>"
        exit 1
      fi
      start_pair_session "$num"
      ;;
    *)
      if [[ "$1" =~ ^[0-9]+$ ]]; then
        local num="$1"
        if [ "${2:-}" = "--tmate" ]; then
          start_tmate_session "$num"
        else
          start_pair_session "$num"
        fi
      else
        error "Unknown pair command: $1"
        echo ""
        echo "Usage:"
        echo "  crab pair <N>            Start pairing session"
        echo "  crab pair <N> --tmate    Start with public tmate URLs"
        echo "  crab join <N>            Join a pairing session"
        echo "  crab spectate <N>        Join as spectator (view only)"
        echo "  crab pair ls             List active sessions"
        echo "  crab pair end <N>        End a session"
        exit 1
      fi
      ;;
  esac
}

# =============================================================================
# Help / Cheat Sheet
# =============================================================================

# Show shared volume info
show_shared() {
  load_config

  if [ "$SHARED_VOLUME_ENABLED" != "true" ]; then
    echo -e "${YELLOW}Shared volume is disabled.${NC}"
    echo ""
    echo "To enable, add to your config:"
    echo "  shared_volume:"
    echo "    enabled: true"
    return
  fi

  echo -e "${CYAN}Shared Volume${NC}"
  echo ""
  echo -e "  Path: ${GREEN}$SHARED_VOLUME_PATH${NC}"
  echo -e "  Link name: $SHARED_VOLUME_LINK"
  echo ""

  if [ -d "$SHARED_VOLUME_PATH" ]; then
    local count=$(ls -1 "$SHARED_VOLUME_PATH" 2>/dev/null | wc -l | tr -d ' ')
    echo "  Contents ($count items):"
    ls -la "$SHARED_VOLUME_PATH" 2>/dev/null | tail -n +2 | while read -r line; do
      echo "    $line"
    done
  else
    echo -e "  ${YELLOW}Not yet created (will be created on first workspace open)${NC}"
  fi
}

show_cheat() {
  cat << 'EOF'
╔═══════════════════════════════════════════════════════════════════════════════╗
║                                                                               ║
║      \___/                                                                    ║
║     ( •_•)         CRABCODE CHEAT SHEET                                       ║
║    /)🦀(\          Workspace manager for multi-repo development               ║
║   <      >                                                                    ║
║                    Tip: Use 'crab' as shorthand for 'crabcode'                ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  MULTI-PROJECT (crab @alias ...)                                             ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab init              Register a new project (asks for alias)               ║
║  crab init -t <tpl>     Register with template (e.g., promptfoo-cloud)        ║
║  crab @pf ws 1          Open workspace 1 for project "pf"                    ║
║  crab @cb config        Show config for project "cb"                          ║
║  crab ws 1              Uses default project (or detects from cwd)            ║
║  crab projects          List all registered projects                          ║
║  crab projects rm <a>   Remove a project registration                         ║
║  crab default pf        Set default project                                   ║
║  crab default           Show current default                                  ║
║                                                                               ║
║  Config: ~/.crabcode/projects/<alias>.yaml                                   ║
║  Auto-detect: crab figures out which project from your cwd                    ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  WORKSPACE COMMANDS (crab ws ...)                                             ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab ws               Interactive menu (list + actions)                      ║
║  crab ws ls            List workspaces (non-interactive)                      ║
║  crab ws new           Create next available workspace                        ║
║  crab ws <N>           Open/create workspace N                                ║
║  crab ws <N> --separate   Open in new terminal window                         ║
║  crab ws <N> restart   Reset git + restart panes (recreates full layout)      ║
║  crab ws <N> cleanup   Kill window + reset to origin/main                     ║
║  crab ws <N> destroy   Completely remove workspace (worktree + files)         ║
║  crab destroy <N>      Shorthand for above                                    ║
║  crab ws <N> continue  Resume with --continue flag                            ║
║                                                                               ║
║  SHORTCUTS (auto-detect workspace from cwd or tmux window)                    ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab restart          Restart current workspace                              ║
║  crab cleanup          Cleanup current workspace                              ║
║  crab continue         Continue current workspace                             ║
║  crab <N>              Shorthand for: crab ws <N>                             ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  SESSION COMMANDS (crab session ...)                                          ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab session ls           List sessions with summaries                       ║
║  crab session start "name" Start new named session                            ║
║  crab session resume "name" Resume existing session                           ║
║  crab session delete "name" Delete a session                                  ║
║  crab session summary "name" "text"  Update session summary                   ║
║                                                                               ║
║  REVIEW COMMANDS (crab review ...)                                            ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab review <PR>          Quick review (number, repo#num, or URL)            ║
║  crab review new           Interactive mode (multiple PRs + context)          ║
║  crab review ls            List review sessions                               ║
║  crab review resume <PR>   Resume a review session                            ║
║                                                                               ║
║  PR formats: 3230, promptfoo#456, https://github.com/.../pull/123            ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  WIP COMMANDS (crab wip ...)                                                  ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab wip save              Save current changes (branch, commits, patches)   ║
║  crab wip save --restart    Save then restart workspace                       ║
║  crab wip ls                List all WIPs globally with metadata              ║
║  crab wip restore           Interactive restore from all WIPs                 ║
║  crab wip restore <N>       Restore WIP #N to original workspace              ║
║  crab wip restore <N> --to <ws>  Restore to different workspace               ║
║  crab wip restore <N> --open     Restore and open workspace with claude       ║
║  crab wip --continue        Restore most recent WIP (current workspace)       ║
║  crab wip delete <name>     Delete a saved WIP state                          ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  TOOLKIT COMMANDS (crab tk ...)                                               ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab tk share <path>              Upload → temp URL (transfer.sh)            ║
║  crab tk share <path> --to ssh:... Transfer via SSH/rsync                     ║
║  crab tk share <path> --to slack:# Upload to Slack channel                    ║
║  crab tk share <path> --to email:@ Send via email                             ║
║  crab tk share <path> --serve      Start local HTTP server + QR code          ║
║  crab tk share <path> --zip        Just create local archive                  ║
║                                                                               ║
║  Options: --include-git, --include-deps, --port=8080                          ║
║  Auto-excludes: node_modules, .git, vendor, venv, dist, build...              ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  SLACK COMMANDS (crab slack ...)                                              ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab slack @user "msg"       Send DM to a user                               ║
║  crab slack #channel "msg"    Post to a channel                               ║
║  crab slack read @user        Show recent DMs with user                       ║
║  crab slack chat @user        Interactive terminal chat                       ║
║  crab slack sent              View your sent messages log                     ║
║  crab slack users             List all workspace users                        ║
║  crab slack users mike        Search users by name                            ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  OTHER COMMANDS                                                               ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab config scan      Auto-detect .env files and ports                       ║
║  crab config           Show current configuration                             ║
║  crab doctor           Diagnose common issues                                 ║
║  crab ports            Show port usage across workspaces                      ║
║  crab shared           Show shared volume info                                ║
║  crab mood             Show your crab's current mood 🦀                       ║
║  crab status           Show workspace status overview                         ║
║  crab update           Update crabcode to latest version                      ║
║  crab cheat            Show this cheat sheet                                  ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  MOBILE COMPANION (crab mobile ...)                                           ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab mobile setup     Setup push notifications (ntfy.sh)                     ║
║  crab mobile serve     Start mobile dashboard on port 8888                    ║
║  crab mobile notify "Title" "Message"   Send push notification                ║
║  crab notify "Title" "Message"          Shorthand for above                   ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  WORKSPACE HANDOFF (crab handoff ...)                                         ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab handoff              Package current workspace for teammate             ║
║  crab handoff <N>          Package workspace N                                ║
║  crab handoff <N> @mike    Package with recipient noted                       ║
║  crab handoff ls           List available handoff packages                    ║
║  crab receive <name>       Apply a handoff to original workspace              ║
║  crab receive <name> --to <N>   Apply to different workspace                  ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  TIME TRAVEL (crab rewind ...)                                                ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab rewind <N>           List snapshots for workspace N                     ║
║  crab rewind <N> 3         Restore 3rd most recent snapshot                   ║
║  crab rewind <N> 2h        Restore from ~2 hours ago                          ║
║  crab rewind <N> save      Create manual snapshot                             ║
║  crab snapshot             Create snapshot of current workspace               ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  LIVE PAIRING (crab pair ...)                                                 ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab pair <N>             Start pairing session for workspace N              ║
║  crab pair <N> --tmate     Start with public tmate URLs                       ║
║  crab join <N>             Join a pairing session (full access)               ║
║  crab spectate <N>         Join as spectator (view only)                      ║
║  crab pair ls              List active pairing sessions                       ║
║  crab pair end <N>         End a pairing session                              ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  TMUX KEYBINDINGS (Prefix = Ctrl+a)                                           ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  Option+1,2,3...       Switch to workspace 1, 2, 3...                         ║
║  Ctrl+a  n/p           Next/previous window                                   ║
║  Ctrl+a  d             Detach from session                                    ║
║  Ctrl+a  z             Toggle pane zoom                                       ║
║  Option+←/→/↑/↓        Navigate panes                                         ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
EOF
}

show_help() {
  echo '    \___/'
  echo '   ( •_•)  crabcode'
  echo '  /)🦀(\   Workspace manager for multi-repo development'
  echo ' <      >'
  echo "         v$VERSION"
  echo ""
  echo "Usage: crab [command] [arguments]"
  echo "       (crab is an alias for crabcode)"
  echo ""
  echo "Workspace Commands:"
  echo "  ws                List all workspaces"
  echo "  ws new            Create next available workspace"
  echo "  ws <N>            Open/create workspace N"
  echo "  ws <N> restart    Reset git + restart panes (recreates layout)"
  echo "  ws <N> cleanup    Kill window + reset to origin/main"
  echo "  ws <N> continue   Resume with --continue flag"
  echo "  ws <N> --separate Open in new terminal window"
  echo ""
  echo "Shortcuts (auto-detect workspace):"
  echo "  <N>               Shorthand for: ws <N>"
  echo "  restart           Restart current workspace"
  echo "  cleanup           Cleanup current workspace"
  echo "  continue          Continue current workspace"
  echo ""
  echo "Session Commands:"
  echo "  session ls        List sessions with summaries"
  echo "  session start     Start new named session"
  echo "  session resume    Resume existing session"
  echo "  session delete    Delete a session"
  echo ""
  echo "Review Commands:"
  echo "  review <PR>       Quick review (number, repo#num, or URL)"
  echo "  review new        Interactive (multiple PRs + context)"
  echo "  review ls         List review sessions"
  echo "  review resume     Resume a review"
  echo ""
  echo "WIP Commands:"
  echo "  wip save          Save current changes"
  echo "  wip ls            List all WIPs globally"
  echo "  wip restore       Interactive restore from all WIPs"
  echo "  wip restore <N>   Restore WIP #N"
  echo "  wip restore <N> --to <ws>  Restore to different workspace"
  echo "  wip --continue    Restore most recent WIP (current workspace)"
  echo ""
  echo "Toolkit Commands:"
  echo "  tk share <path>   Share file/folder (temp URL)"
  echo "  tk share --to ssh:user@host   SSH transfer"
  echo "  tk share --to slack:#channel  Slack upload"
  echo "  tk share --serve  Local HTTP server"
  echo ""
  echo "Multi-Project Commands:"
  echo "  @alias <cmd>      Run command against a specific project"
  echo "  projects          List registered projects"
  echo "  default [alias]   Show/set default project"
  echo "  init              Register a new project (asks for alias)"
  echo ""
  echo "Other Commands:"
  echo "  init              Setup config (auto-detects project type)"
  echo "  init -t <name>    Setup with template (e.g., promptfoo-cloud)"
  echo "  init --list-templates  Show available templates"
  echo "  config            Show configuration"
  echo "  config scan       Auto-detect .env files and ports"
  echo "  doctor            Diagnose issues"
  echo "  ports             Show port usage"
  echo "  shared            Show shared volume info"
  echo "  cheat             Show cheat sheet"
  echo ""
  echo "Config: $CONFIG_FILE"
}

# =============================================================================
# Workspace Subcommand Handler
# =============================================================================

handle_ws_command() {
  local arg="${1:-}"
  shift || true

  case "$arg" in
    "")
      interactive_workspace_menu
      ;;
    "ls"|"list")
      list_workspaces
      ;;
    "new"|"create")
      create_new_workspace
      ;;
    *)
      if [[ "$arg" =~ ^[0-9]+$ ]]; then
        local num="$arg"

        case "${1:-}" in
          "cleanup"|"clean")
            cleanup_workspace "$num"
            ;;
          "destroy"|"rm"|"remove")
            destroy_workspace "$num" "${2:-}"
            ;;
          "restart"|"reset"|"refresh")
            restart_workspace "$num"
            ;;
          "continue"|"resume")
            continue_workspace "$num"
            ;;
          "--separate"|"-s"|"separate")
            open_workspace_separate "$num"
            ;;
          "wip")
            handle_wip_for_workspace "$num" "${@:2}"
            ;;
          "")
            open_workspace "$num"
            ;;
          *)
            error "Unknown command: crab ws $num $1"
            echo "Try: crab ws $num restart|cleanup|continue|wip"
            exit 1
            ;;
        esac
      else
        error "Invalid workspace argument: $arg"
        echo "Usage: crab ws <N> or crab ws new"
        exit 1
      fi
      ;;
  esac
}

# Handle WIP commands for a specific workspace
handle_wip_for_workspace() {
  local num=$1
  shift || true

  case "${1:-}" in
    "save")
      shift  # Remove "save"
      local do_restart="false"
      local custom_name=""
      while [ $# -gt 0 ]; do
        case "$1" in
          --restart|-r)
            do_restart="true"
            shift
            ;;
          *)
            custom_name="$1"
            shift
            ;;
        esac
      done
      wip_save "$num" "$do_restart" "$custom_name"
      ;;
    "ls"|"list")
      wip_list "$num"
      ;;
    "--continue"|"-c")
      wip_continue "$num"
      ;;
    "--resume"|"-r"|"resume")
      wip_resume "$num"
      ;;
    "delete"|"rm")
      wip_delete "$num" "${2:-}"
      ;;
    *)
      echo -e "${CYAN}WIP Commands for workspace $num:${NC}"
      echo "  crab ws $num wip save [\"name\"] [--restart]"
      echo "  crab ws $num wip ls"
      echo "  crab ws $num wip --continue"
      echo "  crab ws $num wip --resume"
      echo "  crab ws $num wip delete <name>"
      ;;
  esac
}

# =============================================================================
# Promptfoo Plugin Commands
# =============================================================================

handle_pf_command() {
  local PLUGIN_DIR="$CONFIG_DIR/plugins/promptfoo"

  case "${1:-}" in
    "install")
      pf_install
      ;;
    "uninstall"|"remove")
      pf_uninstall
      ;;
    "update"|"upgrade")
      pf_uninstall
      pf_install
      ;;
    "help"|"-h"|"--help"|"")
      pf_help
      ;;
    *)
      # Check if plugin is installed before running
      if [ ! -d "$PLUGIN_DIR" ] || [ ! -f "$PLUGIN_DIR/dist/cli.js" ]; then
        echo -e "${CYAN}Promptfoo Target Discovery Agent${NC}"
        echo ""
        echo "Plugin not installed. Install with:"
        echo ""
        echo -e "  ${GREEN}crab pf install${NC}"
        echo ""
        return 1
      fi
      # Pass all args to the Node.js CLI
      node "$PLUGIN_DIR/dist/cli.js" "$@"
      ;;
  esac
}

pf_install() {
  local PLUGIN_DIR="$CONFIG_DIR/plugins/promptfoo"
  local REPO_URL="https://github.com/promptfoo/crabcode.git"
  local BRANCH="main"

  echo -e "${CYAN}Installing Promptfoo Target Discovery Agent...${NC}"

  # Check for Node.js
  if ! command_exists node; then
    error "Node.js is required. Install with: brew install node"
    return 1
  fi

  # Create plugins directory
  mkdir -p "$CONFIG_DIR/plugins"

  # Clone just the plugin directory using sparse checkout
  local TEMP_DIR=$(mktemp -d)
  echo "Cloning plugin from $REPO_URL..."

  git clone --depth 1 --branch "$BRANCH" --filter=blob:none --sparse "$REPO_URL" "$TEMP_DIR" 2>/dev/null
  cd "$TEMP_DIR"
  git sparse-checkout set plugins/promptfoo

  # Move to final location
  rm -rf "$PLUGIN_DIR"
  mv plugins/promptfoo "$PLUGIN_DIR"
  cd - >/dev/null
  rm -rf "$TEMP_DIR"

  # Install dependencies and build
  echo "Installing dependencies..."
  cd "$PLUGIN_DIR"
  npm install --silent
  npm run build --silent
  cd - >/dev/null

  success "✓ Installed to $PLUGIN_DIR"
  echo ""
  echo "Usage:"
  echo -e "  ${GREEN}crab pf --file target.txt${NC}           # Analyze from file"
  echo -e "  ${GREEN}crab pf \"curl http://...\"${NC}           # Analyze curl command"
  echo -e "  ${GREEN}crab pf --help${NC}                      # Show all options"
}

pf_uninstall() {
  local PLUGIN_DIR="$CONFIG_DIR/plugins/promptfoo"

  if [ -d "$PLUGIN_DIR" ]; then
    rm -rf "$PLUGIN_DIR"
    success "✓ Uninstalled promptfoo plugin"
  else
    echo "Plugin not installed"
  fi
}

pf_help() {
  echo -e "${CYAN}Promptfoo Target Discovery Agent${NC}"
  echo ""
  echo "Analyze target specifications and generate working promptfoo configs."
  echo ""
  echo -e "${BOLD}Installation:${NC}"
  echo "  crab pf install              Install the plugin"
  echo "  crab pf uninstall            Remove the plugin"
  echo "  crab pf update               Update to latest version"
  echo ""
  echo -e "${BOLD}Usage:${NC}"
  echo "  crab pf --file <path>        Analyze target from file"
  echo "  crab pf \"curl ...\"           Analyze curl command"
  echo "  crab pf --url <url>          Probe a URL directly"
  echo ""
  echo -e "${BOLD}Options:${NC}"
  echo "  --output, -o <dir>           Output directory (default: current dir)"
  echo "  --provider <provider>        LLM provider (default: openai:gpt-4o)"
  echo "  --verbose, -v                Show detailed output"
  echo ""
  echo -e "${BOLD}Supported formats:${NC}"
  echo "  - Curl commands"
  echo "  - OpenAPI/Swagger specs"
  echo "  - Postman collections"
  echo "  - Burp Suite exports"
  echo "  - Plain text descriptions"
  echo ""
  echo -e "${BOLD}Environment:${NC}"
  echo "  OPENAI_API_KEY               OpenAI API key"
  echo "  ANTHROPIC_API_KEY            Anthropic API key"
}

# =============================================================================
# Multi-Project Commands
# =============================================================================

# List all registered projects
show_projects() {
  local subcmd="${1:-}"

  if [ "$subcmd" = "rm" ] || [ "$subcmd" = "remove" ] || [ "$subcmd" = "delete" ]; then
    remove_project "${2:-}"
    return
  fi

  echo -e "${CYAN}Registered Projects${NC}"
  echo ""

  if [ ! -d "$PROJECTS_DIR" ] || [ -z "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
    echo "  No projects registered."
    echo ""
    echo "  Run 'crab init' to register your first project."
    return
  fi

  # Get default project
  local default_alias=""
  if [ -f "$GLOBAL_CONFIG" ]; then
    default_alias=$(yq -r '.default_project // ""' "$GLOBAL_CONFIG" 2>/dev/null)
    [ "$default_alias" = "null" ] && default_alias=""
  fi

  for f in "$PROJECTS_DIR"/*.yaml; do
    [ -f "$f" ] || continue
    local alias=$(basename "$f" .yaml)
    local repo=$(yq -r '.main_repo // ""' "$f" 2>/dev/null)
    local session=$(yq -r '.session_name // ""' "$f" 2>/dev/null)

    # Check if tmux session is running
    local status_icon="  "
    if tmux has-session -t "$session" 2>/dev/null; then
      status_icon="${GREEN}●${NC} "
    fi

    # Check if default
    local default_marker=""
    if [ "$alias" = "$default_alias" ]; then
      default_marker=" ${YELLOW}(default)${NC}"
    fi

    echo -e "  ${status_icon}${BOLD}@$alias${NC}${default_marker}"
    echo -e "    ${GRAY}$repo${NC}"
  done
  echo ""
}

# Remove a project registration
remove_project() {
  local alias="${1:-}"

  if [ -z "$alias" ]; then
    error "Usage: crab projects rm <alias>"
    return 1
  fi

  # Strip @ prefix if provided
  alias="${alias#@}"

  local project_file="$PROJECTS_DIR/${alias}.yaml"
  if [ ! -f "$project_file" ]; then
    error "No project registered with alias: @$alias"
    return 1
  fi

  echo -e "Remove project registration for ${BOLD}@$alias${NC}?"
  echo -e "  ${GRAY}(This only removes the config, not your workspaces or repo)${NC}"
  read -p "  [y/N]: " confirm
  if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
    echo "Cancelled."
    return
  fi

  rm "$project_file"

  # Clear default if it was the default
  if [ -f "$GLOBAL_CONFIG" ]; then
    local current_default=$(yq -r '.default_project // ""' "$GLOBAL_CONFIG" 2>/dev/null)
    if [ "$current_default" = "$alias" ]; then
      yq -i '.default_project = ""' "$GLOBAL_CONFIG"
      echo -e "  ${YELLOW}Cleared default project (was @$alias)${NC}"
    fi
  fi

  success "Removed project @$alias"
}

# Set or show the default project
set_default_project() {
  local alias="${1:-}"

  if [ -z "$alias" ]; then
    # Show current default
    local current=""
    if [ -f "$GLOBAL_CONFIG" ]; then
      current=$(yq -r '.default_project // ""' "$GLOBAL_CONFIG" 2>/dev/null)
      [ "$current" = "null" ] && current=""
    fi
    if [ -n "$current" ]; then
      echo -e "Default project: ${BOLD}@$current${NC}"
    else
      echo "No default project set."
      echo "Usage: crab default <alias>"
    fi
    return
  fi

  # Strip @ prefix if provided
  alias="${alias#@}"

  local project_file="$PROJECTS_DIR/${alias}.yaml"
  if [ ! -f "$project_file" ]; then
    error "No project registered with alias: @$alias"
    echo "Run 'crab projects' to see registered projects."
    return 1
  fi

  mkdir -p "$CONFIG_DIR"
  if [ -f "$GLOBAL_CONFIG" ]; then
    yq -i ".default_project = \"$alias\"" "$GLOBAL_CONFIG"
  else
    cat > "$GLOBAL_CONFIG" << EOF
# Crabcode Global Configuration
default_project: $alias
EOF
  fi

  success "Default project set to @$alias"
}

# =============================================================================
# Session Management
# =============================================================================

SESSIONS_DIR="$CONFIG_DIR/sessions"

# Get sessions directory for current project
get_sessions_dir() {
  local project="${PROJECT_ALIAS:-default}"
  echo "$SESSIONS_DIR/$project"
}

# Create a new session
# Usage: session_create "name" ["context content"]
session_create() {
  local name="$1"
  local context="${2:-}"
  local sessions_dir=$(get_sessions_dir)
  local session_dir="$sessions_dir/$name"

  if [ -d "$session_dir" ]; then
    error "Session '$name' already exists"
    echo "Use 'crab session resume $name' to continue it"
    return 1
  fi

  mkdir -p "$session_dir"

  # Create session.yaml
  cat > "$session_dir/session.yaml" << EOF
name: $name
project: ${PROJECT_ALIAS:-default}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_accessed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
claude_session_id: ""
summary: ""
type: general
EOF

  # Write context if provided
  if [ -n "$context" ]; then
    echo "$context" > "$session_dir/context.md"
  fi

  echo "$session_dir"
}

# Update session metadata
# Usage: session_update "name" "field" "value"
session_update() {
  local name="$1"
  local field="$2"
  local value="$3"
  local sessions_dir=$(get_sessions_dir)
  local session_file="$sessions_dir/$name/session.yaml"

  if [ ! -f "$session_file" ]; then
    error "Session '$name' not found"
    return 1
  fi

  yq -i ".$field = \"$value\"" "$session_file"
}

# Get session field
# Usage: session_get "name" "field"
session_get() {
  local name="$1"
  local field="$2"
  local sessions_dir=$(get_sessions_dir)
  local session_file="$sessions_dir/$name/session.yaml"

  if [ ! -f "$session_file" ]; then
    return 1
  fi

  yq -r ".$field // \"\"" "$session_file"
}

# List all sessions with summaries
session_list() {
  local sessions_dir=$(get_sessions_dir)
  local filter="${1:-}"  # Optional filter like "review"

  if [ ! -d "$sessions_dir" ]; then
    echo -e "${GRAY}No sessions yet.${NC}"
    echo "Start one with: crab session start \"name\""
    return
  fi

  local found=false
  local project_label=""
  [ -n "$PROJECT_ALIAS" ] && project_label="@$PROJECT_ALIAS "

  # Header based on filter
  local header="Sessions"
  [[ "$filter" == "review" ]] && header="Reviews"
  echo -e "${BOLD}${project_label}${header}:${NC}"
  echo ""

  for session_dir in "$sessions_dir"/*/; do
    [ -d "$session_dir" ] || continue
    local name=$(basename "$session_dir")
    local session_file="$session_dir/session.yaml"

    [ -f "$session_file" ] || continue

    # Apply filter if provided
    if [ -n "$filter" ]; then
      local type=$(yq -r '.type // "general"' "$session_file")
      [[ "$name" == "$filter"* ]] || [[ "$type" == "$filter" ]] || continue
    fi

    found=true
    local summary=$(yq -r '.summary // ""' "$session_file")
    local last_accessed=$(yq -r '.last_accessed // ""' "$session_file")
    local type=$(yq -r '.type // "general"' "$session_file")

    # Format time ago
    local time_ago=""
    if [ -n "$last_accessed" ] && [ "$last_accessed" != "null" ]; then
      local timestamp=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$last_accessed" "+%s" 2>/dev/null || echo "")
      if [ -n "$timestamp" ]; then
        local now=$(date "+%s")
        local diff=$((now - timestamp))
        if [ $diff -lt 60 ]; then
          time_ago="just now"
        elif [ $diff -lt 3600 ]; then
          time_ago="$((diff / 60))m ago"
        elif [ $diff -lt 86400 ]; then
          time_ago="$((diff / 3600))h ago"
        else
          time_ago="$((diff / 86400))d ago"
        fi
      fi
    fi

    # Format summary
    local summary_display=""
    if [ -n "$summary" ] && [ "$summary" != "null" ]; then
      [ ${#summary} -gt 50 ] && summary="${summary:0:47}..."
      summary_display="\"$summary\""
    else
      summary_display="${GRAY}(no summary)${NC}"
    fi

    # Color based on type
    local type_color="$CYAN"
    [[ "$type" == "general" ]] && type_color="$GRAY"

    # Check if review output exists
    local output_marker=""
    if [ -f "$session_dir/review-output.md" ]; then
      output_marker=" ${GREEN}[saved]${NC}"
    fi

    printf "  ${BOLD}%-20s${NC} ${type_color}%-50b${NC}%b ${GRAY}%s${NC}\n" "$name" "$summary_display" "$output_marker" "$time_ago"
  done

  if [ "$found" = false ]; then
    echo -e "  ${GRAY}(none)${NC}"
  fi
  echo ""
}

# Start a new session and launch Claude
session_start() {
  local name="$1"
  local context="${2:-}"

  local session_dir=$(session_create "$name" "$context")
  [ $? -eq 0 ] || return 1

  echo -e "${CYAN}Starting session: $name${NC}"

  # Start Claude and capture session ID
  local context_file="$session_dir/context.md"
  local claude_args=""

  if [ -f "$context_file" ]; then
    echo -e "  Context loaded from: $context_file"
    claude_args="-p \"$(cat "$context_file" | head -c 1000)\""
  fi

  # Update last accessed
  session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

  # Run Claude interactively with context
  cd "$(pwd)"
  if [ -f "$context_file" ]; then
    claude --dangerously-skip-permissions --chrome "$context_file"
  else
    claude --dangerously-skip-permissions --chrome
  fi

  # After Claude exits, prompt for summary if empty
  local current_summary=$(session_get "$name" "summary")
  if [ -z "$current_summary" ] || [ "$current_summary" = "null" ]; then
    echo ""
    read -p "Session summary (optional): " summary
    if [ -n "$summary" ]; then
      session_update "$name" "summary" "$summary"
    fi
  fi
}

# Resume an existing session
session_resume() {
  local name="$1"
  local sessions_dir=$(get_sessions_dir)
  local session_dir="$sessions_dir/$name"
  local session_file="$session_dir/session.yaml"

  if [ ! -f "$session_file" ]; then
    error "Session '$name' not found"
    echo "Use 'crab session ls' to see available sessions"
    return 1
  fi

  echo -e "${CYAN}Resuming session: $name${NC}"

  local summary=$(session_get "$name" "summary")
  [ -n "$summary" ] && [ "$summary" != "null" ] && echo -e "  ${GRAY}$summary${NC}"

  # Show if review output exists
  if [ -f "$session_dir/review-output.md" ]; then
    echo -e "  ${GREEN}Review output saved${NC}"
  fi

  # Update last accessed
  session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

  # Resume Claude from session directory
  cd "$session_dir"
  claude --dangerously-skip-permissions --chrome --continue
}

# Delete a session
session_delete() {
  local name="$1"
  local sessions_dir=$(get_sessions_dir)
  local session_dir="$sessions_dir/$name"

  if [ ! -d "$session_dir" ]; then
    error "Session '$name' not found"
    return 1
  fi

  read -p "Delete session '$name'? [y/N] " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    rm -rf "$session_dir"
    success "Deleted session: $name"
  else
    echo "Cancelled."
  fi
}

# Handle session commands
handle_session_command() {
  local cmd="${1:-ls}"
  shift || true

  case "$cmd" in
    "ls"|"list")
      session_list "$@"
      ;;
    "start"|"new")
      local name="${1:-}"
      if [ -z "$name" ]; then
        read -p "Session name: " name
        [ -z "$name" ] && { error "Name required"; return 1; }
      fi
      session_start "$name"
      ;;
    "resume"|"continue")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify session name: crab session resume <name>"
        return 1
      fi
      session_resume "$name"
      ;;
    "delete"|"rm")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify session name: crab session delete <name>"
        return 1
      fi
      session_delete "$name"
      ;;
    "summary")
      local name="${1:-}"
      local summary="${2:-}"
      if [ -z "$name" ]; then
        error "Usage: crab session summary <name> \"summary text\""
        return 1
      fi
      if [ -z "$summary" ]; then
        read -p "Summary: " summary
      fi
      session_update "$name" "summary" "$summary"
      success "Updated summary for: $name"
      ;;
    *)
      error "Unknown session command: $cmd"
      echo "Usage: crab session [ls|start|resume|delete|summary]"
      return 1
      ;;
  esac
}

# =============================================================================
# Review Commands (Sugar for Sessions)
# =============================================================================

# Parse PR identifier: number, repo#number, or full URL
# Returns: owner repo number
parse_pr_identifier() {
  local pr_id="$1"
  local owner=""
  local repo=""
  local number=""

  if [[ "$pr_id" =~ ^https://github\.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
    # Full URL
    owner="${BASH_REMATCH[1]}"
    repo="${BASH_REMATCH[2]}"
    number="${BASH_REMATCH[3]}"
  elif [[ "$pr_id" =~ ^([^#]+)#([0-9]+)$ ]]; then
    # repo#number format (submodule)
    repo="${BASH_REMATCH[1]}"
    number="${BASH_REMATCH[2]}"
    # Try to get owner from git remote
    owner=$(git remote get-url origin 2>/dev/null | sed -n 's|.*github\.com[:/]\([^/]*\)/.*|\1|p')
  elif [[ "$pr_id" =~ ^[0-9]+$ ]]; then
    # Just a number - use current project's main repo
    number="$pr_id"
    if [ -n "$MAIN_REPO" ]; then
      local remote_url=$(cd "$MAIN_REPO" && git remote get-url origin 2>/dev/null)
      if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/.]+) ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
      fi
    fi
  fi

  echo "$owner $repo $number"
}

# Get court review instructions for the judge pattern
get_court_instructions() {
  cat << 'COURT_EOF'

## Court Review Protocol

You are the **JUDGE** in a code review court. You will orchestrate two reviewers (Claude teammate + Codex) and deliver a final verdict.

### Your Role as Judge:
- **Orchestrate** the review process
- **Verify** all findings by tracing to actual code
- **Investigate** when reviewers disagree
- **Synthesize** a final verdict with zero false positives

### Phase 1: Empanel the Reviewers

Spawn two reviewer agents to analyze the PR independently:

**Reviewer A (Claude):**
```
Use Task tool:
  subagent_type: "general-purpose"
  prompt: "You are Reviewer A. Review this PR for bugs, security issues, and code quality. Be thorough but avoid false positives. Structure findings as Critical/Warning/Suggestion with file:line references. Here is the context: [include PR diff]"
```

**Reviewer B (Codex):**
```
Use Task tool:
  subagent_type: "Bash"
  prompt: "Run: codex --print -p 'You are Reviewer B. Review this code for bugs, security issues, and quality problems. Structure as Critical/Warning/Suggestion with file:line. Diff: [include relevant sections]'"
```

Wait for BOTH reviewers to complete before proceeding.

### Phase 2: Collect Testimony

Document what each reviewer found:
- List Reviewer A's findings
- List Reviewer B's findings
- Note agreements and disagreements

### Phase 3: Verify & Investigate

For EACH finding from either reviewer:

1. **Trace to code**: Use Read tool to examine the actual file and line
2. **Verify the issue**: Is this a real problem or false positive?
3. **Check context**: Does surrounding code explain/mitigate it?
4. **When reviewers disagree**: Investigate deeper, examine edge cases

**Critical Rule**: Do NOT include any finding you haven't personally verified in the code.

### Phase 4: Deliberate

For each potential issue, document:
- What was claimed
- What you found when you traced the code
- Your ruling: CONFIRMED / DISMISSED / NEEDS-INVESTIGATION
- Reasoning

### Phase 5: Final Verdict

Write `review-output.md` with:

```markdown
# Court Review: PR #XXXX

## Verdict Summary
[1-2 sentence overall assessment]

## Confirmed Issues
[Issues verified by tracing code - include file:line and evidence]

## Dismissed Claims
[What reviewers flagged but you determined were false positives - explain why]

## Recommendations
[Actionable next steps]

## Court Record
[Summary of the review process, who found what, how disagreements were resolved]
```

### Rules of the Court:
1. **No false positives**: Only confirm what you've verified in the code
2. **Show your work**: Document how you verified each finding
3. **Be thorough**: Check edge cases, error paths, security implications
4. **Cite evidence**: Every confirmed issue needs file:line proof
5. **Explain dismissals**: If you reject a reviewer's finding, say why
COURT_EOF
}

# Fetch PR data using gh CLI
# mode: "standard" (default) or "court"
fetch_pr_data() {
  local owner="$1"
  local repo="$2"
  local number="$3"
  local mode="${4:-standard}"

  if ! command_exists gh; then
    error "gh CLI required for PR reviews"
    echo "Install: brew install gh"
    return 1
  fi

  local full_repo="$owner/$repo"

  echo -e "${CYAN}Fetching PR #$number from $full_repo...${NC}"

  # Get PR metadata
  local pr_json=$(gh pr view "$number" --repo "$full_repo" --json title,body,headRefName,baseRefName,additions,deletions,changedFiles,url 2>/dev/null)
  if [ -z "$pr_json" ]; then
    error "Could not fetch PR #$number from $full_repo"
    return 1
  fi

  local title=$(echo "$pr_json" | jq -r '.title')
  local additions=$(echo "$pr_json" | jq -r '.additions')
  local deletions=$(echo "$pr_json" | jq -r '.deletions')
  local files=$(echo "$pr_json" | jq -r '.changedFiles')
  local url=$(echo "$pr_json" | jq -r '.url')

  echo -e "  Title: ${BOLD}$title${NC}"
  echo -e "  Files: $files (+$additions / -$deletions)"
  echo ""

  # Get diff and file list
  local diff=$(gh pr diff "$number" --repo "$full_repo" 2>/dev/null)
  local file_list=$(gh pr diff "$number" --repo "$full_repo" --name-only 2>/dev/null)

  # Get instructions based on mode
  local instructions=""
  if [ "$mode" = "court" ]; then
    instructions=$(get_court_instructions)
  else
    instructions="## Instructions
Review this PR. Analyze the changes and:
1. First, propose logical review areas (group related files)
2. Wait for my approval on the areas
3. Then review each area, providing specific findings with file paths and line numbers
4. Generate a summary with actionable feedback
5. **IMPORTANT:** When done, save your complete review findings to \`review-output.md\` in the current directory. Include all issues found, suggestions, and your overall assessment."
  fi

  # Return as structured output
  cat << EOF
# PR Review Context

## PR Information
- **Number:** #$number
- **Repository:** $full_repo
- **Title:** $title
- **URL:** $url
- **Changes:** $files files (+$additions / -$deletions)

## Files Changed
\`\`\`
$file_list
\`\`\`

$instructions

## Diff
\`\`\`diff
$diff
\`\`\`
EOF
}

# Start a new review - interactive mode
review_new_interactive() {
  echo -e "${BOLD}Creating new review session${NC}"
  echo ""

  # Get session name
  local name=""
  read -p "Session name: " name
  [ -z "$name" ] && { error "Name required"; return 1; }

  # Collect PRs
  local prs=()
  echo ""
  echo "Add PRs (empty line when done):"
  while true; do
    read -p "> " pr_input
    [ -z "$pr_input" ] && break
    prs+=("$pr_input")
  done

  if [ ${#prs[@]} -eq 0 ]; then
    error "At least one PR required"
    return 1
  fi

  # Collect context
  echo ""
  echo "Context (optional, empty line when done):"
  local context_lines=()
  while true; do
    read -p "> " context_line
    [ -z "$context_line" ] && break
    context_lines+=("$context_line")
  done

  # Build context document
  local context="# Review Session: $name"$'\n\n'

  # Add user context if provided
  if [ ${#context_lines[@]} -gt 0 ]; then
    context+="## Context"$'\n'
    for line in "${context_lines[@]}"; do
      context+="$line"$'\n'
    done
    context+=$'\n'
  fi

  # Fetch and append PR data
  context+="## Pull Requests"$'\n\n'

  for pr_id in "${prs[@]}"; do
    local parsed=($(parse_pr_identifier "$pr_id"))
    local owner="${parsed[0]}"
    local repo="${parsed[1]}"
    local number="${parsed[2]}"

    if [ -z "$number" ]; then
      warn "Could not parse PR: $pr_id"
      continue
    fi

    local pr_data=$(fetch_pr_data "$owner" "$repo" "$number")
    context+="$pr_data"$'\n\n'
    context+="---"$'\n\n'
  done

  # Create session
  local sessions_dir=$(get_sessions_dir)
  local session_dir="$sessions_dir/$name"
  mkdir -p "$session_dir"

  # Write session metadata
  cat > "$session_dir/session.yaml" << EOF
name: $name
project: ${PROJECT_ALIAS:-default}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_accessed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
claude_session_id: ""
summary: ""
type: review
prs:
$(for pr in "${prs[@]}"; do echo "  - $pr"; done)
EOF

  # Write context
  echo "$context" > "$session_dir/context.md"

  echo ""
  echo -e "${GREEN}Review session created: $name${NC}"
  echo -e "Context written to: $session_dir/context.md"
  echo ""

  # Start Claude from session directory so it can write review-output.md there
  read -p "Start Claude now? [Y/n] " start_now
  if [[ ! "$start_now" =~ ^[Nn]$ ]]; then
    session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    cd "$session_dir"
    claude --dangerously-skip-permissions --chrome "context.md"

    # Prompt for summary after Claude exits
    _prompt_review_summary "$name"
  fi
}

# Prompt for review summary with auto-generate option
_prompt_review_summary() {
  local name="$1"
  echo ""
  echo "Save a summary for this review?"
  echo "  [a] Auto-generate (Claude summarizes)"
  echo "  [m] Manual (type your own)"
  echo "  [s] Skip"
  read -p "Choice [a/m/s]: " choice

  case "$choice" in
    a|A|"")
      echo -e "${CYAN}Generating summary...${NC}"
      local summary=$(claude --continue --print -p "Summarize this review session in ONE short line (under 60 chars). Format: '<main finding/status> - <key detail>'. Example: 'Found 3 issues - N+1 query, missing index, race condition'. Just output the summary, nothing else." 2>/dev/null | tail -1)
      if [ -n "$summary" ]; then
        # Clean up the summary (remove quotes if present)
        summary="${summary#\"}"
        summary="${summary%\"}"
        session_update "$name" "summary" "$summary"
        echo -e "Summary: ${GREEN}$summary${NC}"
      else
        echo -e "${YELLOW}Could not generate summary${NC}"
      fi
      ;;
    m|M)
      read -p "Summary: " summary
      if [ -n "$summary" ]; then
        session_update "$name" "summary" "$summary"
        success "Summary saved"
      fi
      ;;
    *)
      echo "Skipped"
      ;;
  esac
}

# Quick review - single PR (standard single-agent review)
review_quick() {
  local pr_id="$1"

  local parsed=($(parse_pr_identifier "$pr_id"))
  local owner="${parsed[0]}"
  local repo="${parsed[1]}"
  local number="${parsed[2]}"

  if [ -z "$number" ]; then
    error "Could not parse PR identifier: $pr_id"
    echo "Formats: 3230, repo#456, https://github.com/.../pull/123"
    return 1
  fi

  local name="review-${repo:-pr}-$number"

  # Check if session already exists
  local sessions_dir=$(get_sessions_dir)
  if [ -d "$sessions_dir/$name" ]; then
    echo -e "${YELLOW}Review session already exists: $name${NC}"
    read -p "Resume it? [Y/n] " resume
    if [[ ! "$resume" =~ ^[Nn]$ ]]; then
      session_resume "$name"
      return
    fi
    return 1
  fi

  # Fetch PR data
  local context=$(fetch_pr_data "$owner" "$repo" "$number" "standard")
  [ $? -eq 0 ] || return 1

  # Create session
  local session_dir="$sessions_dir/$name"
  mkdir -p "$session_dir"

  cat > "$session_dir/session.yaml" << EOF
name: $name
project: ${PROJECT_ALIAS:-default}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_accessed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
claude_session_id: ""
summary: ""
type: review
prs:
  - $pr_id
EOF

  echo "$context" > "$session_dir/context.md"

  echo -e "${GREEN}Review session created: $name${NC}"
  echo ""

  # Start Claude from session directory so it can write review-output.md there
  session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  cd "$session_dir"
  claude --dangerously-skip-permissions --chrome "context.md"

  # Prompt for summary after Claude exits
  _prompt_review_summary "$name"
}

# Show fun court intro animation
_show_court_intro() {
  cat << 'COURT_ART'

                    ⚖️  THE CRAB COURT  ⚖️
    ┌─────────────────────────────────────────────┐
    │                                             │
    │            🦀 JUDGE CLAUDE 🦀               │
    │         "Order in the court!"               │
    │                                             │
    │     ┌───────────┐       ┌───────────┐       │
    │     │ Reviewer  │       │ Reviewer  │       │
    │     │     A     │  vs   │     B     │       │
    │     │ (Claude)  │       │  (Codex)  │       │
    │     └───────────┘       └───────────┘       │
    │                                             │
    └─────────────────────────────────────────────┘

COURT_ART

  echo "How this works:"
  echo ""
  echo "  1. 📋 Empanel     Judge spawns two independent reviewers"
  echo "  2. 🔍 Review      Both reviewers analyze the PR separately"
  echo "  3. 📑 Collect     Judge gathers findings from both"
  echo "  4. ✅ Verify      Judge traces each claim to actual code"
  echo "  5. ⚖️  Deliberate  Resolve disagreements, rule on each issue"
  echo "  6. 📝 Verdict     Final ruling with zero false positives"
  echo ""
  echo "Fetching PR data..."
  echo ""
}

# Court review - Judge pattern with Claude + Codex reviewers
review_court() {
  local pr_id="$1"

  # Immediate feedback
  echo -e "${CYAN}Preparing court review for: $pr_id${NC}"
  echo ""

  # Check if codex CLI is available
  if ! command_exists codex; then
    warn "Codex CLI not found. Install with: npm install -g @openai/codex"
    echo "Court review will proceed with Claude teammate only."
    echo ""
  fi

  local parsed=($(parse_pr_identifier "$pr_id"))
  local owner="${parsed[0]}"
  local repo="${parsed[1]}"
  local number="${parsed[2]}"

  if [ -z "$number" ]; then
    error "Could not parse PR identifier: $pr_id"
    echo "Formats: 3230, repo#456, https://github.com/.../pull/123"
    return 1
  fi

  local name="court-${repo:-pr}-$number"

  # Check if session already exists
  local sessions_dir=$(get_sessions_dir)
  if [ -d "$sessions_dir/$name" ]; then
    echo -e "${YELLOW}Court review session already exists: $name${NC}"
    read -p "Resume it? [Y/n] " resume
    if [[ ! "$resume" =~ ^[Nn]$ ]]; then
      session_resume "$name"
      return
    fi
    return 1
  fi

  # Show the court intro while fetching
  _show_court_intro

  # Fetch PR data with court instructions (this can take a moment for large PRs)
  local context=$(fetch_pr_data "$owner" "$repo" "$number" "court")
  [ $? -eq 0 ] || return 1

  # Create session
  local session_dir="$sessions_dir/$name"
  mkdir -p "$session_dir"

  cat > "$session_dir/session.yaml" << EOF
name: $name
project: ${PROJECT_ALIAS:-default}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_accessed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
claude_session_id: ""
summary: ""
type: court
prs:
  - $pr_id
EOF

  echo "$context" > "$session_dir/context.md"

  echo -e "${GREEN}Court review session created: $name${NC}"
  echo ""

  # Start Claude as the judge
  session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  cd "$session_dir"
  claude --dangerously-skip-permissions --chrome "context.md"

  # Prompt for summary after Claude exits
  _prompt_review_summary "$name"
}

# Handle review commands
handle_review_command() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    "")
      error "Usage: crab review <PR> or crab court <PR>"
      echo ""
      echo "Commands:"
      echo "  crab review <PR>       Quick single-agent review"
      echo "  crab court <PR>        Court review (Judge + 2 reviewers, thorough)"
      echo "  crab review new        Interactive mode (multiple PRs + context)"
      echo "  crab review ls         List review sessions"
      echo "  crab review resume     Resume a review"
      echo "  crab review show       View saved review output"
      echo "  crab review delete     Delete a review session"
      return 1
      ;;
    "new")
      review_new_interactive
      ;;
    "ls"|"list")
      session_list "review"
      ;;
    "resume"|"continue")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify review to resume"
        echo "Use 'crab review ls' to see reviews"
        return 1
      fi
      # Handle both "review-xxx" and just the PR number/name
      if [[ ! "$name" == review-* ]]; then
        local parsed=($(parse_pr_identifier "$name"))
        local repo="${parsed[1]}"
        local number="${parsed[2]}"
        name="review-${repo:-pr}-$number"
      fi
      session_resume "$name"
      ;;
    "delete"|"rm")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify review to delete"
        return 1
      fi
      if [[ ! "$name" == review-* ]]; then
        local parsed=($(parse_pr_identifier "$name"))
        local repo="${parsed[1]}"
        local number="${parsed[2]}"
        name="review-${repo:-pr}-$number"
      fi
      session_delete "$name"
      ;;
    "show"|"view"|"output")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify review to view"
        echo "Usage: crab review show <name>"
        return 1
      fi
      if [[ ! "$name" == review-* ]]; then
        local parsed=($(parse_pr_identifier "$name"))
        local repo="${parsed[1]}"
        local number="${parsed[2]}"
        name="review-${repo:-pr}-$number"
      fi
      local sessions_dir=$(get_sessions_dir)
      local output_file="$sessions_dir/$name/review-output.md"
      if [ -f "$output_file" ]; then
        echo -e "${BOLD}Review output for: $name${NC}"
        echo ""
        cat "$output_file"
      else
        error "No saved review output for '$name'"
        echo "The review hasn't been saved yet. Resume the review and ask Claude to save findings."
      fi
      ;;
    *)
      # Assume it's a PR identifier
      review_quick "$cmd"
      ;;
  esac
}

# Handle court command (shortcut for crab court <PR>)
# Court review - interactive mode for multiple PRs
court_new_interactive() {
  echo "Creating new court review session"
  echo ""

  # Get session name
  local name=""
  read -p "Session name: " name
  [ -z "$name" ] && { error "Name required"; return 1; }
  name="court-$name"

  # Check if codex CLI is available
  if ! command_exists codex; then
    warn "Codex CLI not found. Install with: npm install -g @openai/codex"
    echo "Court review will proceed with Claude teammate only."
    echo ""
  fi

  # Collect PRs
  local prs=()
  echo ""
  echo "Add PRs (empty line when done):"
  while true; do
    read -p "> " pr_input
    [ -z "$pr_input" ] && break
    prs+=("$pr_input")
  done

  if [ ${#prs[@]} -eq 0 ]; then
    error "At least one PR required"
    return 1
  fi

  # Collect context
  echo ""
  echo "Additional context (optional, empty line when done):"
  local context_lines=()
  while true; do
    read -p "> " context_line
    [ -z "$context_line" ] && break
    context_lines+=("$context_line")
  done

  # Show the court intro
  _show_court_intro

  # Build context document with court instructions
  local court_instructions=$(get_court_instructions)
  local context="# Court Review Session: $name"$'\n\n'
  context+="$court_instructions"$'\n\n'

  # Add user context if provided
  if [ ${#context_lines[@]} -gt 0 ]; then
    context+="## Additional Context"$'\n'
    for line in "${context_lines[@]}"; do
      context+="$line"$'\n'
    done
    context+=$'\n'
  fi

  # Fetch and append PR data
  context+="## Pull Requests"$'\n\n'

  for pr_id in "${prs[@]}"; do
    local parsed=($(parse_pr_identifier "$pr_id"))
    local owner="${parsed[0]}"
    local repo="${parsed[1]}"
    local number="${parsed[2]}"

    if [ -z "$number" ]; then
      warn "Could not parse PR: $pr_id"
      continue
    fi

    # Fetch PR data without court instructions (we already added them above)
    local pr_data=$(fetch_pr_data "$owner" "$repo" "$number" "standard")
    context+="$pr_data"$'\n\n'
    context+="---"$'\n\n'
  done

  # Create session
  local sessions_dir=$(get_sessions_dir)
  local session_dir="$sessions_dir/$name"
  mkdir -p "$session_dir"

  # Write session metadata
  cat > "$session_dir/session.yaml" << EOF
name: $name
project: ${PROJECT_ALIAS:-default}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_accessed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
claude_session_id: ""
summary: ""
type: court
prs:
$(for pr in "${prs[@]}"; do echo "  - $pr"; done)
EOF

  # Write context
  echo "$context" > "$session_dir/context.md"

  echo ""
  echo -e "${GREEN}Court review session created: $name${NC}"
  echo ""

  # Start Claude
  read -p "Start court session now? [Y/n] " start_now
  if [[ ! "$start_now" =~ ^[Nn]$ ]]; then
    session_update "$name" "last_accessed" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    cd "$session_dir"
    claude --dangerously-skip-permissions --chrome "context.md"

    # Prompt for summary after Claude exits
    _prompt_review_summary "$name"
  fi
}

# Handle court command
handle_court_command() {
  local cmd="${1:-}"
  shift 2>/dev/null || true

  case "$cmd" in
    "")
      error "Usage: crab court <PR> or crab court new"
      echo ""
      echo "Court review: thorough multi-agent review with:"
      echo "  - Judge (Claude) - orchestrates, verifies, delivers verdict"
      echo "  - Reviewer A (Claude teammate) - independent review"
      echo "  - Reviewer B (Codex) - independent review"
      echo ""
      echo "Commands:"
      echo "  crab court <PR>        Quick court review for single PR"
      echo "  crab court new         Interactive mode (multiple PRs + context)"
      echo "  crab court ls          List court sessions"
      echo "  crab court resume      Resume a court session"
      echo "  crab court show        View saved court output"
      echo "  crab court delete      Delete a court session"
      return 1
      ;;
    "new")
      court_new_interactive
      ;;
    "ls"|"list")
      session_list "court"
      ;;
    "resume"|"continue")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify court session to resume"
        echo "Use 'crab court ls' to see sessions"
        return 1
      fi
      # Handle both "court-xxx" and just the name
      if [[ ! "$name" == court-* ]]; then
        name="court-$name"
      fi
      session_resume "$name"
      ;;
    "show"|"view"|"output")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify court session to view"
        echo "Usage: crab court show <name>"
        return 1
      fi
      if [[ ! "$name" == court-* ]]; then
        name="court-$name"
      fi
      local sessions_dir=$(get_sessions_dir)
      local output_file="$sessions_dir/$name/review-output.md"
      if [ -f "$output_file" ]; then
        echo "Court verdict for: $name"
        echo ""
        cat "$output_file"
      else
        error "No saved verdict for '$name'"
        echo "Resume the court session and have the judge deliver a verdict."
      fi
      ;;
    "delete"|"rm")
      local name="${1:-}"
      if [ -z "$name" ]; then
        error "Specify court session to delete"
        return 1
      fi
      if [[ ! "$name" == court-* ]]; then
        name="court-$name"
      fi
      session_delete "$name"
      ;;
    *)
      # Assume it's a PR identifier
      review_court "$cmd"
      ;;
  esac
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
  # @alias stripping: crab @pf ws 1 → resolve project, then route "ws 1"
  PROJECT_ALIAS=""
  if [[ "${1:-}" == @* ]]; then
    resolve_project "$1"
    shift
  fi

  # For project-aware commands, resolve project (cwd-first, then default)
  case "${1:-}" in
    ""|"ws"|"workspace"|"restart"|"reset"|"refresh"|"continue"|"resume"|"cleanup"|"clean"|"destroy"|"rm"|"remove"|"new"|"create"|"wip"|"save"|"config"|"doctor"|"ports"|"shared"|"status"|"snapshot"|"receive"|"handoff"|"rewind"|"timetravel"|"tt"|"pair"|"join"|"spectate"|"watch"|"mood"|"mobile"|"slack"|"tk"|"toolkit"|"pf"|"promptfoo"|"session"|"review"|"court")
      if [ -z "$PROJECT_ALIAS" ]; then
        # Legacy migration check
        if is_legacy_config; then
          check_legacy_migration
        fi
        # Try cwd-based detection first (handles: crab restart from a workspace dir)
        resolve_project_from_cwd 2>/dev/null || resolve_project ""
      fi
      ;;
  esac

  case "${1:-}" in
    "")
      list_workspaces
      ;;
    "ws"|"workspace")
      load_config
      validate_config
      handle_ws_command "${@:2}"
      ;;
    "init")
      show_init "${@:2}"
      ;;
    "config")
      if [ "${2:-}" = "scan" ]; then
        config_scan
      else
        show_config
      fi
      ;;
    "doctor")
      show_doctor
      ;;
    "cheat"|"help"|"-h"|"--help")
      if [ "${1:-}" = "cheat" ]; then
        show_cheat
      else
        show_help
      fi
      ;;
    "ports")
      show_ports
      ;;
    "shared")
      show_shared
      ;;
    "tk"|"toolkit")
      handle_tk_command "${@:2}"
      ;;
    "slack")
      handle_slack_command "${@:2}"
      ;;
    "pf"|"promptfoo")
      # Promptfoo target discovery agent
      handle_pf_command "${@:2}"
      ;;
    "session"|"sessions")
      # Session management
      handle_session_command "${@:2}"
      ;;
    "review")
      # PR review sessions
      load_config 2>/dev/null || true
      handle_review_command "${@:2}"
      ;;
    "court")
      # Court review - thorough multi-agent review
      load_config 2>/dev/null || true
      handle_court_command "${@:2}"
      ;;
    "projects"|"project"|"proj")
      show_projects "${@:2}"
      ;;
    "default")
      set_default_project "${2:-}"
      ;;
    "new"|"create")
      # Shorthand: crab new -> crab ws new
      load_config
      validate_config
      create_new_workspace
      ;;
    "restart"|"reset"|"refresh")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> restart"
        exit 1
      fi
      restart_workspace "$num"
      ;;
    "continue"|"resume")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> continue"
        exit 1
      fi
      continue_workspace "$num"
      ;;
    "cleanup"|"clean")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> cleanup"
        exit 1
      fi
      cleanup_workspace "$num"
      ;;
    "save")
      # Shortcut: crab save ["name"] [--restart]
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Not in a workspace directory. Run from inside a workspace."
        exit 1
      fi
      local do_restart="false"
      local custom_name=""
      shift  # Remove "save"
      while [ $# -gt 0 ]; do
        case "$1" in
          --restart|-r)
            do_restart="true"
            shift
            ;;
          *)
            custom_name="$1"
            shift
            ;;
        esac
      done
      wip_save "$num" "$do_restart" "$custom_name"
      ;;
    "destroy"|"rm"|"remove")
      load_config
      validate_config
      if [ -n "${2:-}" ] && [[ "${2:-}" =~ ^[0-9]+$ ]]; then
        destroy_workspace "$2" "${3:-}"
      else
        num=$(detect_workspace)
        if [ -z "$num" ]; then
          error "Specify workspace: crab destroy <N>"
          exit 1
        fi
        destroy_workspace "$num" "${2:-}"
      fi
      ;;
    "wip")
      load_config
      validate_config
      num=$(detect_workspace)

      case "${2:-}" in
        "save")
          # Save requires being in a workspace
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab ws <N> wip save"
            exit 1
          fi
          # Parse: crab wip save ["name"] [--restart]
          local do_restart="false"
          local custom_name=""
          shift 2  # Remove "wip" and "save"
          while [ $# -gt 0 ]; do
            case "$1" in
              --restart|-r)
                do_restart="true"
                shift
                ;;
              *)
                # Anything else is the custom name
                custom_name="$1"
                shift
                ;;
            esac
          done
          wip_save "$num" "$do_restart" "$custom_name"
          ;;
        "ls"|"list")
          # List is global by default, unless --ws flag or physically in workspace
          local dir_ws=$(detect_workspace_from_dir)
          if [ "${3:-}" = "--ws" ] && [ -n "$num" ]; then
            # Explicitly request workspace-specific list
            wip_list "$num"
          elif [ -n "$dir_ws" ] && [ "${3:-}" != "--all" ] && [ "${3:-}" != "-a" ]; then
            # Physically in workspace directory, show workspace-specific
            wip_list "$dir_ws"
            echo -e "${GRAY}Use 'crab wip ls --all' to see all workspaces${NC}"
          else
            # Global view (default when not physically in workspace)
            wip_list_global
          fi
          ;;
        "restore")
          # Restore by index with optional target workspace and --open flag
          # Usage: crab wip restore [<N>] [--to <ws>] [--open]
          local target_ws=""
          local index=""
          local open_after="false"
          shift 2  # Remove "wip" and "restore"

          # Parse arguments
          while [ $# -gt 0 ]; do
            case "$1" in
              --to)
                target_ws="${2:-}"
                shift 2
                ;;
              --open|-o)
                open_after="true"
                shift
                ;;
              *)
                # First non-flag argument is the index
                if [ -z "$index" ] && [[ "$1" =~ ^[0-9]+$ ]]; then
                  index="$1"
                fi
                shift
                ;;
            esac
          done

          if [ -z "$index" ]; then
            # Interactive restore
            wip_restore_global "$target_ws" "$open_after"
          else
            wip_restore_by_index "$index" "$target_ws" "$open_after"
          fi
          ;;
        "--continue"|"-c")
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab wip restore"
            exit 1
          fi
          # Check for --open flag
          local open_flag="false"
          if [ "${3:-}" = "--open" ] || [ "${3:-}" = "-o" ]; then
            open_flag="true"
          fi
          wip_continue "$num" "$open_flag"
          ;;
        "--resume"|"-r"|"resume")
          if [ -z "$num" ]; then
            # Global interactive restore
            wip_restore_global
          else
            wip_resume "$num"
          fi
          ;;
        "delete"|"rm")
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab ws <N> wip delete <name>"
            exit 1
          fi
          wip_delete "$num" "${3:-}"
          ;;
        *)
          echo -e "${CYAN}WIP Commands:${NC}"
          echo ""
          if [ -n "$num" ]; then
            echo -e "  ${BOLD}In workspace $num:${NC}"
            echo "    crab wip save [--restart]  Save current changes"
            echo "    crab wip ls                List WIPs for this workspace"
            echo "    crab wip --continue        Restore most recent WIP"
            echo "    crab wip --resume          Interactive WIP selection"
            echo "    crab wip delete <name>     Delete a WIP state"
            echo ""
          fi
          echo -e "  ${BOLD}Global commands:${NC}"
          echo "    crab wip ls                List all WIPs (global view)"
          echo "    crab wip restore           Interactive restore from all WIPs"
          echo "    crab wip restore <N>       Restore WIP #N to its original workspace"
          echo "    crab wip restore <N> --to <ws>  Restore WIP #N to workspace <ws>"
          echo "    crab wip restore <N> --open     Restore and open workspace"
          echo ""
          echo "  Restores: branch, commits, staged/unstaged changes, submodules"
          ;;
      esac
      ;;
    "mood")
      show_mood
      ;;
    "mobile")
      handle_mobile_command "${@:2}"
      ;;
    "handoff")
      handle_handoff_command "${@:2}"
      ;;
    "rewind"|"timetravel"|"tt")
      handle_rewind_command "${@:2}"
      ;;
    "pair")
      handle_pair_command "${@:2}"
      ;;
    "join")
      if [ -z "${2:-}" ]; then
        error "Usage: crab join <workspace-number>"
        exit 1
      fi
      join_pair_session "$2" "pair"
      ;;
    "spectate"|"watch")
      if [ -z "${2:-}" ]; then
        error "Usage: crab spectate <workspace-number>"
        exit 1
      fi
      join_pair_session "$2" "spectate"
      ;;
    "snapshot")
      load_config
      validate_config
      local num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Not in a workspace. Use: crab snapshot from workspace directory"
        exit 1
      fi
      save_snapshot "$num" "${2:-manual}"
      ;;
    "receive")
      load_config
      validate_config
      receive_handoff "${2:-}" "${4:-}"
      ;;
    "notify")
      crab_notify "${2:-Crab Update}" "${3:-}" "${4:-default}"
      ;;
    "status")
      show_status "${2:-terminal}"
      ;;
    "update"|"upgrade")
      # Self-update from GitHub
      echo -e "${CYAN}Updating crabcode...${NC}"
      local install_dir=$(dirname "$(realpath "$0")")
      local tmp_file="/tmp/crabcode-update-$$"

      if curl -fsSL "https://raw.githubusercontent.com/promptfoo/crabcode/main/src/crabcode" -o "$tmp_file" 2>/dev/null; then
        local new_version=$(grep '^VERSION=' "$tmp_file" | cut -d'"' -f2)
        local current_version="$VERSION"

        if [ "$new_version" = "$current_version" ]; then
          echo -e "${GREEN}Already up to date (v$VERSION)${NC}"
        else
          chmod +x "$tmp_file"
          mv "$tmp_file" "$install_dir/crabcode"
          echo -e "${GREEN}Updated: v$current_version → v$new_version${NC}"
        fi
      else
        error "Failed to download update"
        rm -f "$tmp_file"
        exit 1
      fi
      rm -f "$tmp_file"
      ;;
    "--version"|"-v")
      echo '  /)🦀(\'
      echo "crabcode v$VERSION"
      ;;
    *)
      # Backwards compatibility: crab <N> -> crab ws <N>
      if [[ "$1" =~ ^[0-9]+$ ]]; then
        if [ -z "$PROJECT_ALIAS" ]; then
          if is_legacy_config; then
            check_legacy_migration
          fi
          resolve_project_from_cwd 2>/dev/null || resolve_project ""
        fi
        load_config
        validate_config
        handle_ws_command "$@"
      else
        error "Unknown command: $1"
        echo ""
        echo "Usage: crab ws <N>       Open workspace N"
        echo "       crab @alias ws <N> Open workspace for specific project"
        echo "       crab ws new       Create new workspace"
        echo "       crab restart      Restart current workspace"
        echo "       crab projects     List registered projects"
        echo "       crab cheat        Show all commands"
        exit 1
      fi
      ;;
  esac
}

main "$@"
