#!/usr/bin/env bash
# crabcode - Generic tmux-based workspace manager for multi-repo development
# https://github.com/your-org/crabcode
#
# Usage: crabcode [command] [arguments]
#
# Commands:
#   (no args)         List all workspaces
#   <N>               Open/create workspace N
#   <N> --separate    Open workspace N in separate terminal window
#   <N> cleanup       Kill window + reset to origin/main
#   <N> restart       Reset git + restart panes in place
#   <N> continue      Resume session with --continue flag
#   restart           Auto-detect workspace from cwd + restart
#   continue          Auto-detect workspace from cwd + resume
#   init              Minimal config setup (2 questions)
#   config            Show current configuration
#   config scan       Auto-detect .env files and ports
#   doctor            Diagnose common issues
#   cheat             Show cheat sheet / help
#   ports             Show port usage across workspaces
#   wip save          Save work in progress
#   wip ls            List saved WIP states
#   wip --continue    Restore most recent WIP
#   wip --resume      Interactive WIP selection
#   wip delete <name> Delete a WIP state

set -e

VERSION="0.1.0"
CONFIG_DIR="$HOME/.crabcode"
CONFIG_FILE="$CONFIG_DIR/config.yaml"
WIP_BASE="$CONFIG_DIR/wip"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# =============================================================================
# Utility Functions
# =============================================================================

error() {
  echo -e "${RED}Error: $*${NC}" >&2
}

warn() {
  echo -e "${YELLOW}Warning: $*${NC}" >&2
}

info() {
  echo -e "${CYAN}$*${NC}"
}

success() {
  echo -e "${GREEN}$*${NC}"
}

# Check if a command exists
command_exists() {
  command -v "$1" &>/dev/null
}

# =============================================================================
# Config Loading (using yq for YAML parsing)
# =============================================================================

# Check if yq is installed
check_yq() {
  if ! command_exists yq; then
    error "yq is required but not installed."
    echo "Install with:"
    echo "  brew install yq       # macOS"
    echo "  apt install yq        # Ubuntu/Debian"
    echo "  go install github.com/mikefarah/yq/v4@latest  # Go"
    exit 1
  fi
}

# Load a config value, with optional default
# Usage: config_get "path.to.value" "default"
config_get() {
  local path="$1"
  local default="${2:-}"
  local value

  if [ ! -f "$CONFIG_FILE" ]; then
    echo "$default"
    return
  fi

  value=$(yq -r ".$path // \"\"" "$CONFIG_FILE" 2>/dev/null)
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    echo "$default"
  else
    echo "$value"
  fi
}

# Check if config exists and is valid
config_exists() {
  [ -f "$CONFIG_FILE" ]
}

# Validate required config fields
validate_config() {
  local errors=0

  if ! config_exists; then
    error "No config file found at $CONFIG_FILE"
    echo "Run 'crabcode init' to create one."
    exit 1
  fi

  local session_name=$(config_get "session_name")
  local workspace_base=$(config_get "workspace_base")
  local main_repo=$(config_get "main_repo")

  if [ -z "$session_name" ]; then
    error "Missing required config: session_name"
    errors=$((errors + 1))
  fi

  if [ -z "$workspace_base" ]; then
    error "Missing required config: workspace_base"
    errors=$((errors + 1))
  fi

  if [ -z "$main_repo" ]; then
    error "Missing required config: main_repo"
    errors=$((errors + 1))
  fi

  if [ $errors -gt 0 ]; then
    echo ""
    echo "Run 'crabcode doctor' to diagnose issues."
    exit 1
  fi
}

# Expand ~ and environment variables in paths
expand_path() {
  local path="$1"
  # Expand ~ to $HOME
  path="${path/#\~/$HOME}"
  # Expand environment variables
  eval echo "$path"
}

# =============================================================================
# Config Variables (loaded lazily)
# =============================================================================

_config_loaded=false

load_config() {
  if [ "$_config_loaded" = true ]; then
    return
  fi

  check_yq

  if ! config_exists; then
    return
  fi

  SESSION_NAME=$(config_get "session_name" "crab")
  WORKSPACE_BASE=$(expand_path "$(config_get "workspace_base")")
  MAIN_REPO=$(expand_path "$(config_get "main_repo")")

  WORKSPACE_COUNT=$(config_get "workspaces.count" "5")
  WORKSPACE_PREFIX=$(config_get "workspaces.prefix" "workspace")
  BRANCH_PATTERN=$(config_get "workspaces.branch_pattern" "workspace-{N}")

  API_PORT_BASE=$(config_get "ports.api_base" "3200")
  APP_PORT_BASE=$(config_get "ports.app_base" "3000")

  # Shared volume settings
  SHARED_VOLUME_PATH=$(expand_path "$(config_get "shared_volume.path" "$CONFIG_DIR/shared")")
  SHARED_VOLUME_LINK=$(config_get "shared_volume.link_as" ".local")
  SHARED_VOLUME_ENABLED=$(config_get "shared_volume.enabled" "true")

  _config_loaded=true
}

# =============================================================================
# Tmux Pane Helpers
# =============================================================================

# Get tmux pane indices based on pane-base-index setting
# Layout: terminal (top-left), main (right), server (bottom-left)
# Returns: "terminal_pane:main_pane:server_pane"
get_pane_indices() {
  local pane_base=$(tmux show-options -gv pane-base-index 2>/dev/null || echo "0")
  local p_terminal=$pane_base
  local p_server=$((pane_base + 1))
  local p_main=$((pane_base + 2))
  echo "$p_terminal:$p_main:$p_server"
}

# =============================================================================
# Port Management
# =============================================================================

# Find an available port starting from a base
find_available_port() {
  local base_port=$1
  local port=$base_port
  while lsof -i ":$port" &>/dev/null; do
    port=$((port + 1))
    # Safety limit - don't scan forever
    if [ $port -gt $((base_port + 100)) ]; then
      echo "$base_port"  # Give up, return original
      return
    fi
  done
  echo "$port"
}

# Get workspace ports (api and app) for workspace N
# Returns: api_port:app_port:need_override
get_workspace_ports() {
  local num=$1
  local dir=$2

  local default_api=$((API_PORT_BASE + num))
  local default_app=$((APP_PORT_BASE + num))

  # Read from .env if env_sync is configured
  local env_api=$(read_env_port "$dir" "api")
  local env_app=$(read_env_port "$dir" "app")

  [ -z "$env_api" ] && env_api="$default_api"
  [ -z "$env_app" ] && env_app="$default_app"

  local actual_api=$(find_available_port "$env_api")
  local actual_app=$(find_available_port "$env_app")

  local need_override="false"
  if [ "$actual_api" != "$env_api" ] || [ "$actual_app" != "$env_app" ]; then
    need_override="true"
  fi

  echo "$actual_api:$actual_app:$need_override:$env_api:$env_app"
}

# Read port from .env file based on env_sync config
read_env_port() {
  local dir=$1
  local port_type=$2  # "api" or "app"

  local env_files_count=$(yq -r '.env_sync.files | length // 0' "$CONFIG_FILE" 2>/dev/null)

  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local port_var=$(yq -r ".env_sync.files[$i].port_var" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    if [ -f "$full_path" ] && [ -n "$port_var" ] && [ "$port_var" != "null" ]; then
      local value=$(grep "^${port_var}=" "$full_path" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]')
      if [ -n "$value" ]; then
        # If it's a URL, extract port
        if [[ "$value" =~ :([0-9]+) ]]; then
          echo "${BASH_REMATCH[1]}"
          return
        elif [[ "$value" =~ ^[0-9]+$ ]]; then
          echo "$value"
          return
        fi
      fi
    fi
  done
}

# Sync .env files for a workspace
# New format supports:
#   - copy_from: template file to copy from
#   - ports: array of port vars to manage (increment per workspace)
#   - refs: map of URL vars that reference managed ports
sync_env_files() {
  local dir=$1
  local workspace_num=$2
  local quiet=${3:-false}

  local env_files_count=$(yq -r '.env_sync.files | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$env_files_count" = "0" ] && return

  # Temp file to store resolved ports (bash 3.x compatible)
  local ports_file=$(mktemp)
  trap "rm -f '$ports_file'" RETURN

  # First pass: resolve all managed ports
  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local copy_from=$(yq -r ".env_sync.files[$i].copy_from // \"\"" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    local template_path=""

    # Determine template path
    if [ -n "$copy_from" ] && [ "$copy_from" != "null" ]; then
      template_path="$dir/$copy_from"
    else
      # Fallback: look for .env.example
      template_path="$dir/${env_path}.example"
      [ ! -f "$template_path" ] && template_path="$dir/${env_path%.env}.env.example"
    fi

    # Create from template if target doesn't exist
    if [ ! -f "$full_path" ] && [ -f "$template_path" ]; then
      mkdir -p "$(dirname "$full_path")"
      cp "$template_path" "$full_path"
      [ "$quiet" != "true" ] && echo -e "  ${YELLOW}Created $env_path from template${NC}"
    fi

    # Skip if file still doesn't exist
    [ ! -f "$full_path" ] && continue

    # Get ports array (supports both old port_var and new ports[] format)
    local ports_json=$(yq -r ".env_sync.files[$i].ports // []" "$CONFIG_FILE" 2>/dev/null)
    local old_port_var=$(yq -r ".env_sync.files[$i].port_var // \"\"" "$CONFIG_FILE" 2>/dev/null)

    # Handle old format (port_var: single var)
    if [ -n "$old_port_var" ] && [ "$old_port_var" != "null" ]; then
      ports_json="[\"$old_port_var\"]"
    fi

    # Process each port var
    local ports_count=$(echo "$ports_json" | yq -r 'length // 0' 2>/dev/null)
    for ((p=0; p<ports_count; p++)); do
      local port_var=$(echo "$ports_json" | yq -r ".[$p]" 2>/dev/null)
      [ -z "$port_var" ] || [ "$port_var" = "null" ] && continue

      # Read current value from workspace .env
      local current_value=$(grep "^${port_var}=" "$full_path" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]"'"'")

      # If no current value, try to read base from main repo
      if [ -z "$current_value" ]; then
        local main_env="$MAIN_REPO/$env_path"
        [ -f "$main_env" ] && current_value=$(grep "^${port_var}=" "$main_env" 2>/dev/null | cut -d= -f2- | tr -d '[:space:]"'"'")
      fi

      # Extract base port number
      local base_port=""
      if echo "$current_value" | grep -qE '^[0-9]+$'; then
        base_port="$current_value"
      elif echo "$current_value" | grep -qE ':[0-9]+'; then
        base_port=$(echo "$current_value" | grep -oE ':[0-9]+' | tail -1 | tr -d ':')
      fi

      [ -z "$base_port" ] && continue

      # Calculate workspace port
      local new_port=$((base_port + workspace_num))

      # Check if port is available, find next free if not
      while lsof -i ":$new_port" &>/dev/null; do
        new_port=$((new_port + 1))
        # Safety limit
        if [ $new_port -gt $((base_port + 100)) ]; then
          new_port=$((base_port + workspace_num))
          break
        fi
      done

      # Store resolved port for refs lookup
      echo "$port_var=$new_port" >> "$ports_file"

      # Update the .env file
      local new_value
      if echo "$current_value" | grep -qE '^[0-9]+$'; then
        new_value="$new_port"
      else
        # Replace port in URL/string
        new_value=$(echo "$current_value" | sed "s/:${base_port}/:${new_port}/g")
      fi

      if [ "$current_value" != "$new_value" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
          sed -i '' "s|^${port_var}=.*|${port_var}=$new_value|" "$full_path"
        else
          sed -i "s|^${port_var}=.*|${port_var}=$new_value|" "$full_path"
        fi
        [ "$quiet" != "true" ] && echo -e "  ${GREEN}$env_path: $port_var → $new_port${NC}"
      fi
    done
  done

  # Second pass: process refs (URL vars that reference managed ports)
  for ((i=0; i<env_files_count; i++)); do
    local env_path=$(yq -r ".env_sync.files[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$env_path" ] || [ "$env_path" = "null" ] && continue

    local full_path="$dir/$env_path"
    [ ! -f "$full_path" ] && continue

    # Get refs map
    local refs_keys=$(yq -r ".env_sync.files[$i].refs // {} | keys | .[]" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$refs_keys" ] && continue

    echo "$refs_keys" | while read -r ref_var; do
      [ -z "$ref_var" ] && continue

      local ref_port_var=$(yq -r ".env_sync.files[$i].refs[\"$ref_var\"]" "$CONFIG_FILE" 2>/dev/null)
      [ -z "$ref_port_var" ] || [ "$ref_port_var" = "null" ] && continue

      # Look up the resolved port
      local resolved_port=$(grep "^${ref_port_var}=" "$ports_file" 2>/dev/null | cut -d= -f2)
      [ -z "$resolved_port" ] && continue

      # Read current value
      local current_value=$(grep "^${ref_var}=" "$full_path" 2>/dev/null | cut -d= -f2-)
      [ -z "$current_value" ] && continue

      # Extract current port from URL
      local current_port=$(echo "$current_value" | grep -oE ':[0-9]+' | tail -1 | tr -d ':')
      [ -z "$current_port" ] && continue

      if [ "$current_port" != "$resolved_port" ]; then
        local new_value=$(echo "$current_value" | sed "s/:${current_port}/:${resolved_port}/g")

        if [[ "$OSTYPE" == "darwin"* ]]; then
          sed -i '' "s|^${ref_var}=.*|${ref_var}=$new_value|" "$full_path"
        else
          sed -i "s|^${ref_var}=.*|${ref_var}=$new_value|" "$full_path"
        fi
        [ "$quiet" != "true" ] && echo -e "  ${GREEN}$env_path: $ref_var → :$resolved_port${NC}"
      fi
    done
  done
}

# Show port usage across all workspaces
show_ports() {
  load_config
  validate_config

  echo -e "${CYAN}Port Usage Across Workspaces${NC}"
  echo ""
  printf "  %-20s %-8s %-8s %-20s\n" "WORKSPACE" "API" "APP" "STATUS"
  echo "  ────────────────────────────────────────────────────────"

  for ((i=1; i<=WORKSPACE_COUNT; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ ! -d "$dir" ]; then
      continue
    fi

    local default_api=$((API_PORT_BASE + i))
    local default_app=$((APP_PORT_BASE + i))
    local api_port=$(read_env_port "$dir" "api")
    local app_port=$(read_env_port "$dir" "app")
    [ -z "$api_port" ] && api_port="$default_api"
    [ -z "$app_port" ] && app_port="$default_app"

    # Check API port status
    local api_status="free"
    if lsof -i ":$api_port" &>/dev/null; then
      local pid=$(lsof -t -i ":$api_port" 2>/dev/null | head -1)
      local cwd=$(lsof -p "$pid" 2>/dev/null | grep cwd | awk '{print $NF}')
      if [[ "$cwd" == *"$WORKSPACE_PREFIX-$i"* ]]; then
        api_status="running"
      elif [[ "$cwd" == *"$WORKSPACE_PREFIX-"* ]]; then
        local other_ws=$(echo "$cwd" | grep -oE "${WORKSPACE_PREFIX}-[0-9]+" | sed "s/${WORKSPACE_PREFIX}-/ws/")
        api_status="TAKEN:$other_ws"
      else
        api_status="in-use"
      fi
    fi

    # Check APP port status
    local app_status="free"
    if lsof -i ":$app_port" &>/dev/null; then
      local pid=$(lsof -t -i ":$app_port" 2>/dev/null | head -1)
      local cwd=$(lsof -p "$pid" 2>/dev/null | grep cwd | awk '{print $NF}')
      if [[ "$cwd" == *"$WORKSPACE_PREFIX-$i"* ]]; then
        app_status="running"
      elif [[ "$cwd" == *"$WORKSPACE_PREFIX-"* ]]; then
        local other_ws=$(echo "$cwd" | grep -oE "${WORKSPACE_PREFIX}-[0-9]+" | sed "s/${WORKSPACE_PREFIX}-/ws/")
        app_status="TAKEN:$other_ws"
      else
        app_status="in-use"
      fi
    fi

    # Color code status
    local api_display app_display
    case "$api_status" in
      "free") api_display="${YELLOW}free${NC}" ;;
      "running") api_display="${GREEN}●${NC}" ;;
      TAKEN:*) api_display="${RED}${api_status}${NC}" ;;
      *) api_display="${YELLOW}busy${NC}" ;;
    esac
    case "$app_status" in
      "free") app_display="${YELLOW}free${NC}" ;;
      "running") app_display="${GREEN}●${NC}" ;;
      TAKEN:*) app_display="${RED}${app_status}${NC}" ;;
      *) app_display="${YELLOW}busy${NC}" ;;
    esac

    printf "  %-20s %-8s %-8s " "$WORKSPACE_PREFIX-$i" "$api_port" "$app_port"
    echo -e "API: $api_display  APP: $app_display"
  done
  echo ""
  echo -e "  Legend: ${GREEN}●${NC}=running  ${YELLOW}free${NC}=available  ${RED}TAKEN:wsN${NC}=conflict"
}

# =============================================================================
# Git Operations
# =============================================================================

# Get the branch name for workspace N
get_branch_name() {
  local num=$1
  echo "${BRANCH_PATTERN//\{N\}/$num}"
}

# Create workspace directory with git worktree
create_workspace() {
  local num=$1
  local workspace_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local branch_name=$(get_branch_name "$num")

  if [ -d "$workspace_dir" ]; then
    echo -e "  ${YELLOW}Workspace $num already exists${NC}"
    return 0
  fi

  echo -e "${CYAN}Creating workspace $num...${NC}"

  # Check if main repo exists
  if [ ! -d "$MAIN_REPO" ]; then
    error "Main repo not found at $MAIN_REPO"
    exit 1
  fi

  # Ensure workspace base exists
  mkdir -p "$WORKSPACE_BASE"

  # Create git worktree
  echo "  Creating git worktree..."
  cd "$MAIN_REPO"
  git fetch origin 2>/dev/null || true  # May fail if no remote

  # Check if branch exists
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git worktree add "$workspace_dir" "$branch_name"
  elif git show-ref --verify --quiet "refs/remotes/origin/main"; then
    git worktree add -b "$branch_name" "$workspace_dir" origin/main
  else
    # No origin/main - use current HEAD
    git worktree add -b "$branch_name" "$workspace_dir" HEAD
  fi

  # Initialize submodules if configured
  init_submodules "$workspace_dir"

  # Setup shared volume
  setup_shared_volume "$workspace_dir"

  # Sync .env files (pass workspace number for port calculation)
  sync_env_files "$workspace_dir" "$num"

  success "Workspace $num created at $workspace_dir"
}

# Initialize submodules in workspace
init_submodules() {
  local dir=$1

  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$submodules_count" = "0" ] && return

  cd "$dir"

  # Find the main git dir (worktrees share .git/modules with main repo)
  local git_dir=$(git rev-parse --git-common-dir 2>/dev/null)

  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local reset_to=$(yq -r ".submodules[$i].reset_to" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    # Check if submodule data already exists in main repo
    local modules_dir="$git_dir/modules/$sub_path"
    if [ -d "$modules_dir" ]; then
      # Submodule already fetched - just checkout locally (fast, no network)
      echo "  Checking out submodule: $sub_path (using cached data)"
      git submodule update "$sub_path" 2>/dev/null || git submodule update --init "$sub_path" 2>/dev/null || true
    else
      # Need to fetch submodule (slow, first time only)
      echo "  Fetching submodule: $sub_path (first time, may take a moment)"
      git submodule update --init "$sub_path" 2>/dev/null || true
    fi

    # Reset to configured ref if specified
    if [ -n "$reset_to" ] && [ "$reset_to" != "null" ] && [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      # Only fetch if the ref doesn't exist locally
      if ! git rev-parse --verify "$reset_to" &>/dev/null; then
        echo "  Fetching $reset_to for $sub_path..."
        git fetch origin --quiet 2>/dev/null || true
      fi
      git checkout main 2>/dev/null || git checkout -b main 2>/dev/null || true
      git reset --hard "$reset_to" 2>/dev/null || true
      cd "$dir"
    fi
  done
}

# Reset submodules to configured state
reset_submodules() {
  local dir=$1

  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  [ "$submodules_count" = "0" ] && return

  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local reset_to=$(yq -r ".submodules[$i].reset_to" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      echo "  Resetting submodule: $sub_path"
      cd "$dir/$sub_path"
      git checkout -- . 2>/dev/null || true
      git clean -fd 2>/dev/null || true
      git checkout main 2>/dev/null || git checkout -b main origin/main 2>/dev/null || true
      git fetch origin main --quiet 2>/dev/null || true
      if [ -n "$reset_to" ] && [ "$reset_to" != "null" ]; then
        git reset --hard "$reset_to"
      else
        git reset --hard origin/main
      fi
      cd "$dir"
      echo -e "  ${GREEN}Submodule $sub_path reset${NC}"
    fi
  done
}

# =============================================================================
# Shared Volume Management
# =============================================================================

# Setup shared volume symlink in a workspace
# Handles migration of existing .local directories
setup_shared_volume() {
  local dir=$1

  # Skip if shared volume is disabled
  if [ "$SHARED_VOLUME_ENABLED" != "true" ]; then
    return 0
  fi

  local link_name="$SHARED_VOLUME_LINK"
  local link_path="$dir/$link_name"
  local shared_path="$SHARED_VOLUME_PATH"

  # Create shared volume directory if it doesn't exist
  if [ ! -d "$shared_path" ]; then
    echo "  Creating shared volume at $shared_path..."
    mkdir -p "$shared_path"
  fi

  # Check current state of link path
  if [ -L "$link_path" ]; then
    # Already a symlink - check if it points to the right place
    local current_target=$(readlink "$link_path")
    if [ "$current_target" = "$shared_path" ]; then
      # Already correctly linked
      return 0
    else
      # Wrong target - remove and recreate
      echo "  Updating $link_name symlink..."
      rm "$link_path"
    fi
  elif [ -d "$link_path" ]; then
    # Existing directory - migrate contents to shared volume
    echo "  Migrating existing $link_name to shared volume..."

    # Copy contents to shared volume (preserving existing shared files)
    if [ "$(ls -A "$link_path" 2>/dev/null)" ]; then
      # Directory has contents - migrate them
      local migrated=0
      for item in "$link_path"/*; do
        [ ! -e "$item" ] && continue
        local basename=$(basename "$item")
        if [ -e "$shared_path/$basename" ]; then
          # File/dir exists in shared - create workspace-specific backup
          local ws_name=$(basename "$dir")
          local backup_name="${basename}.from-${ws_name}"
          echo "    $basename exists in shared, saving as $backup_name"
          mv "$item" "$shared_path/$backup_name"
        else
          echo "    Moving $basename to shared volume"
          mv "$item" "$shared_path/"
        fi
        migrated=$((migrated + 1))
      done
      if [ $migrated -gt 0 ]; then
        echo -e "  ${GREEN}Migrated $migrated item(s) to shared volume${NC}"
      fi
    fi

    # Remove the now-empty directory
    rmdir "$link_path" 2>/dev/null || rm -rf "$link_path"
  elif [ -e "$link_path" ]; then
    # Some other file type - backup and remove
    echo "  Backing up existing $link_name..."
    mv "$link_path" "$link_path.backup.$(date +%Y%m%d%H%M%S)"
  fi

  # Create symlink
  ln -s "$shared_path" "$link_path"
  echo -e "  ${GREEN}Linked $link_name → $shared_path${NC}"

  # Add to .gitignore if not already there
  local gitignore="$dir/.gitignore"
  if [ -f "$gitignore" ]; then
    if ! grep -q "^${link_name}$" "$gitignore" 2>/dev/null; then
      echo "" >> "$gitignore"
      echo "# Shared local volume (crabcode)" >> "$gitignore"
      echo "$link_name" >> "$gitignore"
      echo "  Added $link_name to .gitignore"
    fi
  else
    # Create .gitignore with the link name
    echo "# Shared local volume (crabcode)" > "$gitignore"
    echo "$link_name" >> "$gitignore"
    echo "  Created .gitignore with $link_name"
  fi
}

# =============================================================================
# Workspace Operations
# =============================================================================

# List all workspaces
list_workspaces() {
  load_config

  echo -e "${CYAN}Crabcode Workspaces${NC}"
  echo ""

  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo ""
    echo "Run 'crabcode init' to set up crabcode."
    return
  fi

  validate_config

  # Check if main session exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${GREEN}Active session: $SESSION_NAME${NC}"
    echo "Windows:"
    tmux list-windows -t "$SESSION_NAME" 2>/dev/null | while read -r line; do
      echo "  $line"
    done
    echo ""
  else
    echo -e "${YELLOW}No active $SESSION_NAME session.${NC}"
    echo ""
  fi

  echo -e "${YELLOW}Available workspaces:${NC}"
  local found=false

  # Find all existing workspaces (may be more than configured count)
  local max_ws=$WORKSPACE_COUNT
  for dir in "$WORKSPACE_BASE/$WORKSPACE_PREFIX-"*; do
    if [ -d "$dir" ]; then
      local num=$(basename "$dir" | sed "s/${WORKSPACE_PREFIX}-//")
      if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -gt "$max_ws" ]; then
        max_ws=$num
      fi
    fi
  done

  for ((i=1; i<=max_ws; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ -d "$dir" ]; then
      found=true
      local branch=$(cd "$dir" && git branch --show-current 2>/dev/null || echo "unknown")
      local api_port=$((API_PORT_BASE + i))
      local env_port=$(read_env_port "$dir" "api")
      [ -n "$env_port" ] && api_port="$env_port"

      # Check if this workspace has a window in the session
      local status="${YELLOW}[available]${NC}"
      if tmux has-session -t "$SESSION_NAME" 2>/dev/null && \
         tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^ws$i$"; then
        status="${GREEN}[active]${NC}"
      fi
      echo -e "  $i: $WORKSPACE_PREFIX-$i ($branch) :$api_port $status"
    fi
  done

  if [ "$found" = false ]; then
    echo "  No workspaces found."
    echo ""
    echo "Run 'crab ws new' or 'crab ws 1' to create a workspace."
  fi
}

# Interactive workspace menu
interactive_workspace_menu() {
  load_config

  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo ""
    echo "Run 'crab init' to set up crabcode."
    return
  fi

  validate_config

  # Show workspaces
  echo -e "${CYAN}Crabcode Workspaces${NC}"
  echo ""

  # Check if main session exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${GREEN}Active session: $SESSION_NAME${NC}"
    echo "Windows:"
    tmux list-windows -t "$SESSION_NAME" 2>/dev/null | while read -r line; do
      echo "  $line"
    done
    echo ""
  else
    echo -e "${YELLOW}No active $SESSION_NAME session.${NC}"
    echo ""
  fi

  # Find all existing workspaces
  local max_ws=$WORKSPACE_COUNT
  local existing_workspaces=""
  for dir in "$WORKSPACE_BASE/$WORKSPACE_PREFIX-"*; do
    if [ -d "$dir" ]; then
      local num=$(basename "$dir" | sed "s/${WORKSPACE_PREFIX}-//")
      if [[ "$num" =~ ^[0-9]+$ ]]; then
        existing_workspaces="$existing_workspaces $num"
        [ "$num" -gt "$max_ws" ] && max_ws=$num
      fi
    fi
  done

  echo -e "${YELLOW}Workspaces:${NC}"
  local found=false
  for ((i=1; i<=max_ws; i++)); do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$i"
    if [ -d "$dir" ]; then
      found=true
      local branch=$(cd "$dir" && git branch --show-current 2>/dev/null || echo "unknown")
      local api_port=$((API_PORT_BASE + i))
      local env_port=$(read_env_port "$dir" "api")
      [ -n "$env_port" ] && api_port="$env_port"

      local status="${YELLOW}[available]${NC}"
      if tmux has-session -t "$SESSION_NAME" 2>/dev/null && \
         tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^ws$i$"; then
        status="${GREEN}[active]${NC}"
      fi
      echo -e "  $i: $WORKSPACE_PREFIX-$i ($branch) :$api_port $status"
    fi
  done

  if [ "$found" = false ]; then
    echo "  (none created yet)"
  fi

  # Show menu
  echo ""
  echo -e "${CYAN}Actions:${NC}"
  echo "  [1-9] Open workspace    [n] New    [r] Restart    [c] Cleanup    [q] Quit"
  echo ""
  printf "  > "

  read -r choice

  case "$choice" in
    q|Q|quit|exit|"")
      return 0
      ;;
    n|N|new)
      create_new_workspace
      ;;
    r|R|restart)
      echo -n "  Restart which workspace? [1-9]: "
      read -r ws_num
      if [[ "$ws_num" =~ ^[0-9]+$ ]]; then
        restart_workspace "$ws_num"
      else
        error "Invalid workspace number"
      fi
      ;;
    c|C|cleanup)
      echo -n "  Cleanup which workspace? [1-9]: "
      read -r ws_num
      if [[ "$ws_num" =~ ^[0-9]+$ ]]; then
        cleanup_workspace "$ws_num"
      else
        error "Invalid workspace number"
      fi
      ;;
    *)
      if [[ "$choice" =~ ^[0-9]+$ ]]; then
        open_workspace "$choice"
      else
        error "Unknown option: $choice"
      fi
      ;;
  esac
}

# Open or create workspace
open_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  # Create if doesn't exist
  if [ ! -d "$dir" ]; then
    create_workspace "$num"
  fi

  # Get port info
  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)
  local env_api_port=$(echo "$port_info" | cut -d: -f4)

  # Check dependencies
  check_and_setup_workspace "$dir" "$num"

  # Build commands from config
  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  # Port override if needed
  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    echo -e "${YELLOW}  Port $env_api_port in use, using $api_port instead${NC}"
  fi

  local port_msg="Using port $env_api_port"
  [ "$need_override" = "true" ] && port_msg="Port $env_api_port in use → using $api_port"

  # Check if session exists
  if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    # Create new session
    echo -e "${CYAN}Starting $SESSION_NAME session with workspace $num...${NC}"
    echo "  Directory: $dir"
    echo -e "  ${YELLOW}$port_msg${NC}"

    create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "new"
    tmux attach -t "$SESSION_NAME"
  else
    # Session exists
    if tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
      echo -e "${CYAN}Switching to workspace $num...${NC}"
      if [ -n "$TMUX" ]; then
        tmux select-window -t "$SESSION_NAME:$window_name"
      else
        tmux attach -t "$SESSION_NAME" \; select-window -t "$window_name"
      fi
    else
      echo -e "${CYAN}Adding workspace $num to session...${NC}"
      echo "  Directory: $dir"
      echo -e "  ${YELLOW}$port_msg${NC}"

      create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "$port_msg" "add"

      if [ -n "$TMUX" ]; then
        tmux select-window -t "$SESSION_NAME:$window_name"
      else
        tmux attach -t "$SESSION_NAME" \; select-window -t "$window_name"
      fi
    fi
  fi
}

# Create the tmux layout for a workspace
create_workspace_layout() {
  local window_name=$1
  local dir=$2
  local dev_cmd=$3
  local claude_cmd=$4
  local port_msg=$5
  local mode=$6  # "new" or "add"

  if [ "$mode" = "new" ]; then
    tmux new-session -d -s "$SESSION_NAME" -n "$window_name" -c "$dir"
  else
    tmux new-window -t "$SESSION_NAME" -n "$window_name" -c "$dir"
  fi

  # Create 3-pane layout:
  # ┌─────────┬─────────┐
  # │terminal │         │
  # ├─────────┤ main    │
  # │ server  │         │
  # └─────────┴─────────┘

  # Get pane indices (handles pane-base-index setting)
  local pane_indices=$(get_pane_indices)
  local p_terminal=$(echo "$pane_indices" | cut -d: -f1)
  local p_main=$(echo "$pane_indices" | cut -d: -f2)
  local p_server=$(echo "$pane_indices" | cut -d: -f3)

  # Create layout: start with one pane, split right for main, then split left for server
  tmux split-window -h -t "$SESSION_NAME:$window_name" -c "$dir"
  tmux select-pane -t "$SESSION_NAME:$window_name.$p_terminal"
  tmux split-window -v -t "$SESSION_NAME:$window_name" -c "$dir"

  # After splits: terminal=base, main=base+1, server=base+2
  [ -n "$dev_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" "echo '$port_msg' && $dev_cmd" C-m
  [ -n "$claude_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_main" "$claude_cmd" C-m
  tmux select-pane -t "$SESSION_NAME:$window_name.$p_main"
}

# Get command for a pane from config
get_pane_command() {
  local pane_name=$1
  local panes_count=$(yq -r '.layout.panes | length // 0' "$CONFIG_FILE" 2>/dev/null)

  for ((i=0; i<panes_count; i++)); do
    local name=$(yq -r ".layout.panes[$i].name" "$CONFIG_FILE" 2>/dev/null)
    if [ "$name" = "$pane_name" ]; then
      yq -r ".layout.panes[$i].command // \"\"" "$CONFIG_FILE" 2>/dev/null
      return
    fi
  done
  echo ""
}

# Check and setup workspace (dependencies, .env sync, shared volume)
check_and_setup_workspace() {
  local dir=$1
  local num=$2

  check_and_install_deps "$dir"

  # Setup shared volume (handles migration if needed)
  setup_shared_volume "$dir"

  echo -e "${BLUE}Syncing .env files for workspace $num...${NC}"
  sync_env_files "$dir" "$num"
}

# Check if dependencies need installing
check_and_install_deps() {
  local dir=$1
  local install_cmd=$(config_get "install_command" "")

  [ -z "$install_cmd" ] && return

  cd "$dir"

  local marker="$dir/node_modules/.crabcode-installed"
  local need_install="false"

  if [ ! -d "$dir/node_modules" ]; then
    need_install="true"
  elif [ ! -f "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/pnpm-lock.yaml" ] && [ "$dir/pnpm-lock.yaml" -nt "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/package-lock.json" ] && [ "$dir/package-lock.json" -nt "$marker" ]; then
    need_install="true"
  elif [ -f "$dir/yarn.lock" ] && [ "$dir/yarn.lock" -nt "$marker" ]; then
    need_install="true"
  fi

  if [ "$need_install" = "true" ]; then
    echo -e "${YELLOW}Installing dependencies...${NC}"
    if eval "$install_cmd"; then
      touch "$marker"
      echo -e "${GREEN}Dependencies installed${NC}"
    else
      error "Failed to install dependencies"
      return 1
    fi
  fi

  # Check submodule dependencies
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    local sub_install=$(yq -r ".submodules[$i].install_command // \"\"" "$CONFIG_FILE" 2>/dev/null)

    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue
    [ -z "$sub_install" ] || [ "$sub_install" = "null" ] && continue

    local sub_dir="$dir/$sub_path"
    if [ -d "$sub_dir" ]; then
      local sub_marker="$sub_dir/node_modules/.crabcode-installed"
      local sub_need_install="false"

      if [ ! -d "$sub_dir/node_modules" ]; then
        sub_need_install="true"
      elif [ ! -f "$sub_marker" ]; then
        sub_need_install="true"
      fi

      if [ "$sub_need_install" = "true" ]; then
        echo -e "${YELLOW}Installing $sub_path dependencies...${NC}"
        cd "$sub_dir"
        if eval "$sub_install"; then
          touch "$sub_marker"
          echo -e "${GREEN}$sub_path dependencies installed${NC}"
        else
          warn "Failed to install $sub_path dependencies"
        fi
        cd "$dir"
      fi
    fi
  done
}

# =============================================================================
# Cleanup / Restart / Continue
# =============================================================================

cleanup_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${YELLOW}Cleaning up workspace $num...${NC}"

  # Kill the window in the session if it exists
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    tmux kill-window -t "$SESSION_NAME:$window_name" 2>/dev/null || true
  fi

  # Kill any running processes for this workspace
  local kill_pattern=$(config_get "cleanup.kill_pattern" "")
  if [ -n "$kill_pattern" ]; then
    kill_pattern="${kill_pattern//\{N\}/$num}"
    kill_pattern="${kill_pattern//\{PREFIX\}/$WORKSPACE_PREFIX}"
    pkill -f "$kill_pattern" 2>/dev/null || true
  fi

  cd "$dir"

  echo "  Fetching origin..."
  git fetch origin

  echo "  Resetting to origin/main..."
  git checkout main 2>/dev/null || git checkout -b main origin/main
  git reset --hard origin/main

  echo "  Cleaning untracked files..."
  local exclude_pattern=$(config_get "cleanup.preserve_files" ".env")
  git clean -fd --exclude="$exclude_pattern"

  reset_submodules "$dir"

  success "Workspace $num cleaned and reset to origin/main"
}

restart_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"
  local branch_name=$(get_branch_name "$num")

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${YELLOW}Restarting workspace $num...${NC}"

  cd "$dir"

  local current_branch=$(git branch --show-current)

  echo "  Fetching origin..."
  git fetch origin

  if [ "$current_branch" != "$branch_name" ]; then
    echo "  Switching from $current_branch to $branch_name..."
    git checkout "$branch_name" 2>/dev/null || git checkout -b "$branch_name"
  fi

  echo "  Resetting $branch_name to origin/main content..."
  git reset --hard origin/main

  echo "  Cleaning untracked files..."
  local exclude_pattern=$(config_get "cleanup.preserve_files" ".env")
  git clean -fd --exclude="$exclude_pattern"

  reset_submodules "$dir"

  # Ensure shared volume is set up (migrates existing .local if needed)
  setup_shared_volume "$dir"

  success "Git reset complete (on branch: $branch_name)"

  # If we're in tmux and the window exists, restart the panes
  if [ -n "$TMUX" ] && tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
    local port_info=$(get_workspace_ports "$num" "$dir")
    local api_port=$(echo "$port_info" | cut -d: -f1)
    local app_port=$(echo "$port_info" | cut -d: -f2)
    local need_override=$(echo "$port_info" | cut -d: -f3)

    local dev_cmd=$(get_pane_command "server")
    local claude_cmd=$(get_pane_command "main")

    if [ "$need_override" = "true" ]; then
      dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    fi

    # Get pane indices
    local pane_indices=$(get_pane_indices)
    local p_terminal=$(echo "$pane_indices" | cut -d: -f1)
    local p_main=$(echo "$pane_indices" | cut -d: -f2)
    local p_server=$(echo "$pane_indices" | cut -d: -f3)

    echo "  Clearing terminal pane..."
    tmux send-keys -t "$SESSION_NAME:$window_name.$p_terminal" "clear" C-m

    echo "  Restarting server pane..."
    tmux respawn-pane -k -t "$SESSION_NAME:$window_name.$p_server" -c "$dir"
    sleep 0.5
    [ -n "$dev_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" "clear && $dev_cmd" C-m

    echo "  Restarting main pane..."
    tmux respawn-pane -k -t "$SESSION_NAME:$window_name.$p_main" -c "$dir"
    sleep 0.5
    [ -n "$claude_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_main" "clear && $claude_cmd" C-m

    success "Workspace $num restarted!"
  else
    echo -e "${YELLOW}  Not in tmux session - run 'crabcode $num' to start${NC}"
  fi
}

continue_workspace() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local window_name="ws$num"

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist at $dir"
    exit 1
  fi

  echo -e "${CYAN}Continuing workspace $num...${NC}"

  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)

  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  # Add --continue to claude command if it contains "claude"
  if [[ "$claude_cmd" == *"claude"* ]]; then
    claude_cmd="$claude_cmd --continue"
  fi

  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
  fi

  if [ -n "$TMUX" ] && tmux list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -q "^$window_name$"; then
    echo "  Window exists, restarting with --continue..."

    # Get pane indices
    local pane_indices=$(get_pane_indices)
    local p_main=$(echo "$pane_indices" | cut -d: -f2)
    local p_server=$(echo "$pane_indices" | cut -d: -f3)

    tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" C-c
    sleep 0.3
    [ -n "$dev_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_server" "$dev_cmd" C-m

    tmux respawn-pane -k -t "$SESSION_NAME:$window_name.$p_main" -c "$dir"
    sleep 0.5
    [ -n "$claude_cmd" ] && tmux send-keys -t "$SESSION_NAME:$window_name.$p_main" "clear && $claude_cmd" C-m

    success "Workspace $num continued with previous session"
  else
    echo "  Creating window with --continue..."
    create_workspace_layout "$window_name" "$dir" "$dev_cmd" "$claude_cmd" "" "add"

    if [ -n "$TMUX" ]; then
      tmux select-window -t "$SESSION_NAME:$window_name"
    fi

    success "Workspace $num started with previous session"
  fi
}

# Open workspace in separate terminal
open_workspace_separate() {
  local num=$1
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local session="$SESSION_NAME-$num"

  # Create if doesn't exist
  if [ ! -d "$dir" ]; then
    create_workspace "$num"
  fi

  local port_info=$(get_workspace_ports "$num" "$dir")
  local api_port=$(echo "$port_info" | cut -d: -f1)
  local app_port=$(echo "$port_info" | cut -d: -f2)
  local need_override=$(echo "$port_info" | cut -d: -f3)
  local env_api_port=$(echo "$port_info" | cut -d: -f4)

  echo -e "${CYAN}Starting workspace $num in separate window...${NC}"

  check_and_setup_workspace "$dir" "$num"

  local dev_cmd=$(get_pane_command "server")
  local claude_cmd=$(get_pane_command "main")

  if [ "$need_override" = "true" ]; then
    dev_cmd="PORT=$api_port APP_PORT=$app_port $dev_cmd"
    echo -e "${YELLOW}  Port $env_api_port in use, using $api_port instead${NC}"
  fi

  if tmux has-session -t "$session" 2>/dev/null; then
    if command_exists osascript; then
      osascript -e "tell application \"Terminal\" to do script \"tmux attach -t $session\""
    else
      echo "Open a new terminal and run: tmux attach -t $session"
    fi
  else
    tmux new-session -d -s "$session" -n "dev" -c "$dir"
    tmux split-window -h -t "$session" -c "$dir"
    tmux select-pane -t "$session:dev.1"
    tmux split-window -v -t "$session" -c "$dir"

    [ -n "$dev_cmd" ] && tmux send-keys -t "$session:dev.2" "$dev_cmd" C-m
    [ -n "$claude_cmd" ] && tmux send-keys -t "$session:dev.3" "$claude_cmd" C-m
    tmux select-pane -t "$session:dev.3"

    if command_exists osascript; then
      osascript -e "tell application \"Terminal\" to do script \"tmux attach -t $session\""
    else
      echo "Open a new terminal and run: tmux attach -t $session"
    fi
  fi
}

# Detect workspace number from current directory only (not tmux)
detect_workspace_from_dir() {
  local cwd=$(pwd)
  if [[ "$cwd" =~ $WORKSPACE_PREFIX-([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
    return
  fi
  echo ""
}

# Detect workspace number from current directory or tmux window
detect_workspace() {
  # First try: current directory
  local cwd=$(pwd)
  if [[ "$cwd" =~ $WORKSPACE_PREFIX-([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
    return
  fi

  # Second try: tmux window name (ws1, ws2, etc.)
  if [ -n "$TMUX" ]; then
    local window_name=$(tmux display-message -p '#{window_name}' 2>/dev/null)
    if [[ "$window_name" =~ ^ws([0-9]+)$ ]]; then
      echo "${BASH_REMATCH[1]}"
      return
    fi
  fi

  echo ""
}

# Find the next available workspace number
find_next_workspace() {
  local num=1
  while true; do
    local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
    if [ ! -d "$dir" ]; then
      echo "$num"
      return
    fi
    num=$((num + 1))
    # Safety limit
    if [ $num -gt 100 ]; then
      echo ""
      return
    fi
  done
}

# Create a new workspace with the next available number
create_new_workspace() {
  local next_num=$(find_next_workspace)

  if [ -z "$next_num" ]; then
    error "Could not find an available workspace number"
    exit 1
  fi

  echo -e "${CYAN}Creating new workspace $next_num...${NC}"
  open_workspace "$next_num"
}

# =============================================================================
# WIP Management
# =============================================================================

get_wip_dir() {
  local num=$1
  echo "$WIP_BASE/$WORKSPACE_PREFIX-$num"
}

wip_save() {
  local num=$1
  local do_restart=$2
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local wip_dir=$(get_wip_dir "$num")
  local timestamp=$(date +%Y%m%d-%H%M%S)
  local branch_name=$(get_branch_name "$num")

  if [ ! -d "$dir" ]; then
    error "Workspace $num does not exist"
    return 1
  fi

  echo -e "${CYAN}Saving WIP state for workspace $num...${NC}"

  cd "$dir"
  local diff=$(git diff HEAD 2>/dev/null || echo "")
  local staged=$(git diff --cached HEAD 2>/dev/null || echo "")
  local status=$(git status --porcelain 2>/dev/null || echo "")
  local branch=$(git branch --show-current 2>/dev/null || echo "unknown")

  git fetch origin main --quiet 2>/dev/null || true
  local commits_ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo "0")
  local commit_log=""
  if [ "$commits_ahead" -gt 0 ] 2>/dev/null; then
    commit_log=$(git log --oneline origin/main..HEAD 2>/dev/null || echo "")
  fi

  # Collect submodule changes
  local submodule_diffs=""
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local sub_diff=$(git diff HEAD 2>/dev/null || echo "")
      local sub_staged=$(git diff --cached HEAD 2>/dev/null || echo "")
      [ -n "$sub_diff" ] && submodule_diffs="$submodule_diffs$sub_diff"
      [ -n "$sub_staged" ] && submodule_diffs="$submodule_diffs$sub_staged"
      cd "$dir"
    fi
  done

  # Check if there's anything to save
  local has_changes="false"
  if [ -n "$diff" ] || [ -n "$staged" ] || [ -n "$status" ] || [ -n "$submodule_diffs" ]; then
    has_changes="true"
  elif [ "$commits_ahead" -gt 0 ] 2>/dev/null; then
    has_changes="true"
  elif [ "$branch" != "$branch_name" ] && [ "$branch" != "main" ]; then
    has_changes="true"
  fi

  if [ "$has_changes" = "false" ]; then
    echo -e "${YELLOW}No changes to save.${NC}"
    return 0
  fi

  local slug="wip-$(date +%H%M)"
  local summary="Work in progress"

  # Try to generate AI summary if claude is available
  if command_exists claude; then
    local all_diffs="$diff$staged$submodule_diffs"
    local summary_json=$(generate_wip_summary "$all_diffs")
    local parsed_slug=$(echo "$summary_json" | sed -n 's/.*"slug"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
    local parsed_summary=$(echo "$summary_json" | sed -n 's/.*"summary"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
    [ -n "$parsed_slug" ] && slug="$parsed_slug"
    [ -n "$parsed_summary" ] && summary="$parsed_summary"
  fi

  local wip_path="$wip_dir/$timestamp-$slug"
  mkdir -p "$wip_path"

  echo "  Saving patches..."
  [ -n "$diff" ] && echo "$diff" > "$wip_path/main-unstaged.patch"
  [ -n "$staged" ] && echo "$staged" > "$wip_path/main-staged.patch"
  [ -n "$status" ] && echo "$status" > "$wip_path/main-status.txt"
  [ -n "$commit_log" ] && echo "$commit_log" > "$wip_path/main-commits.txt"

  # Save submodule patches
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local sub_diff=$(git diff HEAD 2>/dev/null || echo "")
      local sub_staged=$(git diff --cached HEAD 2>/dev/null || echo "")
      local sub_status=$(git status --porcelain 2>/dev/null || echo "")
      local safe_name=$(echo "$sub_path" | tr '/' '-')
      [ -n "$sub_diff" ] && echo "$sub_diff" > "$wip_path/${safe_name}-unstaged.patch"
      [ -n "$sub_staged" ] && echo "$sub_staged" > "$wip_path/${safe_name}-staged.patch"
      [ -n "$sub_status" ] && echo "$sub_status" > "$wip_path/${safe_name}-status.txt"
      cd "$dir"
    fi
  done

  cat > "$wip_path/metadata.json" << EOF
{
  "timestamp": "$timestamp",
  "slug": "$slug",
  "summary": "$summary",
  "workspace": $num,
  "branch": "$branch",
  "commits_ahead": $commits_ahead,
  "created_at": "$(date -Iseconds)"
}
EOF

  success "WIP saved: $slug"
  echo -e "   ${BLUE}$summary${NC}"
  echo "   Location: $wip_path"

  if [ "$do_restart" = "true" ]; then
    echo ""
    restart_workspace "$num"
  fi
}

generate_wip_summary() {
  local diff_content="$1"
  local max_lines=100
  local truncated_diff=$(echo "$diff_content" | head -n $max_lines)

  if command_exists claude; then
    local prompt="Based on this git diff, provide a JSON response with exactly this format (no markdown, just raw JSON):
{\"slug\": \"short-kebab-case-name-max-30-chars\", \"summary\": \"One sentence describing the changes\"}

Git diff:
$truncated_diff"

    local result=$(echo "$prompt" | timeout 30 claude --print 2>/dev/null || echo "")

    if [ -n "$result" ]; then
      local json=$(echo "$result" | grep -o '{[^}]*}' | head -1)
      if [ -n "$json" ]; then
        echo "$json"
        return
      fi
    fi
  fi

  echo "{\"slug\": \"wip-$(date +%H%M)\", \"summary\": \"Work in progress\"}"
}

wip_list() {
  local num=$1
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    echo -e "${YELLOW}No WIP states saved for workspace $num${NC}"
    return 0
  fi

  local wips=($(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r))

  if [ ${#wips[@]} -eq 0 ]; then
    echo -e "${YELLOW}No WIP states saved for workspace $num${NC}"
    return 0
  fi

  echo -e "${CYAN}WIP States for Workspace $num${NC}"
  echo ""

  local i=1
  for wip in "${wips[@]}"; do
    local name=$(basename "$wip")
    local metadata="$wip/metadata.json"

    if [ -f "$metadata" ]; then
      local summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      local created=$(grep -o '"created_at"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"created_at"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      local branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')

      echo -e "  ${GREEN}[$i]${NC} $name"
      echo -e "      ${BLUE}$summary${NC}"
      echo -e "      Branch: $branch | Created: $created"
      echo ""
    else
      echo -e "  ${GREEN}[$i]${NC} $name (no metadata)"
      echo ""
    fi

    ((i++))
  done
}

# List all WIPs globally across all workspaces
wip_list_global() {
  if [ ! -d "$WIP_BASE" ]; then
    echo -e "${YELLOW}No WIP states saved${NC}"
    echo "  Save your work with: crab wip save"
    return 0
  fi

  # Collect all WIPs with their metadata
  local all_wips=()
  local wip_data=()

  # Scan all workspace WIP directories
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        # Get timestamp for sorting
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    echo -e "${YELLOW}No WIP states saved${NC}"
    echo "  Save your work with: crab wip save"
    return 0
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  echo -e "${CYAN}${BOLD}All WIP States${NC}"
  echo ""

  local i=1
  for entry in "${sorted_wips[@]}"; do
    local ws_name=$(echo "$entry" | cut -d'|' -f2)
    local wip_path=$(echo "$entry" | cut -d'|' -f3)
    local wip_name=$(basename "$wip_path")
    local metadata="$wip_path/metadata.json"

    # Extract workspace number from ws_name (e.g., cloud-workspace-1 -> 1)
    local ws_num=$(echo "$ws_name" | grep -o '[0-9]*$')

    # Count patch files
    local file_count=$(ls -1 "$wip_path"/*.patch 2>/dev/null | wc -l | tr -d ' ')
    [ -z "$file_count" ] && file_count=0

    if [ -f "$metadata" ]; then
      local summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      local created=$(grep -o '"created_at"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"created_at"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')

      # Handle both new format (branch) and old format (cloud_branch)
      local branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      if [ -z "$branch" ]; then
        branch=$(grep -o '"cloud_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"cloud_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
      fi

      # Handle both new format (commits_ahead) and old format (cloud_commits_ahead)
      local commits_ahead=$(grep -o '"commits_ahead"[[:space:]]*:[[:space:]]*[0-9]*' "$metadata" | sed 's/"commits_ahead"[[:space:]]*:[[:space:]]*//')
      if [ -z "$commits_ahead" ]; then
        commits_ahead=$(grep -o '"cloud_commits_ahead"[[:space:]]*:[[:space:]]*[0-9]*' "$metadata" | sed 's/"cloud_commits_ahead"[[:space:]]*:[[:space:]]*//')
      fi

      # Format the date nicely
      local display_date=$(echo "$created" | cut -d'T' -f1)
      local display_time=$(echo "$created" | cut -d'T' -f2 | cut -d'+' -f1 | cut -d'-' -f1 | cut -c1-5)

      echo -e "  ${GREEN}[$i]${NC} ${BOLD}$wip_name${NC}"
      echo -e "      ${BLUE}$summary${NC}"
      echo -e "      ${GRAY}Workspace: ${NC}$ws_num  ${GRAY}Branch: ${NC}$branch  ${GRAY}Files: ${NC}$file_count patches"
      if [ -n "$commits_ahead" ] && [ "$commits_ahead" != "0" ]; then
        echo -e "      ${GRAY}Commits ahead: ${NC}$commits_ahead  ${GRAY}Created: ${NC}$display_date $display_time"
      else
        echo -e "      ${GRAY}Created: ${NC}$display_date $display_time"
      fi
      echo ""
    else
      echo -e "  ${GREEN}[$i]${NC} ${BOLD}$wip_name${NC} ${GRAY}(no metadata)${NC}"
      echo -e "      ${GRAY}Workspace: ${NC}$ws_num  ${GRAY}Files: ${NC}$file_count patches"
      echo ""
    fi

    ((i++))
  done

  echo -e "${GRAY}Restore with: crab wip restore <number> [--to <workspace>]${NC}"
}

# Interactive restore from global WIP list
wip_restore_global() {
  local target_ws="${1:-}"

  if [ ! -d "$WIP_BASE" ]; then
    error "No WIP states found"
    return 1
  fi

  # Collect all WIPs
  local all_wips=()
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    error "No WIP states found"
    return 1
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  echo -e "${CYAN}Select WIP to restore:${NC}"
  echo ""

  local i=1
  for entry in "${sorted_wips[@]}"; do
    local ws_name=$(echo "$entry" | cut -d'|' -f2)
    local wip_path=$(echo "$entry" | cut -d'|' -f3)
    local wip_name=$(basename "$wip_path")
    local metadata="$wip_path/metadata.json"
    local ws_num=$(echo "$ws_name" | grep -o '[0-9]*$')
    local summary=""

    if [ -f "$metadata" ]; then
      summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    echo -e "  ${GREEN}[$i]${NC} $wip_name ${GRAY}(ws $ws_num)${NC}"
    [ -n "$summary" ] && echo -e "      ${BLUE}$summary${NC}"
    ((i++))
  done

  echo ""
  echo -e "  ${YELLOW}[0]${NC} Cancel"
  echo ""

  read -p "Select WIP [1-${#sorted_wips[@]}]: " selection

  if [ "$selection" = "0" ] || [ -z "$selection" ]; then
    echo "Cancelled."
    return 0
  fi

  if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#sorted_wips[@]} ]; then
    error "Invalid selection"
    return 1
  fi

  local selected_entry="${sorted_wips[$((selection-1))]}"
  local selected_ws=$(echo "$selected_entry" | cut -d'|' -f2)
  local selected_wip=$(echo "$selected_entry" | cut -d'|' -f3)
  local original_ws_num=$(echo "$selected_ws" | grep -o '[0-9]*$')

  # Determine target workspace
  local restore_to_ws="$original_ws_num"
  if [ -n "$target_ws" ]; then
    restore_to_ws="$target_ws"
  fi

  # Check if target workspace exists
  local target_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$restore_to_ws"
  if [ ! -d "$target_dir" ]; then
    echo -e "${YELLOW}Workspace $restore_to_ws does not exist.${NC}"
    read -p "Create it? [y/N]: " create_ws
    if [ "$create_ws" = "y" ] || [ "$create_ws" = "Y" ]; then
      create_workspace "$restore_to_ws"
    else
      echo "Cancelled."
      return 0
    fi
  fi

  local wip_name=$(basename "$selected_wip")
  echo ""
  echo -e "${CYAN}Restoring WIP: $wip_name -> workspace $restore_to_ws${NC}"

  _restore_wip "$restore_to_ws" "$selected_wip"
}

# Restore by index from global list
wip_restore_by_index() {
  local index="$1"
  local target_ws="$2"

  if [ ! -d "$WIP_BASE" ]; then
    error "No WIP states found"
    return 1
  fi

  # Collect all WIPs
  local all_wips=()
  for ws_dir in "$WIP_BASE"/*/; do
    [ ! -d "$ws_dir" ] && continue
    local ws_name=$(basename "$ws_dir")

    for wip in "$ws_dir"*/; do
      [ ! -d "$wip" ] && continue
      local metadata="$wip/metadata.json"
      if [ -f "$metadata" ]; then
        local timestamp=$(grep -o '"timestamp"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"timestamp"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        all_wips+=("$timestamp|$ws_name|$wip")
      else
        all_wips+=("00000000-000000|$ws_name|$wip")
      fi
    done
  done

  if [ ${#all_wips[@]} -eq 0 ]; then
    error "No WIP states found"
    return 1
  fi

  # Sort by timestamp (newest first)
  IFS=$'\n' sorted_wips=($(printf '%s\n' "${all_wips[@]}" | sort -r))
  unset IFS

  if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 1 ] || [ "$index" -gt ${#sorted_wips[@]} ]; then
    error "Invalid WIP index: $index (valid range: 1-${#sorted_wips[@]})"
    return 1
  fi

  local selected_entry="${sorted_wips[$((index-1))]}"
  local selected_ws=$(echo "$selected_entry" | cut -d'|' -f2)
  local selected_wip=$(echo "$selected_entry" | cut -d'|' -f3)
  local original_ws_num=$(echo "$selected_ws" | grep -o '[0-9]*$')

  # Determine target workspace
  local restore_to_ws="$original_ws_num"
  if [ -n "$target_ws" ]; then
    restore_to_ws="$target_ws"
  fi

  # Check if target workspace exists
  local target_dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$restore_to_ws"
  if [ ! -d "$target_dir" ]; then
    echo -e "${YELLOW}Workspace $restore_to_ws does not exist.${NC}"
    read -p "Create it? [y/N]: " create_ws
    if [ "$create_ws" = "y" ] || [ "$create_ws" = "Y" ]; then
      create_workspace "$restore_to_ws"
    else
      echo "Cancelled."
      return 0
    fi
  fi

  local wip_name=$(basename "$selected_wip")
  echo -e "${CYAN}Restoring WIP: $wip_name -> workspace $restore_to_ws${NC}"

  _restore_wip "$restore_to_ws" "$selected_wip"
}

wip_continue() {
  local num=$1
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local latest_wip=$(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r | head -1)

  if [ -z "$latest_wip" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local wip_name=$(basename "$latest_wip")
  echo -e "${CYAN}Restoring WIP: $wip_name${NC}"

  _restore_wip "$num" "$latest_wip"
}

wip_resume() {
  local num=$1
  local wip_dir=$(get_wip_dir "$num")

  if [ ! -d "$wip_dir" ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  local wips=($(ls -1d "$wip_dir"/*/ 2>/dev/null | sort -r))

  if [ ${#wips[@]} -eq 0 ]; then
    error "No WIP states found for workspace $num"
    return 1
  fi

  echo -e "${CYAN}Select WIP to restore:${NC}"
  echo ""

  local i=1
  for wip in "${wips[@]}"; do
    local name=$(basename "$wip")
    local metadata="$wip/metadata.json"
    local summary=""

    if [ -f "$metadata" ]; then
      summary=$(grep -o '"summary"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"summary"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    echo -e "  ${GREEN}[$i]${NC} $name"
    [ -n "$summary" ] && echo -e "      ${BLUE}$summary${NC}"
    ((i++))
  done

  echo ""
  echo -e "  ${YELLOW}[0]${NC} Cancel"
  echo ""

  read -p "Select WIP [1-${#wips[@]}]: " selection

  if [ "$selection" = "0" ] || [ -z "$selection" ]; then
    echo "Cancelled."
    return 0
  fi

  if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#wips[@]} ]; then
    error "Invalid selection"
    return 1
  fi

  local selected_wip="${wips[$((selection-1))]}"
  local wip_name=$(basename "$selected_wip")

  echo ""
  echo -e "${CYAN}Restoring WIP: $wip_name${NC}"

  _restore_wip "$num" "$selected_wip"
}

_restore_wip() {
  local num=$1
  local wip_path=$2
  local dir="$WORKSPACE_BASE/$WORKSPACE_PREFIX-$num"
  local wip_name=$(basename "$wip_path")
  local branch_name=$(get_branch_name "$num")

  local metadata="$wip_path/metadata.json"
  local saved_branch="$branch_name"
  if [ -f "$metadata" ]; then
    # Handle both new format (branch) and old format (cloud_branch)
    saved_branch=$(grep -o '"branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    if [ -z "$saved_branch" ]; then
      saved_branch=$(grep -o '"cloud_branch"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata" | sed 's/"cloud_branch"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi
    # If still empty, use default branch name
    if [ -z "$saved_branch" ]; then
      saved_branch="$branch_name"
    fi
  fi

  cd "$dir"

  local current_branch=$(git branch --show-current)
  if [ "$current_branch" != "$saved_branch" ] && [ -n "$saved_branch" ]; then
    echo "  Switching to branch $saved_branch..."
    git checkout "$saved_branch" 2>/dev/null || git checkout -b "$saved_branch"
  fi

  # Apply main patches
  if [ -f "$wip_path/main-staged.patch" ] && [ -s "$wip_path/main-staged.patch" ]; then
    echo "  Applying staged changes..."
    git apply "$wip_path/main-staged.patch" 2>/dev/null && git add -A || echo "    (some hunks may have failed)"
  fi

  if [ -f "$wip_path/main-unstaged.patch" ] && [ -s "$wip_path/main-unstaged.patch" ]; then
    echo "  Applying unstaged changes..."
    git apply "$wip_path/main-unstaged.patch" 2>/dev/null || echo "    (some hunks may have failed)"
  fi

  # Apply submodule patches
  local submodules_count=$(yq -r '.submodules | length // 0' "$CONFIG_FILE" 2>/dev/null)
  for ((i=0; i<submodules_count; i++)); do
    local sub_path=$(yq -r ".submodules[$i].path" "$CONFIG_FILE" 2>/dev/null)
    [ -z "$sub_path" ] || [ "$sub_path" = "null" ] && continue

    if [ -d "$dir/$sub_path" ]; then
      cd "$dir/$sub_path"
      local safe_name=$(echo "$sub_path" | tr '/' '-')

      if [ -f "$wip_path/${safe_name}-staged.patch" ] && [ -s "$wip_path/${safe_name}-staged.patch" ]; then
        echo "  Applying $sub_path staged changes..."
        git apply "$wip_path/${safe_name}-staged.patch" 2>/dev/null && git add -A || echo "    (some hunks may have failed)"
      fi

      if [ -f "$wip_path/${safe_name}-unstaged.patch" ] && [ -s "$wip_path/${safe_name}-unstaged.patch" ]; then
        echo "  Applying $sub_path unstaged changes..."
        git apply "$wip_path/${safe_name}-unstaged.patch" 2>/dev/null || echo "    (some hunks may have failed)"
      fi

      cd "$dir"
    fi
  done

  success "WIP restored: $wip_name"
  echo ""
  echo "  Run 'crabcode $num' to open the workspace"
  echo "  Or 'crabcode continue' to resume with --continue"
}

wip_delete() {
  local num=$1
  local wip_name=$2
  local wip_dir=$(get_wip_dir "$num")

  if [ -z "$wip_name" ]; then
    error "Usage: crabcode wip delete <wip-name>"
    return 1
  fi

  local wip_path="$wip_dir/$wip_name"

  if [ ! -d "$wip_path" ]; then
    wip_path=$(ls -1d "$wip_dir"/*"$wip_name"*/ 2>/dev/null | head -1)
  fi

  if [ ! -d "$wip_path" ]; then
    error "WIP not found: $wip_name"
    return 1
  fi

  local actual_name=$(basename "$wip_path")
  read -p "Delete WIP '$actual_name'? [y/N]: " confirm

  if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
    rm -rf "$wip_path"
    success "Deleted: $actual_name"
  else
    echo "Cancelled."
  fi
}

# =============================================================================
# Toolkit - Share
# =============================================================================

# Default exclude patterns for sharing (dependencies, build artifacts)
SHARE_EXCLUDE_PATTERNS=(
  "node_modules"
  ".git"
  "vendor"
  "venv"
  ".venv"
  "__pycache__"
  ".pytest_cache"
  "dist"
  "build"
  ".next"
  ".nuxt"
  "target"
  ".cache"
  "*.pyc"
  "*.pyo"
  ".DS_Store"
  "Thumbs.db"
)

# Create a clean archive of a path, excluding dependencies
# Returns the path to the created archive
tk_create_archive() {
  local source_path="$1"
  local include_git="${2:-false}"
  local include_deps="${3:-false}"

  local abs_path=$(cd "$source_path" 2>/dev/null && pwd || echo "$source_path")
  local base_name=$(basename "$abs_path")
  local timestamp=$(date +%Y%m%d-%H%M%S)
  local archive_name="${base_name}-${timestamp}.zip"
  local archive_path="/tmp/$archive_name"

  echo -e "${CYAN}Creating archive...${NC}"

  # Build exclude arguments for zip
  local exclude_args=""

  if [ "$include_deps" != "true" ]; then
    for pattern in "${SHARE_EXCLUDE_PATTERNS[@]}"; do
      # Skip .git if include_git is true
      if [ "$pattern" = ".git" ] && [ "$include_git" = "true" ]; then
        continue
      fi
      exclude_args="$exclude_args -x '$base_name/$pattern/*' -x '$base_name/$pattern'"
    done
    echo "  Excluding: dependencies and build artifacts"
  fi

  if [ "$include_git" != "true" ]; then
    echo "  Excluding: .git/"
  fi

  # Check if it's a git repo and respect .gitignore
  if [ -d "$abs_path/.git" ] || [ -f "$abs_path/.git" ]; then
    # Get list of gitignored files and add to excludes
    local gitignored=$(cd "$abs_path" && git ls-files --others --ignored --exclude-standard 2>/dev/null | head -100)
    if [ -n "$gitignored" ]; then
      echo "  Respecting: .gitignore patterns"
    fi
  fi

  # Create the archive
  cd "$(dirname "$abs_path")"

  # Use eval to properly handle the exclude args
  if eval "zip -rq '$archive_path' '$base_name' $exclude_args" 2>/dev/null; then
    local size=$(du -h "$archive_path" | cut -f1)
    echo -e "  ${GREEN}Created: $archive_name ($size)${NC}"
    echo "$archive_path"
  else
    error "Failed to create archive"
    return 1
  fi
}

# Upload to transfer.sh
tk_upload_transfersh() {
  local file_path="$1"
  local filename=$(basename "$file_path")
  local filesize=$(du -h "$file_path" | cut -f1)

  echo -e "${CYAN}Uploading to transfer.sh ($filesize)...${NC}"

  # Create temp file for error output
  local error_file=$(mktemp)

  # Use -f to fail silently on HTTP errors, capture response
  local response
  response=$(curl -f --progress-bar --upload-file "$file_path" "https://transfer.sh/$filename" 2>"$error_file")
  local curl_exit=$?

  # Read any error output
  local error_output=$(cat "$error_file" 2>/dev/null)
  rm -f "$error_file"

  if [ $curl_exit -eq 0 ] && [ -n "$response" ] && [[ "$response" == http* ]]; then
    echo ""
    echo -e "${GREEN}Upload complete!${NC}"
    echo ""
    echo -e "  URL: ${BOLD}$response${NC}"
    echo "  Expires: 14 days"
    echo ""

    # Copy to clipboard if possible
    if command_exists pbcopy; then
      echo -n "$response" | pbcopy
      echo "  (Copied to clipboard)"
    elif command_exists xclip; then
      echo -n "$response" | xclip -selection clipboard
      echo "  (Copied to clipboard)"
    fi

    return 0
  else
    # Show error details for debugging
    if [ -n "$error_output" ]; then
      echo -e "${YELLOW}transfer.sh error: $error_output${NC}" >&2
    fi
    if [ -n "$response" ] && [[ "$response" != http* ]]; then
      echo -e "${YELLOW}Unexpected response: $response${NC}" >&2
    fi
    return 1
  fi
}

# Upload to 0x0.st (alternative service)
tk_upload_0x0() {
  local file_path="$1"
  local filesize=$(du -h "$file_path" | cut -f1)

  echo -e "${CYAN}Uploading to 0x0.st ($filesize)...${NC}"

  # Create temp file for error output
  local error_file=$(mktemp)

  local response
  response=$(curl -f -F "file=@$file_path" https://0x0.st 2>"$error_file")
  local curl_exit=$?

  local error_output=$(cat "$error_file" 2>/dev/null)
  rm -f "$error_file"

  if [ $curl_exit -eq 0 ] && [ -n "$response" ] && [[ "$response" == http* ]]; then
    echo ""
    echo -e "${GREEN}Upload complete!${NC}"
    echo ""
    echo -e "  URL: ${BOLD}$response${NC}"
    echo ""

    # Copy to clipboard
    if command_exists pbcopy; then
      echo -n "$response" | pbcopy
      echo "  (Copied to clipboard)"
    elif command_exists xclip; then
      echo -n "$response" | xclip -selection clipboard
      echo "  (Copied to clipboard)"
    fi

    return 0
  else
    if [ -n "$error_output" ]; then
      echo -e "${YELLOW}0x0.st error: $error_output${NC}" >&2
    fi
    return 1
  fi
}

# Upload with automatic fallback between services
tk_upload_with_fallback() {
  local file_path="$1"

  # Try transfer.sh first
  if tk_upload_transfersh "$file_path"; then
    return 0
  fi

  echo ""
  echo -e "${YELLOW}transfer.sh failed, trying 0x0.st...${NC}"
  echo ""

  # Fallback to 0x0.st
  if tk_upload_0x0 "$file_path"; then
    return 0
  fi

  echo ""
  error "All upload services failed"
  echo "Try using SSH transfer instead: crab tk share <path> --to ssh:user@host"
  return 1
}

# Transfer via SSH/rsync
tk_transfer_ssh() {
  local file_path="$1"
  local destination="$2"

  # Parse destination: user@host:/path or just host
  local user_host="${destination%%:*}"
  local remote_path="${destination#*:}"

  # Default to ~/Downloads if no path specified
  if [ "$remote_path" = "$destination" ]; then
    remote_path="~/Downloads/"
  fi

  echo -e "${CYAN}Transferring via SSH...${NC}"
  echo "  Destination: $user_host:$remote_path"

  if command_exists rsync; then
    rsync -avz --progress "$file_path" "$user_host:$remote_path"
  else
    scp "$file_path" "$user_host:$remote_path"
  fi

  if [ $? -eq 0 ]; then
    echo ""
    success "Transfer complete!"
  else
    error "Transfer failed"
    return 1
  fi
}

# Upload to Slack
tk_upload_slack() {
  local file_path="$1"
  local target="${2:-}"

  # Use same token as crab slack commands
  local slack_token=$(config_get "slack.bot_token" "")

  # Check for slackcat first (easier)
  if command_exists slackcat && [ -n "$target" ]; then
    echo -e "${CYAN}Uploading to Slack via slackcat...${NC}"
    slackcat --channel "$target" "$file_path"
    return $?
  fi

  # Otherwise use curl with Slack API
  if [ -z "$slack_token" ]; then
    error "Slack not configured. Add to ~/.crabcode/config.yaml:"
    echo ""
    echo "slack:"
    echo "  bot_token: xoxb-your-bot-token"
    return 1
  fi

  if [ -z "$target" ]; then
    error "No target specified. Use --to slack:@user or --to slack:#channel"
    return 1
  fi

  # Resolve target to channel ID (supports @user and #channel)
  local channel_id
  if [[ "$target" == "@"* ]]; then
    local username="${target#@}"
    echo -e "${CYAN}Looking up user: $username...${NC}"
    local user_id=$(slack_get_user_id "$username")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
    echo -e "${CYAN}Uploading file to @$username...${NC}"
  else
    # Remove # prefix if present
    local channel_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$channel_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
    echo -e "${CYAN}Uploading file to #$channel_name...${NC}"
  fi

  # Step 1: Get upload URL (new Slack API)
  local filename=$(basename "$file_path")
  local filesize=$(stat -f%z "$file_path" 2>/dev/null || stat -c%s "$file_path" 2>/dev/null)

  local upload_response=$(curl -s -X POST "https://slack.com/api/files.getUploadURLExternal" \
    -H "Authorization: Bearer $slack_token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "filename=$filename&length=$filesize")

  local upload_url=$(echo "$upload_response" | jq -r '.upload_url // empty')
  local file_id=$(echo "$upload_response" | jq -r '.file_id // empty')

  if [ -z "$upload_url" ] || [ -z "$file_id" ]; then
    error "Failed to get upload URL from Slack"
    echo "$upload_response" | jq -r '.error // .'
    return 1
  fi

  # Step 2: Upload file to the URL
  curl -s -X POST "$upload_url" \
    -F "file=@$file_path" > /dev/null

  # Step 3: Complete upload and share to channel/DM
  local complete_response=$(curl -s -X POST "https://slack.com/api/files.completeUploadExternal" \
    -H "Authorization: Bearer $slack_token" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg file_id "$file_id" --arg channel_id "$channel_id" \
      '{files: [{id: $file_id}], channel_id: $channel_id}')")

  local ok=$(echo "$complete_response" | jq -r '.ok')
  if [ "$ok" = "true" ]; then
    echo ""
    success "File uploaded to $target!"
  else
    error "Failed to complete Slack upload"
    echo "$complete_response" | jq -r '.error // .'
    return 1
  fi
}

# Send via email
tk_send_email() {
  local file_path="$1"
  local recipient="$2"
  local filename=$(basename "$file_path")

  echo -e "${CYAN}Sending via email...${NC}"

  # Check for mutt (preferred for attachments)
  if command_exists mutt; then
    local subject="Shared file: $filename"
    local body="Shared via crabcode toolkit.\n\nFile: $filename"

    echo -e "$body" | mutt -s "$subject" -a "$file_path" -- "$recipient"

    if [ $? -eq 0 ]; then
      success "Email sent to $recipient"
      return 0
    else
      error "Failed to send email"
      return 1
    fi
  fi

  # macOS: Open in Mail.app
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "Opening Mail.app..."
    open -a Mail "$file_path"
    echo -e "${YELLOW}Please compose and send the email manually${NC}"
    return 0
  fi

  # Fallback: check for mail/mailx
  if command_exists mail; then
    echo -e "${YELLOW}Note: mail command may not support attachments on all systems${NC}"
    echo "File: $file_path"
    echo ""
    echo "To send manually:"
    echo "  echo 'See attached' | mutt -s 'Shared file' -a '$file_path' -- $recipient"
    return 1
  fi

  error "No email client found. Install mutt:"
  echo "  brew install mutt    # macOS"
  echo "  apt install mutt     # Linux"
  return 1
}

# Start local HTTP server
tk_serve() {
  local source_path="$1"
  local port="${2:-8080}"

  local abs_path=$(cd "$source_path" 2>/dev/null && pwd || echo "$source_path")

  # If it's a directory, create an archive first
  local file_to_serve="$abs_path"
  if [ -d "$abs_path" ]; then
    file_to_serve=$(tk_create_archive "$abs_path")
  fi

  local filename=$(basename "$file_to_serve")
  local filesize=$(du -h "$file_to_serve" | cut -f1)

  # Get local IP
  local local_ip=""
  if command_exists ipconfig; then
    # macOS
    local_ip=$(ipconfig getifaddr en0 2>/dev/null || ipconfig getifaddr en1 2>/dev/null)
  else
    # Linux
    local_ip=$(hostname -I 2>/dev/null | awk '{print $1}')
  fi

  echo ""
  echo -e "${CYAN}Starting file server...${NC}"
  echo ""
  echo -e "  File:    ${BOLD}$filename${NC} ($filesize)"
  echo -e "  Local:   ${BOLD}http://localhost:$port/$filename${NC}"
  [ -n "$local_ip" ] && echo -e "  Network: ${BOLD}http://$local_ip:$port/$filename${NC}"
  echo ""

  # Generate QR code if qrencode is available
  if command_exists qrencode && [ -n "$local_ip" ]; then
    echo "QR Code (scan to download):"
    qrencode -t ANSI256 "http://$local_ip:$port/$filename" 2>/dev/null || true
    echo ""
  fi

  echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
  echo ""

  # Create a temporary directory for serving
  local serve_dir=$(mktemp -d)
  cp "$file_to_serve" "$serve_dir/"

  # Use Python's built-in HTTP server
  if command_exists python3; then
    cd "$serve_dir" && python3 -m http.server "$port"
  elif command_exists python; then
    cd "$serve_dir" && python -m SimpleHTTPServer "$port"
  else
    error "Python not found. Cannot start HTTP server."
    rm -rf "$serve_dir"
    return 1
  fi

  # Cleanup
  rm -rf "$serve_dir"
}

# Main toolkit share handler
handle_tk_share() {
  local path="${1:-.}"
  shift || true

  # Parse options
  local to=""
  local include_git="false"
  local include_deps="false"
  local zip_only="false"
  local serve_mode="false"
  local port="8080"

  while [ $# -gt 0 ]; do
    case "$1" in
      --to)
        to="$2"
        shift 2
        ;;
      --to=*)
        to="${1#--to=}"
        shift
        ;;
      --include-git)
        include_git="true"
        shift
        ;;
      --include-deps)
        include_deps="true"
        shift
        ;;
      --zip)
        zip_only="true"
        shift
        ;;
      --serve)
        serve_mode="true"
        shift
        ;;
      --port)
        port="$2"
        shift 2
        ;;
      --port=*)
        port="${1#--port=}"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  # Validate path
  if [ ! -e "$path" ]; then
    error "Path not found: $path"
    return 1
  fi

  # Handle serve mode
  if [ "$serve_mode" = "true" ]; then
    tk_serve "$path" "$port"
    return $?
  fi

  # Create archive if it's a directory
  local file_to_share="$path"
  if [ -d "$path" ]; then
    file_to_share=$(tk_create_archive "$path" "$include_git" "$include_deps")
    if [ $? -ne 0 ]; then
      return 1
    fi
  fi

  # Just create zip
  if [ "$zip_only" = "true" ]; then
    local filename=$(basename "$file_to_share")
    local dest="./$filename"
    cp "$file_to_share" "$dest"
    success "Archive created: $dest"
    return 0
  fi

  # Handle different destinations
  case "$to" in
    ""|url)
      # Default: use auto-fallback between transfer.sh and 0x0.st
      tk_upload_with_fallback "$file_to_share"
      ;;
    transfer.sh)
      # Explicit transfer.sh (no fallback)
      tk_upload_transfersh "$file_to_share"
      ;;
    0x0|0x0.st)
      tk_upload_0x0 "$file_to_share"
      ;;
    ssh:*|scp:*|rsync:*)
      local dest="${to#*:}"
      tk_transfer_ssh "$file_to_share" "$dest"
      ;;
    slack:*|slack)
      local channel="${to#slack:}"
      [ "$channel" = "slack" ] && channel=""
      tk_upload_slack "$file_to_share" "$channel"
      ;;
    email:*|mail:*)
      local recipient="${to#*:}"
      tk_send_email "$file_to_share" "$recipient"
      ;;
    *)
      # Assume it's an SSH destination if it contains @
      if [[ "$to" == *"@"* ]]; then
        tk_transfer_ssh "$file_to_share" "$to"
      else
        error "Unknown destination: $to"
        echo "Use: --to=url, --to=ssh:user@host, --to=slack:#channel, --to=email:addr"
        return 1
      fi
      ;;
  esac
}

# Show toolkit help
show_tk_help() {
  echo -e "${CYAN}Toolkit Commands${NC}"
  echo ""
  echo "Share files and folders:"
  echo "  crab tk share <path>                    Upload and get temp URL"
  echo "  crab tk share <path> --to ssh:user@host Transfer via SSH"
  echo "  crab tk share <path> --to slack:#chan   Upload to Slack"
  echo "  crab tk share <path> --to email:addr    Send via email"
  echo "  crab tk share <path> --zip              Just create archive"
  echo "  crab tk share <path> --serve            Start local HTTP server"
  echo ""
  echo "Options:"
  echo "  --include-git     Include .git folder"
  echo "  --include-deps    Include dependencies (node_modules, etc.)"
  echo "  --port=8080       Port for --serve mode"
  echo ""
  echo "For git repos, automatically excludes:"
  echo "  node_modules, vendor, venv, dist, build, .git, etc."
}

# Handle toolkit subcommand
handle_tk_command() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    "share")
      handle_tk_share "$@"
      ;;
    "serve")
      tk_serve "${1:-.}" "${2:-8080}"
      ;;
    ""|"help"|"-h"|"--help")
      show_tk_help
      ;;
    *)
      error "Unknown toolkit command: $cmd"
      echo "Run 'crab tk help' for usage"
      return 1
      ;;
  esac
}

# =============================================================================
# Slack Integration
# =============================================================================

# Get Slack bot token from config
slack_get_token() {
  config_get "slack.bot_token" ""
}

# Get display name for messages (git config or override)
slack_get_display_name() {
  local configured=$(config_get "slack.display_name" "")
  if [ -n "$configured" ] && [ "$configured" != "null" ]; then
    echo "$configured"
  else
    git config user.name 2>/dev/null || whoami
  fi
}

# Lookup Slack user ID from @username
slack_get_user_id() {
  local username="$1"
  local token=$(slack_get_token)

  # Remove @ prefix if present
  username="${username#@}"

  # Get user list and find matching username
  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.list?limit=500")

  # Extract user ID where name or display_name matches
  echo "$response" | jq -r --arg name "$username" \
    '.members[] | select(.name == $name or .profile.display_name == $name or .real_name == $name) | .id' | head -1
}

# Lookup Slack channel ID from #channel
slack_get_channel_id() {
  local channel="$1"
  local token=$(slack_get_token)

  # Remove # prefix if present
  channel="${channel#\#}"

  # Get channel list
  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.list?types=public_channel,private_channel&limit=500")

  echo "$response" | jq -r --arg name "$channel" \
    '.channels[] | select(.name == $name) | .id' | head -1
}

# Open a DM channel with a user
slack_open_dm() {
  local user_id="$1"
  local token=$(slack_get_token)

  local response=$(curl -s -X POST -H "Authorization: Bearer $token" \
    -H "Content-Type: application/json" \
    -d "{\"users\":\"$user_id\"}" \
    "https://slack.com/api/conversations.open")

  echo "$response" | jq -r '.channel.id'
}

# Send a message to Slack
slack_post_message() {
  local channel_id="$1"
  local message="$2"
  local token=$(slack_get_token)
  local display_name=$(slack_get_display_name)

  # Format: 🦀 [Name] message - with crab icon as bot avatar
  local full_message="*[$display_name]* $message"

  local response=$(curl -s -X POST -H "Authorization: Bearer $token" \
    -H "Content-Type: application/json" \
    -d "$(jq -n \
      --arg channel "$channel_id" \
      --arg text "$full_message" \
      --arg username "crab ($display_name)" \
      '{channel: $channel, text: $text, icon_emoji: ":crab:", username: $username}')" \
    "https://slack.com/api/chat.postMessage")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" = "true" ]; then
    return 0
  else
    local err=$(echo "$response" | jq -r '.error')
    error "Slack API error: $err"
    return 1
  fi
}

# Read message history from a channel/DM
slack_read_history() {
  local channel_id="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.history?channel=$channel_id&limit=$limit")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" != "true" ]; then
    local err=$(echo "$response" | jq -r '.error')
    error "Failed to read history: $err"
    return 1
  fi

  # Parse and display messages (oldest first)
  echo "$response" | jq -r '.messages | reverse | .[] |
    "\(.ts | tonumber | strftime("%H:%M")) \(.user // "bot"): \(.text)"' 2>/dev/null
}

# Get username from user ID (for display)
slack_get_username() {
  local user_id="$1"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.info?user=$user_id")

  echo "$response" | jq -r '.user.profile.display_name // .user.real_name // .user.name'
}

# Cache for user ID to name mapping (file-based for bash 3.x compatibility)
SLACK_USER_CACHE_DIR="/tmp/crab-slack-cache-$$"

slack_get_username_cached() {
  local user_id="$1"
  local cache_file="$SLACK_USER_CACHE_DIR/$user_id"

  mkdir -p "$SLACK_USER_CACHE_DIR" 2>/dev/null

  if [ -f "$cache_file" ]; then
    cat "$cache_file"
  else
    local name=$(slack_get_username "$user_id")
    echo "$name" > "$cache_file"
    echo "$name"
  fi
}

# Format and display messages with usernames
slack_display_messages() {
  local channel_id="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/conversations.history?channel=$channel_id&limit=$limit")

  local ok=$(echo "$response" | jq -r '.ok')
  if [ "$ok" != "true" ]; then
    return 1
  fi

  # Get messages as JSON array (reversed for chronological order)
  local messages=$(echo "$response" | jq -c '.messages | reverse | .[]')

  while IFS= read -r msg; do
    local ts=$(echo "$msg" | jq -r '.ts | tonumber | strftime("%H:%M")')
    local user_id=$(echo "$msg" | jq -r '.user // empty')
    local text=$(echo "$msg" | jq -r '.text')
    local bot_name=$(echo "$msg" | jq -r '.bot_profile.name // empty')

    local sender
    if [ -n "$bot_name" ]; then
      sender="$bot_name"
    elif [ -n "$user_id" ]; then
      sender=$(slack_get_username_cached "$user_id")
    else
      sender="unknown"
    fi

    echo -e "${GRAY}[$ts]${NC} ${CYAN}$sender${NC}: $text"
  done <<< "$messages"
}

# Interactive chat mode
slack_chat() {
  local target="$1"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Add bot_token to ~/.crabcode/config.yaml"
    return 1
  fi

  # Resolve target to channel ID
  local channel_id
  local target_name

  if [[ "$target" == "#"* ]]; then
    target_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$target_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    target_name="${target#@}"
    local user_id=$(slack_get_user_id "$target_name")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  # Display chat header
  echo ""
  echo -e "${CYAN}━━ Chat with $target ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${GRAY}Type messages and press Enter. Ctrl+C to exit.${NC}"
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""

  # Show recent history
  slack_display_messages "$channel_id" 10

  echo ""
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

  # Chat loop
  local last_check=$(date +%s)

  while true; do
    # Non-blocking read with timeout for polling
    echo -ne "${GREEN}>${NC} "

    if read -t 5 -r message; then
      if [ -n "$message" ]; then
        if slack_post_message "$channel_id" "$message"; then
          echo -e "${GRAY}[sent]${NC}"
        fi
      fi
    fi

    # Poll for new messages every 5 seconds
    local now=$(date +%s)
    if [ $((now - last_check)) -ge 5 ]; then
      # Check for new messages (would need to track last seen timestamp for proper implementation)
      last_check=$now
    fi
  done
}

# Log file for sent messages
SLACK_SENT_LOG="$CONFIG_DIR/slack_sent.log"

# Log a sent message
slack_log_sent() {
  local target="$1"
  local message="$2"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local display_name=$(slack_get_display_name)

  mkdir -p "$CONFIG_DIR"
  echo "[$timestamp] $display_name → $target: $message" >> "$SLACK_SENT_LOG"
}

# View sent messages log
slack_view_sent() {
  local count="${1:-20}"

  if [ ! -f "$SLACK_SENT_LOG" ]; then
    echo "No sent messages yet."
    return
  fi

  echo -e "${CYAN}━━ Sent Messages ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  tail -n "$count" "$SLACK_SENT_LOG" | while IFS= read -r line; do
    echo -e "  ${GRAY}$line${NC}"
  done
  echo ""
}

# Quick send message
slack_send() {
  local target="$1"
  local message="$2"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Add bot_token to ~/.crabcode/config.yaml"
    return 1
  fi

  if [ -z "$target" ] || [ -z "$message" ]; then
    error "Usage: crab slack @user \"message\" or crab slack #channel \"message\""
    return 1
  fi

  # Resolve target to channel ID
  local channel_id

  if [[ "$target" == "#"* ]]; then
    local channel_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$channel_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    local username="${target#@}"
    local user_id=$(slack_get_user_id "$username")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  if slack_post_message "$channel_id" "$message"; then
    slack_log_sent "$target" "$message"
    success "Message sent to $target"
  fi
}

# Read recent messages from a conversation
slack_read() {
  local target="$1"
  local limit="${2:-10}"
  local token=$(slack_get_token)

  if [ -z "$token" ]; then
    error "Slack not configured. Add bot_token to ~/.crabcode/config.yaml"
    return 1
  fi

  if [ -z "$target" ]; then
    error "Usage: crab slack read @user [count]"
    return 1
  fi

  # Resolve target to channel ID
  local channel_id
  local target_name

  if [[ "$target" == "#"* ]]; then
    target_name="${target#\#}"
    channel_id=$(slack_get_channel_id "$target_name")
    if [ -z "$channel_id" ]; then
      error "Channel not found: $target"
      return 1
    fi
  elif [[ "$target" == "@"* ]]; then
    target_name="${target#@}"
    local user_id=$(slack_get_user_id "$target_name")
    if [ -z "$user_id" ]; then
      error "User not found: $target"
      return 1
    fi
    channel_id=$(slack_open_dm "$user_id")
    if [ -z "$channel_id" ] || [ "$channel_id" = "null" ]; then
      error "Failed to open DM with $target"
      return 1
    fi
  else
    error "Target must start with @ (user) or # (channel)"
    return 1
  fi

  echo ""
  echo -e "${CYAN}━━ Messages with $target ━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  slack_display_messages "$channel_id" "$limit"
  echo ""
}

# List available users
slack_list_users() {
  local token=$(slack_get_token)
  local filter="${1:-}"

  echo -e "${CYAN}Slack Users:${NC}"
  echo ""

  local response=$(curl -s -H "Authorization: Bearer $token" \
    "https://slack.com/api/users.list?limit=200")

  if [ -n "$filter" ]; then
    echo "$response" | jq -r --arg filter "$filter" \
      '.members[] | select(.deleted == false and .is_bot == false) | select(.name | contains($filter)) | "  @\(.name)  \(.profile.display_name // .real_name // "-")"'
  else
    echo "$response" | jq -r \
      '.members[] | select(.deleted == false and .is_bot == false) | "  @\(.name)  \(.profile.display_name // .real_name // "-")"'
  fi
}

# Handle slack command
handle_slack_command() {
  local first="${1:-}"

  if [ -z "$first" ]; then
    show_slack_help
    return
  fi

  case "$first" in
    "chat")
      shift
      slack_chat "$@"
      ;;
    "read"|"history")
      shift
      slack_read "$@"
      ;;
    "sent"|"log")
      shift
      slack_view_sent "$@"
      ;;
    "users"|"list")
      shift
      slack_list_users "$@"
      ;;
    "help"|"-h"|"--help")
      show_slack_help
      ;;
    "@"*|"#"*)
      # Quick send: crab slack @user "message" or crab slack #channel "message"
      local target="$1"
      shift
      local message="$*"
      slack_send "$target" "$message"
      ;;
    *)
      error "Unknown slack command: $first"
      show_slack_help
      return 1
      ;;
  esac
}

show_slack_help() {
  echo -e "${CYAN}Slack Commands${NC}"
  echo ""
  echo "Quick send:"
  echo "  crab slack @user \"message\"      Send DM to a user"
  echo "  crab slack #channel \"message\"   Post to a channel"
  echo ""
  echo "Read messages:"
  echo "  crab slack read @user           Show recent DMs with user"
  echo "  crab slack read #channel        Show recent channel messages"
  echo "  crab slack read @user 20        Show last 20 messages"
  echo ""
  echo "Interactive chat:"
  echo "  crab slack chat @user           Open chat session with user"
  echo "  crab slack chat #channel        Open chat session in channel"
  echo ""
  echo "Utilities:"
  echo "  crab slack sent                 View your sent messages log"
  echo "  crab slack sent 50              Show last 50 sent messages"
  echo "  crab slack users                List all users"
  echo "  crab slack users mike           Search users by name"
  echo ""
  echo "Examples:"
  echo "  crab slack @michael \"hey, can you review my PR?\""
  echo "  crab slack read @michael"
  echo "  crab slack chat @michael"
  echo ""
  echo "Configuration (~/.crabcode/config.yaml):"
  echo "  slack:"
  echo "    bot_token: xoxb-your-token"
  echo "    display_name: \"Your Name\"  # optional, defaults to git config"
}

# =============================================================================
# Init / Config / Doctor
# =============================================================================

show_init() {
  echo -e "${CYAN}Crabcode Setup${NC}"
  echo ""

  # Check for existing global config
  if config_exists; then
    echo -e "${YELLOW}Config already exists at $CONFIG_FILE${NC}"
    read -p "Overwrite? [y/N]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo "Cancelled."
      return
    fi
  fi

  # Check for project-level config in current directory
  local project_config="$(pwd)/.crabcode.yaml"
  if [ -f "$project_config" ]; then
    echo -e "${GREEN}Found project config: .crabcode.yaml${NC}"
    echo ""
    echo "This project has a crabcode config. Use it for your global setup?"
    read -p "  [Y/n]: " use_project
    if [ "$use_project" != "n" ] && [ "$use_project" != "N" ]; then
      mkdir -p "$CONFIG_DIR"
      cp "$project_config" "$CONFIG_FILE"

      # Update paths to absolute if they use relative paths
      local current_dir=$(pwd)

      # Check if main_repo needs updating (if it's relative or placeholder)
      local main_repo_val=$(yq -r '.main_repo // ""' "$CONFIG_FILE" 2>/dev/null)
      if [ -z "$main_repo_val" ] || [ "$main_repo_val" = "null" ] || [[ "$main_repo_val" == "~/"* ]] || [[ "$main_repo_val" == "./"* ]]; then
        yq -i ".main_repo = \"$current_dir\"" "$CONFIG_FILE"
        echo -e "  ${YELLOW}Set main_repo to: $current_dir${NC}"
      fi

      # Check if workspace_base needs updating
      local ws_base_val=$(yq -r '.workspace_base // ""' "$CONFIG_FILE" 2>/dev/null)
      if [ -z "$ws_base_val" ] || [ "$ws_base_val" = "null" ]; then
        local repo_name=$(basename "$current_dir")
        local default_base="$(dirname "$current_dir")/${repo_name}-workspaces"
        yq -i ".workspace_base = \"$default_base\"" "$CONFIG_FILE"
        echo -e "  ${YELLOW}Set workspace_base to: $default_base${NC}"
      fi

      echo ""
      success "Config created at $CONFIG_FILE"
      echo ""
      echo -e "${CYAN}Next steps:${NC}"
      echo "  1. Review config: crab config"
      echo "  2. Run 'crab config scan' if you need to detect ports"
      echo "  3. Run 'crab ws 1' to create your first workspace"
      return
    fi
    echo ""
  fi

  echo "Let's set up crabcode for your project."
  echo "(Minimal setup - run 'crab config scan' after to detect ports)"
  echo ""

  # Main repo
  local default_repo=$(pwd)
  echo -e "Path to your main repo"
  read -p "  [$default_repo]: " main_repo
  main_repo=${main_repo:-$default_repo}

  # Expand ~
  main_repo="${main_repo/#\~/$HOME}"

  if [ ! -d "$main_repo" ]; then
    error "Directory does not exist: $main_repo"
    return 1
  fi

  if [ ! -d "$main_repo/.git" ]; then
    warn "Not a git repository: $main_repo"
    read -p "Continue anyway? [y/N]: " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      return 1
    fi
  fi

  # Workspace base - derive from main repo
  local repo_name=$(basename "$main_repo")
  local repo_parent=$(dirname "$main_repo")
  local default_base="$repo_parent/${repo_name}-workspaces"

  echo ""
  echo -e "Where should workspaces be created?"
  echo -e "  (Each workspace is a git worktree, e.g., ${repo_name}-workspaces/ws-1)"
  read -p "  [$default_base]: " workspace_base
  workspace_base=${workspace_base:-$default_base}

  # Expand ~
  workspace_base="${workspace_base/#\~/$HOME}"

  # Create config directory
  mkdir -p "$CONFIG_DIR"

  # Generate minimal config file
  cat > "$CONFIG_FILE" << EOF
# Crabcode Configuration
# Generated by 'crabcode init'
# Run 'crab config scan' to auto-detect env files and ports

session_name: crab
workspace_base: $workspace_base
main_repo: $main_repo

workspaces:
  prefix: ws
  branch_pattern: workspace-{N}

layout:
  panes:
    - name: terminal
      command: ""
    - name: server
      command: ""
    - name: main
      command: ""

# Run 'crab config scan' to detect .env files and generate env_sync config
# Then edit this file to customize:
#
# env_sync:
#   files:
#     - path: .env
#       ports: [PORT, API_PORT]
#
# layout:
#   panes:
#     - name: terminal
#       command: ""
#     - name: server
#       command: "npm run dev"
#     - name: main
#       command: "claude"
#
# shared_volume:
#   enabled: true
#   path: ~/.crabcode/shared
#   link_as: .local
#
# submodules:
#   - path: my-submodule
#     reset_to: origin/main
EOF

  echo ""
  success "Config created at $CONFIG_FILE"
  echo ""
  echo -e "${CYAN}Next steps:${NC}"
  echo ""
  echo "  1. Run 'crab config scan' to detect .env files and ports"
  echo "  2. Edit $CONFIG_FILE to set your layout commands:"
  echo "     - server pane: your dev server command (e.g., pnpm dev)"
  echo "     - main pane: your main tool (e.g., claude)"
  echo "  3. Run 'crab ws 1' to create your first workspace"
  echo ""
}

# =============================================================================
# Config Scan - Discover env files and provide template
# =============================================================================

config_scan() {
  echo -e "${CYAN}Scanning for .env files...${NC}"
  echo ""

  if ! config_exists; then
    error "No config file found. Run 'crab init' first."
    return 1
  fi

  load_config

  local repo_path=$(expand_path "$MAIN_REPO")
  if [ ! -d "$repo_path" ]; then
    error "Main repo not found: $repo_path"
    return 1
  fi

  # Find all .env and .env.example files (bash 3.x compatible)
  local env_files=""
  local file_count=0

  while IFS= read -r file; do
    [ -z "$file" ] && continue
    env_files="$env_files$file"$'\n'
    file_count=$((file_count + 1))
  done < <(find "$repo_path" -maxdepth 3 -type f \( -name ".env" -o -name ".env.example" \) ! -path "*/node_modules/*" ! -path "*/.git/*" 2>/dev/null | sort)

  if [ $file_count -eq 0 ]; then
    echo "  No .env files found in $repo_path"
    echo ""
    echo "  You can manually configure env_sync in $CONFIG_FILE"
    return 0
  fi

  echo -e "Found ${GREEN}${file_count}${NC} env file(s):"
  echo ""

  # Group files by directory, prioritize .env over .env.example
  local dirs_seen=""
  local files_to_show=""

  echo "$env_files" | while IFS= read -r file; do
    [ -z "$file" ] && continue
    local rel_path="${file#$repo_path/}"
    local dir_path=$(dirname "$rel_path")
    local file_name=$(basename "$file")

    # Determine the target .env path (without .example)
    local target_path="$rel_path"
    local copy_from=""

    case "$file_name" in
      .env.example)
        target_path="${rel_path%.example}"
        # Check if .env exists (prioritize it)
        if [ -f "$repo_path/$target_path" ]; then
          # .env exists, skip .env.example
          continue
        fi
        copy_from="$rel_path"
        ;;
      .env)
        # Check if .env.example also exists
        if [ -f "$file.example" ]; then
          copy_from="${rel_path}.example"
        fi
        ;;
    esac

    echo -e "  ${BOLD}$target_path${NC}"
    if [ -n "$copy_from" ]; then
      echo -e "    └─ copy from: ${CYAN}$copy_from${NC}"
    fi
  done

  echo ""
  echo -e "${CYAN}Add to ~/.crabcode/config.yaml:${NC}"
  echo ""
  echo "env_sync:"
  echo "  files:"

  # Generate template
  local shown_paths=""
  echo "$env_files" | while IFS= read -r file; do
    [ -z "$file" ] && continue
    local rel_path="${file#$repo_path/}"
    local file_name=$(basename "$file")

    local target_path="$rel_path"
    local copy_from=""

    case "$file_name" in
      .env.example)
        target_path="${rel_path%.example}"
        if [ -f "$repo_path/$target_path" ]; then
          continue
        fi
        copy_from="$rel_path"
        ;;
      .env)
        if [ -f "$file.example" ]; then
          copy_from="${rel_path}.example"
        fi
        ;;
    esac

    # Skip if already shown
    case "$shown_paths" in
      *"$target_path"*) continue ;;
    esac
    shown_paths="$shown_paths $target_path"

    echo "    - path: $target_path"
    if [ -n "$copy_from" ]; then
      echo "      copy_from: $copy_from"
    fi
    echo "      ports: []           # e.g., [API_PORT, ADMIN_PORT]"
    echo "      # refs:             # optional: URL vars that reference ports"
    echo "      #   VITE_API_URL: API_PORT"
  done

  echo ""
  echo -e "${CYAN}How it works:${NC}"
  echo "  - ports: vars crab manages (increments per workspace, checks availability)"
  echo "  - refs: URL vars that reference a managed port (auto-rewritten)"
  echo "  - other vars: just copied from copy_from template"
  echo ""
  echo -e "${CYAN}Example for promptfoo-cloud:${NC}"
  echo ""
  echo "env_sync:"
  echo "  files:"
  echo "    - path: server/.env"
  echo "      copy_from: server/.env.example"
  echo "      ports: [API_PORT, ADMIN_PORT]"
  echo "    - path: app/.env"
  echo "      copy_from: app/.env.example"
  echo "      ports: [VITE_PORT]"
  echo "      refs:"
  echo "        VITE_API_URL: API_PORT"
}

show_config() {
  if ! config_exists; then
    echo -e "${YELLOW}No config file found.${NC}"
    echo "Run 'crabcode init' to create one."
    return
  fi

  echo -e "${CYAN}Crabcode Configuration${NC}"
  echo "File: $CONFIG_FILE"
  echo ""
  cat "$CONFIG_FILE"
}

show_doctor() {
  echo -e "${CYAN}Crabcode Doctor${NC}"
  echo ""

  local issues=0

  # Check yq
  echo -n "  yq: "
  if command_exists yq; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check tmux
  echo -n "  tmux: "
  if command_exists tmux; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check git
  echo -n "  git: "
  if command_exists git; then
    echo -e "${GREEN}installed${NC}"
  else
    echo -e "${RED}not installed${NC}"
    issues=$((issues + 1))
  fi

  # Check config
  echo -n "  config: "
  if config_exists; then
    echo -e "${GREEN}exists${NC}"

    # Validate config
    load_config

    echo -n "  session_name: "
    if [ -n "$SESSION_NAME" ]; then
      echo -e "${GREEN}$SESSION_NAME${NC}"
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

    echo -n "  workspace_base: "
    if [ -n "$WORKSPACE_BASE" ]; then
      if [ -d "$WORKSPACE_BASE" ] || [ -d "$(dirname "$WORKSPACE_BASE")" ]; then
        echo -e "${GREEN}$WORKSPACE_BASE${NC}"
      else
        echo -e "${YELLOW}$WORKSPACE_BASE (will be created)${NC}"
      fi
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

    echo -n "  main_repo: "
    if [ -n "$MAIN_REPO" ]; then
      if [ -d "$MAIN_REPO" ]; then
        echo -e "${GREEN}$MAIN_REPO${NC}"
      else
        echo -e "${RED}$MAIN_REPO (not found)${NC}"
        issues=$((issues + 1))
      fi
    else
      echo -e "${RED}not set${NC}"
      issues=$((issues + 1))
    fi

  else
    echo -e "${YELLOW}not found${NC}"
    echo ""
    echo "Run 'crabcode init' to create a config file."
    return
  fi

  # Check shared volume
  echo -n "  shared_volume: "
  if [ "$SHARED_VOLUME_ENABLED" = "true" ]; then
    if [ -d "$SHARED_VOLUME_PATH" ]; then
      echo -e "${GREEN}$SHARED_VOLUME_PATH${NC}"
    else
      echo -e "${YELLOW}$SHARED_VOLUME_PATH (will be created)${NC}"
    fi
  else
    echo -e "${YELLOW}disabled${NC}"
  fi

  echo ""
  if [ $issues -eq 0 ]; then
    success "All checks passed!"
  else
    echo -e "${RED}$issues issue(s) found${NC}"
  fi
}

# =============================================================================
# Help / Cheat Sheet
# =============================================================================

# Show shared volume info
show_shared() {
  load_config

  if [ "$SHARED_VOLUME_ENABLED" != "true" ]; then
    echo -e "${YELLOW}Shared volume is disabled.${NC}"
    echo ""
    echo "To enable, add to your config:"
    echo "  shared_volume:"
    echo "    enabled: true"
    return
  fi

  echo -e "${CYAN}Shared Volume${NC}"
  echo ""
  echo -e "  Path: ${GREEN}$SHARED_VOLUME_PATH${NC}"
  echo -e "  Link name: $SHARED_VOLUME_LINK"
  echo ""

  if [ -d "$SHARED_VOLUME_PATH" ]; then
    local count=$(ls -1 "$SHARED_VOLUME_PATH" 2>/dev/null | wc -l | tr -d ' ')
    echo "  Contents ($count items):"
    ls -la "$SHARED_VOLUME_PATH" 2>/dev/null | tail -n +2 | while read -r line; do
      echo "    $line"
    done
  else
    echo -e "  ${YELLOW}Not yet created (will be created on first workspace open)${NC}"
  fi
}

show_cheat() {
  cat << 'EOF'
╔═══════════════════════════════════════════════════════════════════════════════╗
║                            CRABCODE CHEAT SHEET                               ║
║                                                                               ║
║  Tip: Use 'crab' as shorthand for 'crabcode'                                  ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  WORKSPACE COMMANDS (crab ws ...)                                             ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab ws               Interactive menu (list + actions)                      ║
║  crab ws ls            List workspaces (non-interactive)                      ║
║  crab ws new           Create next available workspace                        ║
║  crab ws <N>           Open/create workspace N                                ║
║  crab ws <N> --separate   Open in new terminal window                         ║
║  crab ws <N> restart   Reset git + restart panes                              ║
║  crab ws <N> cleanup   Kill window + reset to origin/main                     ║
║  crab ws <N> continue  Resume with --continue flag                            ║
║                                                                               ║
║  SHORTCUTS (auto-detect workspace from cwd or tmux window)                    ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab restart          Restart current workspace                              ║
║  crab cleanup          Cleanup current workspace                              ║
║  crab continue         Continue current workspace                             ║
║  crab <N>              Shorthand for: crab ws <N>                             ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  WIP COMMANDS (crab wip ...)                                                  ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab wip save              Save current changes                              ║
║  crab wip save --restart    Save then restart workspace                       ║
║  crab wip ls                List all WIPs globally with metadata              ║
║  crab wip restore           Interactive restore from all WIPs                 ║
║  crab wip restore <N>       Restore WIP #N to original workspace              ║
║  crab wip restore <N> --to <ws>  Restore to different workspace               ║
║  crab wip --continue        Restore most recent WIP (current workspace)       ║
║  crab wip delete <name>     Delete a saved WIP state                          ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  TOOLKIT COMMANDS (crab tk ...)                                               ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab tk share <path>              Upload → temp URL (transfer.sh)            ║
║  crab tk share <path> --to ssh:... Transfer via SSH/rsync                     ║
║  crab tk share <path> --to slack:# Upload to Slack channel                    ║
║  crab tk share <path> --to email:@ Send via email                             ║
║  crab tk share <path> --serve      Start local HTTP server + QR code          ║
║  crab tk share <path> --zip        Just create local archive                  ║
║                                                                               ║
║  Options: --include-git, --include-deps, --port=8080                          ║
║  Auto-excludes: node_modules, .git, vendor, venv, dist, build...              ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  SLACK COMMANDS (crab slack ...)                                              ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab slack @user "msg"       Send DM to a user                               ║
║  crab slack #channel "msg"    Post to a channel                               ║
║  crab slack read @user        Show recent DMs with user                       ║
║  crab slack chat @user        Interactive terminal chat                       ║
║  crab slack sent              View your sent messages log                     ║
║  crab slack users             List all workspace users                        ║
║  crab slack users mike        Search users by name                            ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  OTHER COMMANDS                                                               ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  crab init             Minimal setup (2 questions)                            ║
║  crab config scan      Auto-detect .env files and ports                       ║
║  crab config           Show current configuration                             ║
║  crab doctor           Diagnose common issues                                 ║
║  crab ports            Show port usage across workspaces                      ║
║  crab shared           Show shared volume info                                ║
║  crab cheat            Show this cheat sheet                                  ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  TMUX KEYBINDINGS (Prefix = Ctrl+a)                                           ║
║  ────────────────────────────────────────────────────────────────────────     ║
║  Option+1,2,3...       Switch to workspace 1, 2, 3...                         ║
║  Ctrl+a  n/p           Next/previous window                                   ║
║  Ctrl+a  d             Detach from session                                    ║
║  Ctrl+a  z             Toggle pane zoom                                       ║
║  Option+←/→/↑/↓        Navigate panes                                         ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
EOF
}

show_help() {
  echo "crabcode v$VERSION - Workspace manager for multi-repo development"
  echo ""
  echo "Usage: crab [command] [arguments]"
  echo "       (crab is an alias for crabcode)"
  echo ""
  echo "Workspace Commands:"
  echo "  ws                List all workspaces"
  echo "  ws new            Create next available workspace"
  echo "  ws <N>            Open/create workspace N"
  echo "  ws <N> restart    Reset git + restart panes"
  echo "  ws <N> cleanup    Kill window + reset to origin/main"
  echo "  ws <N> continue   Resume with --continue flag"
  echo "  ws <N> --separate Open in new terminal window"
  echo ""
  echo "Shortcuts (auto-detect workspace):"
  echo "  <N>               Shorthand for: ws <N>"
  echo "  restart           Restart current workspace"
  echo "  cleanup           Cleanup current workspace"
  echo "  continue          Continue current workspace"
  echo ""
  echo "WIP Commands:"
  echo "  wip save          Save current changes"
  echo "  wip ls            List all WIPs globally"
  echo "  wip restore       Interactive restore from all WIPs"
  echo "  wip restore <N>   Restore WIP #N"
  echo "  wip restore <N> --to <ws>  Restore to different workspace"
  echo "  wip --continue    Restore most recent WIP (current workspace)"
  echo ""
  echo "Toolkit Commands:"
  echo "  tk share <path>   Share file/folder (temp URL)"
  echo "  tk share --to ssh:user@host   SSH transfer"
  echo "  tk share --to slack:#channel  Slack upload"
  echo "  tk share --serve  Local HTTP server"
  echo ""
  echo "Other Commands:"
  echo "  init              Minimal config setup (2 questions)"
  echo "  config            Show configuration"
  echo "  config scan       Auto-detect .env files and ports"
  echo "  doctor            Diagnose issues"
  echo "  ports             Show port usage"
  echo "  shared            Show shared volume info"
  echo "  cheat             Show cheat sheet"
  echo ""
  echo "Config: $CONFIG_FILE"
}

# =============================================================================
# Workspace Subcommand Handler
# =============================================================================

handle_ws_command() {
  local arg="${1:-}"
  shift || true

  case "$arg" in
    "")
      interactive_workspace_menu
      ;;
    "ls"|"list")
      list_workspaces
      ;;
    "new"|"create")
      create_new_workspace
      ;;
    *)
      if [[ "$arg" =~ ^[0-9]+$ ]]; then
        local num="$arg"
        case "${1:-}" in
          "cleanup"|"clean")
            cleanup_workspace "$num"
            ;;
          "restart"|"reset"|"refresh")
            restart_workspace "$num"
            ;;
          "continue"|"resume")
            continue_workspace "$num"
            ;;
          "--separate"|"-s"|"separate")
            open_workspace_separate "$num"
            ;;
          "wip")
            handle_wip_for_workspace "$num" "${@:2}"
            ;;
          "")
            open_workspace "$num"
            ;;
          *)
            error "Unknown command: crab ws $num $1"
            echo "Try: crab ws $num restart|cleanup|continue|wip"
            exit 1
            ;;
        esac
      else
        error "Invalid workspace argument: $arg"
        echo "Usage: crab ws <N> or crab ws new"
        exit 1
      fi
      ;;
  esac
}

# Handle WIP commands for a specific workspace
handle_wip_for_workspace() {
  local num=$1
  shift || true

  case "${1:-}" in
    "save")
      if [ "${2:-}" = "--restart" ] || [ "${2:-}" = "-r" ]; then
        wip_save "$num" "true"
      else
        wip_save "$num" "false"
      fi
      ;;
    "ls"|"list")
      wip_list "$num"
      ;;
    "--continue"|"-c")
      wip_continue "$num"
      ;;
    "--resume"|"-r"|"resume")
      wip_resume "$num"
      ;;
    "delete"|"rm")
      wip_delete "$num" "${2:-}"
      ;;
    *)
      echo -e "${CYAN}WIP Commands for workspace $num:${NC}"
      echo "  crab ws $num wip save [--restart]"
      echo "  crab ws $num wip ls"
      echo "  crab ws $num wip --continue"
      echo "  crab ws $num wip --resume"
      echo "  crab ws $num wip delete <name>"
      ;;
  esac
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
  case "${1:-}" in
    "")
      list_workspaces
      ;;
    "ws"|"workspace")
      load_config
      validate_config
      handle_ws_command "${@:2}"
      ;;
    "init")
      show_init
      ;;
    "config")
      if [ "${2:-}" = "scan" ]; then
        config_scan
      else
        show_config
      fi
      ;;
    "doctor")
      show_doctor
      ;;
    "cheat"|"help"|"-h"|"--help")
      if [ "${1:-}" = "cheat" ]; then
        show_cheat
      else
        show_help
      fi
      ;;
    "ports")
      show_ports
      ;;
    "shared")
      show_shared
      ;;
    "tk"|"toolkit")
      handle_tk_command "${@:2}"
      ;;
    "slack")
      handle_slack_command "${@:2}"
      ;;
    "new"|"create")
      # Shorthand: crab new -> crab ws new
      load_config
      validate_config
      create_new_workspace
      ;;
    "restart"|"reset"|"refresh")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> restart"
        exit 1
      fi
      restart_workspace "$num"
      ;;
    "continue"|"resume")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> continue"
        exit 1
      fi
      continue_workspace "$num"
      ;;
    "cleanup"|"clean")
      load_config
      validate_config
      num=$(detect_workspace)
      if [ -z "$num" ]; then
        error "Cannot detect workspace. Run from a workspace dir or use: crab ws <N> cleanup"
        exit 1
      fi
      cleanup_workspace "$num"
      ;;
    "wip")
      load_config
      validate_config
      num=$(detect_workspace)

      case "${2:-}" in
        "save")
          # Save requires being in a workspace
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab ws <N> wip save"
            exit 1
          fi
          if [ "${3:-}" = "--restart" ] || [ "${3:-}" = "-r" ]; then
            wip_save "$num" "true"
          else
            wip_save "$num" "false"
          fi
          ;;
        "ls"|"list")
          # List is global by default, unless --ws flag or physically in workspace
          local dir_ws=$(detect_workspace_from_dir)
          if [ "${3:-}" = "--ws" ] && [ -n "$num" ]; then
            # Explicitly request workspace-specific list
            wip_list "$num"
          elif [ -n "$dir_ws" ] && [ "${3:-}" != "--all" ] && [ "${3:-}" != "-a" ]; then
            # Physically in workspace directory, show workspace-specific
            wip_list "$dir_ws"
            echo -e "${GRAY}Use 'crab wip ls --all' to see all workspaces${NC}"
          else
            # Global view (default when not physically in workspace)
            wip_list_global
          fi
          ;;
        "restore")
          # Restore by index with optional target workspace
          local target_ws=""
          local index="${3:-}"

          # Parse --to flag
          if [ "${4:-}" = "--to" ] && [ -n "${5:-}" ]; then
            target_ws="${5}"
          fi

          if [ -z "$index" ]; then
            # Interactive restore
            wip_restore_global "$target_ws"
          else
            wip_restore_by_index "$index" "$target_ws"
          fi
          ;;
        "--continue"|"-c")
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab wip restore"
            exit 1
          fi
          wip_continue "$num"
          ;;
        "--resume"|"-r"|"resume")
          if [ -z "$num" ]; then
            # Global interactive restore
            wip_restore_global
          else
            wip_resume "$num"
          fi
          ;;
        "delete"|"rm")
          if [ -z "$num" ]; then
            error "Not in a workspace directory. Use: crab ws <N> wip delete <name>"
            exit 1
          fi
          wip_delete "$num" "${3:-}"
          ;;
        *)
          echo -e "${CYAN}WIP Commands:${NC}"
          echo ""
          if [ -n "$num" ]; then
            echo -e "  ${BOLD}In workspace $num:${NC}"
            echo "    crab wip save [--restart]  Save current changes"
            echo "    crab wip ls                List WIPs for this workspace"
            echo "    crab wip --continue        Restore most recent WIP"
            echo "    crab wip --resume          Interactive WIP selection"
            echo "    crab wip delete <name>     Delete a WIP state"
            echo ""
          fi
          echo -e "  ${BOLD}Global commands:${NC}"
          echo "    crab wip ls                List all WIPs (global view)"
          echo "    crab wip restore           Interactive restore from all WIPs"
          echo "    crab wip restore <N>       Restore WIP #N to its original workspace"
          echo "    crab wip restore <N> --to <ws>  Restore WIP #N to workspace <ws>"
          ;;
      esac
      ;;
    "--version"|"-v")
      echo "crabcode v$VERSION"
      ;;
    *)
      # Backwards compatibility: crab <N> -> crab ws <N>
      if [[ "$1" =~ ^[0-9]+$ ]]; then
        load_config
        validate_config
        handle_ws_command "$@"
      else
        error "Unknown command: $1"
        echo ""
        echo "Usage: crab ws <N>       Open workspace N"
        echo "       crab ws new       Create new workspace"
        echo "       crab restart      Restart current workspace"
        echo "       crab wip save     Save work in progress"
        echo "       crab cheat        Show all commands"
        exit 1
      fi
      ;;
  esac
}

main "$@"
